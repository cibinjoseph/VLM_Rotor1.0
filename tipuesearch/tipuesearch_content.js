var tipuesearch = {"pages":[{"title":" VOLCANOR ","text":"VOLCANOR An object-oriented, parallelized, unsteady vortex lattice solver for multi-rotor/wing analysis written in Fortran. This solver was developed from scratch as part of my PhD to study rotorcraft aerodynamics. It was written to be as generalized as possible in order to handle aircraft configurations consisting of multiple wings and rotors. However, it is far from complete and is yet to develop into an easy-to-use software. For this reason, it is constantly evolving and users are encouraged to improve it if possible. Developer Info Cibin Joseph Research Associate at IIT Madras, India","tags":"home","loc":"index.html"},{"title":"C81_class – VOLCANOR ","text":"type, public :: C81_class Base class for C81 performance data Contents Variables airfoilName ML NL MD ND MM NM MaL MaD MaM AL AD AM CL CD CM Type-Bound Procedures writefile readfile getCL getCD getCM Components Type Visibility Attributes Name Initial character(len=30), public :: airfoilName Airfoil name in C81 file integer, public :: ML No. of lift coefficient machs integer, public :: NL No. of lift coefficient alphas integer, public :: MD No. of drag coefficient machs integer, public :: ND No. of drag coefficient alphas integer, public :: MM No. of moment coefficient machs integer, public :: NM No. of moment coefficient alphas real(kind=dp), public, allocatable, dimension(:) :: MaL Machs for lift real(kind=dp), public, allocatable, dimension(:) :: MaD Machs for drag real(kind=dp), public, allocatable, dimension(:) :: MaM Machs for moment real(kind=dp), public, allocatable, dimension(:) :: AL Alphas for lift real(kind=dp), public, allocatable, dimension(:) :: AD Alphas for drag real(kind=dp), public, allocatable, dimension(:) :: AM Alphas for moment real(kind=dp), public, allocatable, dimension(:,:) :: CL Lift coefficient real(kind=dp), public, allocatable, dimension(:,:) :: CD Drag coefficient real(kind=dp), public, allocatable, dimension(:,:) :: CM Moment coefficient Type-Bound Procedures procedure, public,  :: writefile public  subroutine writefile (this, C81filename) Writes C81 class data to C81 file Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename procedure, public,  :: readfile public  subroutine readfile (this, C81filename) Reads from C81 file to C81 class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename procedure, public,  :: getCL public  function getCL (this, alphaQuery, machQuery) Returns value of 2-d linear interpolated CL\nfor a given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) procedure, public,  :: getCD public  function getCD (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CD\nfor given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) procedure, public,  :: getCM public  function getCM (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CM\nfor given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp)","tags":"","loc":"type/c81_class.html"},{"title":"switches_class – VOLCANOR ","text":"type, public :: switches_class Switches that determine solver options Contents Variables ntSub ntSubInit wakeDissipation wakeStrain wakeBurst wakeSuppress slowStart slowStartNt wakeTipPlot wakePlot gridPlot rotorForcePlot fdScheme probe nProbes initWakeVelNt restartFromNt restartWriteNt Components Type Visibility Attributes Name Initial integer, public :: ntSub No. of timesteps for sub-iterations [+/-n] integer, public :: ntSubInit No. of timesteps for initial sub-iterations [+/-n] integer, public :: wakeDissipation Wake dissipation [0, 1] integer, public :: wakeStrain Wake strain [0, 1] integer, public :: wakeBurst Wake burst on exceeding skew value [0, 1] integer, public :: wakeSuppress Suppress wake (for testing and non-lifting surfaces) [0, 1] integer, public :: slowStart Slow start to avoid large starting vortex [0, 1] integer, public :: slowStartNt Slow start to avoid large starting vortex [+/-n] integer, public :: wakeTipPlot Plot wake tip every nth timestep [+/-n] integer, public :: wakePlot Plot full wake every nth timestep [+/-n] integer, public :: gridPlot Record vortices for field computation every nth timestep [+/-n] integer, public :: rotorForcePlot Plot rotor forces every nth timestep [+/-n] integer, public :: fdScheme Choose finite-difference scheme [0,1,...,5] integer, public :: probe Use probes for recording velocity [0,1] integer, public :: nProbes No. of probes [n] integer, public :: initWakeVelNt Use initial velocity for convecting away starting vortex [0, 1] integer, public :: restartFromNt Restart from nth timestep [n] integer, public :: restartWriteNt Write restart files every nth timestep for restarting later [n]","tags":"","loc":"type/switches_class.html"},{"title":"vf_class – VOLCANOR ","text":"type, public :: vf_class Vortex filament class Contents Variables fc l0 lc rVc0 rVc age ageAzimuthal Type-Bound Procedures vind calclength strain Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(3, 2) :: fc Filament coords (xyz, 1:2) real(kind=dp), public :: l0 = 0._dp Original length real(kind=dp), public :: lc = 0._dp Current length real(kind=dp), public :: rVc0 = 0._dp Initial vortex core radius real(kind=dp), public :: rVc = 0._dp Current vortex core radius real(kind=dp), public :: age = 0._dp Vortex age (in seconds) real(kind=dp), public :: ageAzimuthal = 0._dp vortex age (in radians) Type-Bound Procedures procedure, public,  :: vind => vf_vind public  function vf_vind (this, P) result(vind) Compute induced velocity by unit strength vortex filament Arguments Type Intent Optional Attributes Name class( vf_class ) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: calclength => vf_calclength public  subroutine vf_calclength (this, isOriginal) Compute length of vortex filament Arguments Type Intent Optional Attributes Name class( vf_class ) :: this logical, intent(in) :: isOriginal procedure, public,  :: strain => vf_strain public  subroutine vf_strain (this) Arguments Type Intent Optional Attributes Name class( vf_class ) :: this","tags":"","loc":"type/vf_class.html"},{"title":"vr_class – VOLCANOR ","text":"type, public :: vr_class Vortex ring class Contents Variables vf gam skew Type-Bound Procedures vind vindSource assignP shiftdP rot calclength strain decay calc_skew burst mirror Components Type Visibility Attributes Name Initial type( vf_class ), public, dimension(4) :: vf real(kind=dp), public :: gam Circulation real(kind=dp), public :: skew Skew parameter Type-Bound Procedures procedure, public,  :: vind => vr_vind public  function vr_vind (this, P) result(vind) Compute induced velocity by unit strength 4-element vortex ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vindSource => vr_vindSource public  function vr_vindSource (this, P, nCap) result(vind) Compute induced velocity by unit strength 3-element source ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in), dimension(3) :: P real(kind=dp), intent(in), dimension(3) :: nCap Return Value real(kind=dp), dimension(3) procedure, public,  :: assignP => vr_assignP public  subroutine vr_assignP (this, n, P) Assign coordinates to nth corner Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: n real(kind=dp), dimension(3) :: P procedure, public,  :: shiftdP => vr_shiftdP public  subroutine vr_shiftdP (this, n, dshift) Shift coordinates of nth corner by dshift distance \n(usually for U*dt convection) Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: dshift procedure, public,  :: rot => vr_rot public  subroutine vr_rot (this, Tmat, originVec) Rotate vortex ring using Tmat about origin Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in), dimension(3, 3) :: Tmat real(kind=dp), optional, dimension(3) :: originVec procedure, public,  :: calclength => vr_calclength public  subroutine vr_calclength (this, isOriginal) Calculate length of filaments in vortex ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this logical, intent(in) :: isOriginal procedure, public,  :: strain => vr_strain public  subroutine vr_strain (this) Arguments Type Intent Optional Attributes Name class( vr_class ) :: this procedure, public,  :: decay => vr_decay public  subroutine vr_decay (this, dt, decayCoeff) Arguments Type Intent Optional Attributes Name class( vr_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: decayCoeff procedure, public,  :: calc_skew public  subroutine calc_skew (this) Compute skew Arguments Type Intent Optional Attributes Name class( vr_class ) :: this procedure, public,  :: burst => vr_burst public  subroutine vr_burst (this, skewLimit) Burst vortex filaments if skewLimit is exceeded Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in) :: skewLimit procedure, public,  :: mirror => vr_mirror public  subroutine vr_mirror (this, coordNum) Mirror gamma and coordinates about a specified plane Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: coordNum","tags":"","loc":"type/vr_class.html"},{"title":"wingpanel_class – VOLCANOR ","text":"type, public :: wingpanel_class Wing panel class Contents Variables vr gamPrev gamTrapz PC CP nCap tauCapChord tauCapSpan velCP velCPTotal velCPm normalForce normalForceUnsteady chordwiseResVel velPitch delP delPUnsteady delDiConstant delDiUnsteady meanChord meanSpan panelArea rHinge alpha Type-Bound Procedures assignP calcCP calcN invertNcap calcTau rot shiftdP calc_chordwiseResVel calc_area calc_mean_dimensions isCPinsidecore Components Type Visibility Attributes Name Initial type( vr_class ), public :: vr real(kind=dp), public :: gamPrev Circulation at previous timestep real(kind=dp), public :: gamTrapz Circulation after trapezoidal integration real(kind=dp), public, dimension(3, 4) :: PC Panel coords (xyz, 1:4) real(kind=dp), public, dimension(3) :: CP Collocation point coords real(kind=dp), public, dimension(3) :: nCap Unit normal vector real(kind=dp), public, dimension(3) :: tauCapChord Unit tangential vector along chord real(kind=dp), public, dimension(3) :: tauCapSpan Unit tangential vector along span real(kind=dp), public, dimension(3) :: velCP Local vel at CP excluding wing vortices real(kind=dp), public, dimension(3) :: velCPTotal Local vel at CP including wing vortices real(kind=dp), public, dimension(3) :: velCPm Local vel at CP due to wing motion real(kind=dp), public, dimension(3) :: normalForce Normal force vector (inertial frame) real(kind=dp), public, dimension(3) :: normalForceUnsteady Unsteady part of normal force vector (inertial frame) real(kind=dp), public, dimension(3) :: chordwiseResVel Chordwise resultant velocity vector real(kind=dp), public :: velPitch Airfoil pitch velocity about rHinge real(kind=dp), public :: delP Pressure difference between upper and lower surfaces at panel real(kind=dp), public :: delPUnsteady Unsteady pressure at panel real(kind=dp), public :: delDiConstant Induced drag (constant part) at panel real(kind=dp), public :: delDiUnsteady Induced drag (unsteady part) at panel real(kind=dp), public :: meanChord Panel mean chord real(kind=dp), public :: meanSpan Panel mean span real(kind=dp), public :: panelArea Panel area for computing lift real(kind=dp), public :: rHinge Dist to point about which airfoil pitching occurs (LE of wing) real(kind=dp), public :: alpha Local angle of attack (in radians) Type-Bound Procedures procedure, public,  :: assignP => wingpanel_assignP public  subroutine wingpanel_assignP (this, n, P) Assign coordinates to nth corner Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this integer, intent(in) :: n real(kind=dp), dimension(3) :: P procedure, public,  :: calcCP => wingpanel_calcCP public  subroutine wingpanel_calcCP (this, isTriangle) Compute collocation point location Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle procedure, public,  :: calcN => wingpanel_calcN public  subroutine wingpanel_calcN (this, isTriangle) Compute normal vector Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle procedure, public,  :: invertNcap => wingpanel_invertNcap public  subroutine wingpanel_invertNcap (this) Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this procedure, public,  :: calcTau => wingpanel_calcTau public  subroutine wingpanel_calcTau (this, isTriangle) Compute chordwise and spanwise tangential vectors Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle procedure, public,  :: rot => wingpanel_rot public  subroutine wingpanel_rot (this, Tmat, originVec) Rotate panel using transformation matrix Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this real(kind=dp), dimension(3, 3) :: Tmat real(kind=dp), optional, dimension(3) :: originVec procedure, public,  :: shiftdP => wingpanel_shiftdP public  subroutine wingpanel_shiftdP (this, dshift) Shift corners of vortex ring by dshift Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift procedure, public,  :: calc_chordwiseResVel => wingpanel_calc_chordwiseResVel public  subroutine wingpanel_calc_chordwiseResVel (this) Compute panel resultant velocities using local velocities Arguments Type Intent Optional Attributes Name class( wingpanel_class ), intent(inout) :: this procedure, public,  :: calc_area => wingpanel_calc_area public  subroutine wingpanel_calc_area (this) Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this procedure, public,  :: calc_mean_dimensions => wingpanel_calc_mean_dimensions public  subroutine wingpanel_calc_mean_dimensions (this) Calculate mean chord and mean span Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this procedure, public,  :: isCPinsidecore => wingpanel_isCPinsidecore public  function wingpanel_isCPinsidecore (this) Check whether collocation point lies\ninside viscous core region of vortex ring Arguments Type Intent Optional Attributes Name class( wingpanel_class ), intent(in) :: this Return Value logical","tags":"","loc":"type/wingpanel_class.html"},{"title":"Nwake_class – VOLCANOR ","text":"type, public :: Nwake_class Near wake class Contents Variables vr Components Type Visibility Attributes Name Initial type( vr_class ), public :: vr","tags":"","loc":"type/nwake_class.html"},{"title":"Fwake_class – VOLCANOR ","text":"type, public :: Fwake_class Far wake class Contents Variables vf gam Type-Bound Procedures shiftdP assignP rot decay mirror Components Type Visibility Attributes Name Initial type( vf_class ), public :: vf real(kind=dp), public :: gam = 0._dp Circulation Type-Bound Procedures procedure, public,  :: shiftdP => Fwake_shiftdP public  subroutine Fwake_shiftdP (this, n, dshift) Shift coordinates of nth corner by dshift distance\n(usually for Udt convection) Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: dshift procedure, public,  :: assignP => Fwake_assignP public  subroutine Fwake_assignP (this, n, P) Assign point to nth endpoint of filament Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: P procedure, public,  :: rot => Fwake_rot public  subroutine Fwake_rot (this, TMat, originVec) Rotate using TMat about originVec Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this real(kind=dp), intent(in), dimension(3, 3) :: TMat real(kind=dp), optional, dimension(3) :: originVec procedure, public,  :: decay => Fwake_decay public  subroutine Fwake_decay (this, dt, decayCoeff) Arguments Type Intent Optional Attributes Name class( Fwake_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: decayCoeff procedure, public,  :: mirror => Fwake_mirror public  subroutine Fwake_mirror (this, coordNum) Mirror gamma and coordinates about a specified plane Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: coordNum","tags":"","loc":"type/fwake_class.html"},{"title":"pFwake_class – VOLCANOR ","text":"type, public :: pFwake_class Prescribed far wake Contents Variables waF coords nRevs helixPitch helixRadius relaxFactor isClockwiseRotor isPresent Type-Bound Procedures update rot_wake_axis Components Type Visibility Attributes Name Initial type( Fwake_class ), public, dimension(240) :: waF real(kind=dp), public, dimension(3, 241) :: coords real(kind=dp), public :: nRevs = 10.0 real(kind=dp), public :: helixPitch = 0._dp real(kind=dp), public :: helixRadius = 0._dp real(kind=dp), public :: relaxFactor = 0.5_dp logical, public :: isClockwiseRotor = .True. logical, public :: isPresent = .false. Type-Bound Procedures procedure, public,  :: update => pFwake_update public  subroutine pFwake_update (this, waF, hubCoords, shaftAxis, deltaPsi) Arguments Type Intent Optional Attributes Name class( pFwake_class ), intent(inout) :: this type( Fwake_class ), intent(in), dimension(:) :: waF real(kind=dp), intent(in), dimension(3) :: hubCoords real(kind=dp), intent(in), dimension(3) :: shaftAxis real(kind=dp), intent(in) :: deltaPsi procedure, public,  :: rot_wake_axis => pFwake_rot_wake_axis public  subroutine pFwake_rot_wake_axis (this, theta, axisVec, origin) Arguments Type Intent Optional Attributes Name class( pFwake_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta real(kind=dp), intent(in), dimension(3) :: axisVec real(kind=dp), intent(in), dimension(3) :: origin","tags":"","loc":"type/pfwake_class.html"},{"title":"blade_class – VOLCANOR ","text":"type, public :: blade_class Single blade class Contents Variables id wiP waN waF wapF wapFPredicted waNPredicted waFPredicted C81 nc ns theta psi pivotLE preconeAngle velWakeMax flapInitial dflapInitial flapPrev dflapPrev flap dflap Iflap kflap cflap MflapConstant MflapLift MflapLiftPrev flapOrigin forceInertial lift drag dragInduced dragProfile liftUnsteady dragUnsteady airfoilNo airfoilFile airfoilSectionLimit velNwake velNwake1 velNwake2 velNwake3 velNwakePredicted velNwakeStep velFwake velFwake1 velFwake2 velFwake3 velFwakePredicted velFwakeStep stlNodesCols stlNodes stlElementNodes xAxis yAxis zAxis xAxisAzi yAxisAzi zAxisAzi xAxisAziFlap yAxisAziFlap zAxisAziFlap secChord secArea secForceInertial secLift secDrag secLiftDir secDragDir secLiftInPlane secLiftOutPlane secDragInduced secDragProfile secLiftUnsteady secDragUnsteady secLiftInPlaneUnsteady secLiftOutPlaneUnsteady secTauCapChord secTauCapSpan secNormalVec secCP secChordwiseResVel secAlpha secPhi secTheta secViz secVix secCD secCM secMflap secMflapArm alpha0 secCL secCLu spanwiseLiftSwitch Type-Bound Procedures move rotate rot_pitch rot_wake_axis rot_pts rot_flap vind_bywing vindSource_bywing vind_bywing_boundVortices vind_bywing_chordwiseVortices vind_boundVortex vind_bywake convectwake limitWakeVel calc_secChord calc_secArea calc_force calc_force_alpha calc_force_alphaGamma calc_secAlpha calc_secChordwiseResVel burst_wake calc_skew calc_secLocations lookup_secCoeffs secCoeffsToSecForces dirLiftDrag sumSecToNetForces calc_stlStats computeBladeDynamics getddflap blade_write write(unformatted) blade_read read(unformatted) Components Type Visibility Attributes Name Initial character(len=2), public :: id type( wingpanel_class ), public, allocatable, dimension(:, :) :: wiP Wing panel type( Nwake_class ), public, allocatable, dimension(:, :) :: waN Near wake type( Fwake_class ), public, allocatable, dimension(:) :: waF Far wake type( pFwake_class ), public :: wapF Prescribed far wake type( pFwake_class ), public :: wapFPredicted Prescribed far wake type( Nwake_class ), public, allocatable, dimension(:, :) :: waNPredicted type( Fwake_class ), public, allocatable, dimension(:) :: waFPredicted type( C81_class ), public, allocatable, dimension(:) :: C81 integer, public :: nc No. of chordwise panels integer, public :: ns No. of spanwise panels real(kind=dp), public :: theta real(kind=dp), public :: psi real(kind=dp), public :: pivotLE Location of pivot from LE (x/c) for setting pitch angle real(kind=dp), public :: preconeAngle Precone angle for blade real(kind=dp), public :: velWakeMax Max vel on wake collocation points for preventing blowup real(kind=dp), public :: flapInitial real(kind=dp), public :: dflapInitial real(kind=dp), public :: flapPrev real(kind=dp), public :: dflapPrev real(kind=dp), public :: flap real(kind=dp), public :: dflap real(kind=dp), public :: Iflap real(kind=dp), public :: kflap real(kind=dp), public :: cflap real(kind=dp), public :: MflapConstant real(kind=dp), public :: MflapLift real(kind=dp), public :: MflapLiftPrev real(kind=dp), public, dimension(3) :: flapOrigin real(kind=dp), public, dimension(3) :: forceInertial real(kind=dp), public, dimension(3) :: lift real(kind=dp), public, dimension(3) :: drag real(kind=dp), public, dimension(3) :: dragInduced real(kind=dp), public, dimension(3) :: dragProfile real(kind=dp), public, dimension(3) :: liftUnsteady real(kind=dp), public, dimension(3) :: dragUnsteady integer, public, allocatable, dimension(:) :: airfoilNo character(len=30), public, allocatable, dimension(:) :: airfoilFile real(kind=dp), public, allocatable, dimension(:) :: airfoilSectionLimit real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake1 real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake2 real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake3 real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwakePredicted real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwakeStep real(kind=dp), public, allocatable, dimension(:, :) :: velFwake real(kind=dp), public, allocatable, dimension(:, :) :: velFwake1 real(kind=dp), public, allocatable, dimension(:, :) :: velFwake2 real(kind=dp), public, allocatable, dimension(:, :) :: velFwake3 real(kind=dp), public, allocatable, dimension(:, :) :: velFwakePredicted real(kind=dp), public, allocatable, dimension(:, :) :: velFwakeStep integer, public :: stlNodesCols real(kind=dp), public, allocatable, dimension(:, :) :: stlNodes integer, public, allocatable, dimension(:, :) :: stlElementNodes real(kind=dp), public, dimension(3) :: xAxis real(kind=dp), public, dimension(3) :: yAxis real(kind=dp), public, dimension(3) :: zAxis real(kind=dp), public, dimension(3) :: xAxisAzi real(kind=dp), public, dimension(3) :: yAxisAzi real(kind=dp), public, dimension(3) :: zAxisAzi real(kind=dp), public, dimension(3) :: xAxisAziFlap real(kind=dp), public, dimension(3) :: yAxisAziFlap real(kind=dp), public, dimension(3) :: zAxisAziFlap real(kind=dp), public, allocatable, dimension(:) :: secChord real(kind=dp), public, allocatable, dimension(:) :: secArea real(kind=dp), public, allocatable, dimension(:, :) :: secForceInertial real(kind=dp), public, allocatable, dimension(:, :) :: secLift real(kind=dp), public, allocatable, dimension(:, :) :: secDrag real(kind=dp), public, allocatable, dimension(:, :) :: secLiftDir real(kind=dp), public, allocatable, dimension(:, :) :: secDragDir real(kind=dp), public, allocatable, dimension(:, :) :: secLiftInPlane real(kind=dp), public, allocatable, dimension(:, :) :: secLiftOutPlane real(kind=dp), public, allocatable, dimension(:, :) :: secDragInduced real(kind=dp), public, allocatable, dimension(:, :) :: secDragProfile real(kind=dp), public, allocatable, dimension(:, :) :: secLiftUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secDragUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secLiftInPlaneUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secLiftOutPlaneUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secTauCapChord real(kind=dp), public, allocatable, dimension(:, :) :: secTauCapSpan real(kind=dp), public, allocatable, dimension(:, :) :: secNormalVec real(kind=dp), public, allocatable, dimension(:, :) :: secCP real(kind=dp), public, allocatable, dimension(:, :) :: secChordwiseResVel real(kind=dp), public, allocatable, dimension(:) :: secAlpha real(kind=dp), public, allocatable, dimension(:) :: secPhi real(kind=dp), public, allocatable, dimension(:) :: secTheta real(kind=dp), public, allocatable, dimension(:) :: secViz real(kind=dp), public, allocatable, dimension(:) :: secVix real(kind=dp), public, allocatable, dimension(:) :: secCD real(kind=dp), public, allocatable, dimension(:) :: secCM real(kind=dp), public, allocatable, dimension(:) :: secMflap real(kind=dp), public, allocatable, dimension(:) :: secMflapArm real(kind=dp), public, allocatable, dimension(:) :: alpha0 real(kind=dp), public, allocatable, dimension(:) :: secCL real(kind=dp), public, allocatable, dimension(:) :: secCLu integer, public :: spanwiseLiftSwitch Type-Bound Procedures procedure, public,  :: move => blade_move public  subroutine blade_move (this, dshift) Move blade by dshift Arguments Type Intent Optional Attributes Name class( blade_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift procedure, public,  :: rotate => blade_rotate public  subroutine blade_rotate (this, angleRad, axisX, axisY, axisZ, originX, originY, originZ, rotateType) Rotate blade geometry about axis at specified origin\nRotation angle in radians Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), value :: angleRad real(kind=dp), intent(in), value :: axisX real(kind=dp), intent(in), value :: axisY real(kind=dp), intent(in), value :: axisZ real(kind=dp), intent(in), value :: originX real(kind=dp), intent(in), value :: originY real(kind=dp), intent(in), value :: originZ character(len=*), intent(in) :: rotateType procedure, public,  :: rot_pitch => blade_rot_pitch public  subroutine blade_rot_pitch (this, theta) Rotate blade by pitch angle about pivotLE Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta procedure, public,  :: rot_wake_axis => blade_rot_wake_axis public  subroutine blade_rot_wake_axis (this, theta, axisVec, origin, rowNear, rowFar, wakeType) Rotate wake about axis at specified origin Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta real(kind=dp), intent(in), dimension(3) :: axisVec real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: rowNear integer, intent(in) :: rowFar character(len=1), intent(in) :: wakeType procedure, public,  :: rot_pts => blade_rot_pts public  subroutine blade_rot_pts (this, pts, origin, order) Rotate blade using pts. pts refers to (phi, theta, psi) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: pts real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: order procedure, public,  :: rot_flap => blade_rot_flap public  subroutine blade_rot_flap (this, beta) Rotate blade by flap angle Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: beta procedure, public,  :: vind_bywing => blade_vind_bywing public  function blade_vind_bywing (this, P) Compute induced velocity by blade bound vorticity Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vindSource_bywing => blade_vindSource_bywing public  function blade_vindSource_bywing (this, P) Compute induced velocity by blade bound vorticity Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vind_bywing_boundVortices => blade_vind_bywing_boundVortices public  function blade_vind_bywing_boundVortices (this, P) Compute induced velocity by bound vortices alone Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vind_bywing_chordwiseVortices => blade_vind_bywing_chordwiseVortices public  function blade_vind_bywing_chordwiseVortices (this, P) Compute induced velocity by bound vortices alone Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vind_boundVortex => blade_vind_boundVortex public  function blade_vind_boundVortex (this, ic, is, P) Compute induced velocity by bound vortices alone Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: ic integer, intent(in) :: is real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vind_bywake => blade_vind_bywake public  function blade_vind_bywake (this, rowNear, rowFar, P, optionalChar) Compute induced velocity by wake vortex rings Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar real(kind=dp), intent(in), dimension(3) :: P character(len=1), optional :: optionalChar Return Value real(kind=dp), dimension(3) procedure, public,  :: convectwake => blade_convectwake public  subroutine blade_convectwake (this, rowNear, rowFar, dt, wakeType) Convect wake collocation points using velNwake matrix Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType procedure, public,  :: limitWakeVel => blade_limitWakeVel public  subroutine blade_limitWakeVel (this, rowNear, rowFar) Limits all wake velocity to a set value to prevent blow up Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar procedure, public,  :: calc_secChord public  subroutine calc_secChord (this) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this procedure, public,  :: calc_secArea public  subroutine calc_secArea (this) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this procedure, public,  :: calc_force => blade_calc_force public  subroutine blade_calc_force (this, density, Omega, dt) Compute force using blade circulation Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: Omega real(kind=dp), intent(in) :: dt procedure, public,  :: calc_force_alpha => blade_calc_force_alpha public  subroutine blade_calc_force_alpha (this, density, velSound) Compute force using sectional alpha Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound procedure, public,  :: calc_force_alphaGamma => blade_calc_force_alphaGamma public  subroutine blade_calc_force_alphaGamma (this, density, invertGammaSign, velSound, dt) Compute force using alpha approximated from sec circulation Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: invertGammaSign real(kind=dp), intent(in) :: velSound real(kind=dp), intent(in) :: dt procedure, public,  :: calc_secAlpha => blade_calc_secAlpha public  subroutine blade_calc_secAlpha (this, verticalAxis) Compute sec alpha using sec resultant velocity Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: verticalAxis procedure, public,  :: calc_secChordwiseResVel => blade_calc_secChordwiseResVel public  subroutine blade_calc_secChordwiseResVel (this) Compute sectional resultant vel by interpolating local panel vel Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this procedure, public,  :: burst_wake => blade_burst_wake public  subroutine blade_burst_wake (this, rowFar, skewLimit, largeCoreRadius) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowFar real(kind=dp), intent(in) :: skewLimit real(kind=dp), intent(in) :: largeCoreRadius procedure, public,  :: calc_skew => blade_calc_skew public  subroutine blade_calc_skew (this, rowNear) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear procedure, public,  :: calc_secLocations => blade_calc_secLocations public  subroutine blade_calc_secLocations (this, chordwiseFraction, flapHingeRadius) Compute important locations at each section\ncoordinates of collocation point located at chord fraction\nflap moment arm Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: chordwiseFraction real(kind=dp), intent(in) :: flapHingeRadius procedure, public,  :: lookup_secCoeffs => blade_lookup_secCoeffs public  subroutine blade_lookup_secCoeffs (this, velSound) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: velSound procedure, public,  :: secCoeffsToSecForces => blade_secCoeffsToSecForces public  subroutine blade_secCoeffsToSecForces (this, density) Convert force coefficients to dimensional forces Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density procedure, public,  :: dirLiftDrag => blade_dirLiftDrag public  subroutine blade_dirLiftDrag (this, Omega) Compute lift and drag direction vectors Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: Omega procedure, public,  :: sumSecToNetForces => blade_sumSecToNetForces public  subroutine blade_sumSecToNetForces (this) Sum up sectional forces to net forces Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this procedure, public,  :: calc_stlStats => blade_calc_stlStats public  subroutine blade_calc_stlStats (this) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this procedure, public,  :: computeBladeDynamics => blade_computeBladeDynamics public  subroutine blade_computeBladeDynamics (this, dt, omega) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: omega procedure, public,  :: getddflap public  function getddflap (this, flap, dflap, omega, MflapLift) Returns ddflap from blade flap equation Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in) :: flap real(kind=dp), intent(in) :: dflap real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: MflapLift Return Value real(kind=dp) procedure, public,  :: blade_write public  subroutine blade_write (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg generic, public,  :: write(unformatted) => blade_write public  subroutine blade_write (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public,  :: blade_read public  subroutine blade_read (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg generic, public,  :: read(unformatted) => blade_read public  subroutine blade_read (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"type/blade_class.html"},{"title":"rotor_class – VOLCANOR ","text":"type, public :: rotor_class Rotor class Contents Variables id nb ns nc nNwake nFwake nbConvect nNwakeEnd nFwakeEnd blade Omega omegaSlow shaftAxis xAxisBody yAxisBody zAxisBody hubCoords cgCoords fromCoords radius chord root_cut preconeAngle dpitch flapInitial dflapInitial Iflap cflap kflap MflapConstant forceInertial lift liftPrev drag dragInduced dragProfile liftUnsteady dragUnsteady liftUnitVec dragUnitVec sideUnitVec controlPitch thetaTwist pivotLE flapHinge velBody omegaBody velBodyPrev omegaBodyPrev velBodyHistory omegaBodyHistory psi pts streamwiseCoreSwitch spanwiseCore streamwiseCoreVec AIC AIC_inv gamVec gamVecPrev RHS camberSectionLimit airfoilSectionLimit alpha0 initWakeVel psiStart skewLimit apparentViscCoeff decayCoeff rollupStartRadius rollupEndRadius propConvention spanSpacing chordSpacing overrideTauSpan symmetricTau wakeTruncateNt prescWakeNt prescWakeAfterTruncNt prescWakeGenNt rollupStart rollupEnd suppressFwakeSwitch forceCalcSwitch skewPlotSwitch inflowPlotSwitch bladeDynamicsSwitch pitchDynamicsSwitch bodyDynamicsSwitch bodyDynamicsIOVars spanwiseLiftSwitch customTrajectorySwitch gammaPlotSwitch rowNear rowFar nCamberFiles nAirfoils imagePlane imageRotorNum surfaceType axisymmetrySwitch camberFile airfoilFile geometryFile nonDimforceDenominator Type-Bound Procedures readGeom init deinit plot3dtoblade stltoblade getCamber gettheta getthetadot move rot_pts rot_advance rot_flap assignshed map_gam age_wake dissipate_wake strain_wake calcAIC vind_bywing vind_bywing_boundVortices vind_bywake shiftwake shiftFwake rollup calc_force calc_force_alpha calc_force_alphaGamma calc_secAlpha convectwake burst_wake calc_skew dirLiftDrag sumBladeToNetForces mirrorGamma mirrorVelCP mirrorWake toChordsRevs eraseNwake eraseFwake updatePrescribedWake computeBladeDynamics getdw computeBodyDynamics rotor_write write(unformatted) rotor_read read(unformatted) Components Type Visibility Attributes Name Initial character(len=2), public :: id integer, public :: nb integer, public :: ns integer, public :: nc integer, public :: nNwake integer, public :: nFwake integer, public :: nbConvect integer, public :: nNwakeEnd integer, public :: nFwakeEnd type( blade_class ), public, allocatable, dimension(:) :: blade real(kind=dp), public :: Omega real(kind=dp), public :: omegaSlow real(kind=dp), public, dimension(3) :: shaftAxis real(kind=dp), public, dimension(3) :: xAxisBody real(kind=dp), public, dimension(3) :: yAxisBody real(kind=dp), public, dimension(3) :: zAxisBody real(kind=dp), public, dimension(3) :: hubCoords real(kind=dp), public, dimension(3) :: cgCoords real(kind=dp), public, dimension(3) :: fromCoords real(kind=dp), public :: radius real(kind=dp), public :: chord real(kind=dp), public :: root_cut real(kind=dp), public :: preconeAngle real(kind=dp), public :: dpitch real(kind=dp), public :: flapInitial real(kind=dp), public :: dflapInitial real(kind=dp), public :: Iflap real(kind=dp), public :: cflap real(kind=dp), public :: kflap real(kind=dp), public :: MflapConstant real(kind=dp), public, dimension(3) :: forceInertial real(kind=dp), public, dimension(3) :: lift real(kind=dp), public, dimension(3) :: liftPrev real(kind=dp), public, dimension(3) :: drag real(kind=dp), public, dimension(3) :: dragInduced real(kind=dp), public, dimension(3) :: dragProfile real(kind=dp), public, dimension(3) :: liftUnsteady real(kind=dp), public, dimension(3) :: dragUnsteady real(kind=dp), public, dimension(3) :: liftUnitVec real(kind=dp), public, dimension(3) :: dragUnitVec real(kind=dp), public, dimension(3) :: sideUnitVec real(kind=dp), public, dimension(3) :: controlPitch real(kind=dp), public :: thetaTwist real(kind=dp), public :: pivotLE real(kind=dp), public :: flapHinge real(kind=dp), public, dimension(3) :: velBody real(kind=dp), public, dimension(3) :: omegaBody real(kind=dp), public, dimension(3) :: velBodyPrev real(kind=dp), public, dimension(3) :: omegaBodyPrev real(kind=dp), public, allocatable, dimension(:, :) :: velBodyHistory real(kind=dp), public, allocatable, dimension(:, :) :: omegaBodyHistory real(kind=dp), public :: psi real(kind=dp), public, dimension(3) :: pts character(len=1), public :: streamwiseCoreSwitch real(kind=dp), public :: spanwiseCore real(kind=dp), public, allocatable, dimension(:) :: streamwiseCoreVec real(kind=dp), public, allocatable, dimension(:, :) :: AIC real(kind=dp), public, allocatable, dimension(:, :) :: AIC_inv real(kind=dp), public, allocatable, dimension(:) :: gamVec real(kind=dp), public, allocatable, dimension(:) :: gamVecPrev real(kind=dp), public, allocatable, dimension(:) :: RHS real(kind=dp), public, allocatable, dimension(:) :: camberSectionLimit real(kind=dp), public, allocatable, dimension(:) :: airfoilSectionLimit real(kind=dp), public, allocatable, dimension(:) :: alpha0 real(kind=dp), public :: initWakeVel real(kind=dp), public :: psiStart real(kind=dp), public :: skewLimit real(kind=dp), public :: apparentViscCoeff real(kind=dp), public :: decayCoeff real(kind=dp), public :: rollupStartRadius real(kind=dp), public :: rollupEndRadius integer, public :: propConvention integer, public :: spanSpacing integer, public :: chordSpacing integer, public :: overrideTauSpan integer, public :: symmetricTau integer, public :: wakeTruncateNt integer, public :: prescWakeNt integer, public :: prescWakeAfterTruncNt integer, public :: prescWakeGenNt integer, public :: rollupStart integer, public :: rollupEnd integer, public :: suppressFwakeSwitch integer, public :: forceCalcSwitch integer, public :: skewPlotSwitch integer, public :: inflowPlotSwitch integer, public :: bladeDynamicsSwitch integer, public :: pitchDynamicsSwitch integer, public :: bodyDynamicsSwitch integer, public :: bodyDynamicsIOVars integer, public :: spanwiseLiftSwitch integer, public :: customTrajectorySwitch integer, public :: gammaPlotSwitch integer, public :: rowNear integer, public :: rowFar integer, public :: nCamberFiles integer, public :: nAirfoils integer, public :: imagePlane integer, public :: imageRotorNum integer, public :: surfaceType integer, public :: axisymmetrySwitch character(len=30), public, allocatable, dimension(:) :: camberFile character(len=30), public, allocatable, dimension(:) :: airfoilFile character(len=30), public :: geometryFile real(kind=dp), public :: nonDimforceDenominator Type-Bound Procedures procedure, public,  :: readGeom => rotor_readGeom public  subroutine rotor_readGeom (this, filename, outputFilename) Read rotor geometry from geomXX.nml in namelist format Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: outputFilename procedure, public,  :: init => rotor_init public  subroutine rotor_init (this, rotorNumber, density, dt, nt, switches, sourceRotor) Initialize variables of rotor geometry and wake Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this integer, intent(in) :: rotorNumber real(kind=dp), intent(in) :: density real(kind=dp), intent(inout) :: dt integer, intent(inout) :: nt type( switches_class ), intent(inout) :: switches type( rotor_class ), optional :: sourceRotor procedure, public,  :: deinit => rotor_deinit public  subroutine rotor_deinit (this, switches) Deinitialise rotor variables Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this type( switches_class ), intent(in) :: switches procedure, public,  :: plot3dtoblade => rotor_plot3dtoblade public  subroutine rotor_plot3dtoblade (this, PLOT3Dfilename) Read blade geometry from PLOT3D formatted file Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: PLOT3Dfilename procedure, public,  :: stltoblade => rotor_stltoblade public  subroutine rotor_stltoblade (this, stlfilename) Read ASCII stl file for non-lifting surface geometry Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: stlfilename procedure, public,  :: getCamber => rotor_getCamber public  function rotor_getCamber (this, x, y) Get z coordinate on wing from x, y values Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y Return Value real(kind=dp), dimension(size(x), size(y)) procedure, public,  :: gettheta => rotor_gettheta public  function rotor_gettheta (this, psi, ib) Get pitch angle corresponding to blade azimuthal location Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in) :: psi integer, intent(in) :: ib Return Value real(kind=dp) procedure, public,  :: getthetadot => rotor_getthetadot public  function rotor_getthetadot (this, psi, ib) Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in) :: psi integer, intent(in) :: ib Return Value real(kind=dp) procedure, public,  :: move => rotor_move public  subroutine rotor_move (this, dshift) Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift procedure, public,  :: rot_pts => rotor_rot_pts public  subroutine rotor_rot_pts (this, pts, origin, order) Rotate using pts => phi theta psi\nWarning: This rotation is about the global reference frame Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: pts real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: order procedure, public,  :: rot_advance => rotor_rot_advance public  subroutine rotor_rot_advance (this, dpsi, nopitch) Rotate rotor by dpsi angle about axis Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dpsi logical, optional :: nopitch procedure, public,  :: rot_flap => rotor_rot_flap public  subroutine rotor_rot_flap (this) Rotate blades by flap angle Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: assignshed => rotor_assignshed public  subroutine rotor_assignshed (this, edge) Assign coordinates to first rowNear of wake from last row of blade Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this character(len=2), intent(in) :: edge procedure, public,  :: map_gam => rotor_map_gam public  subroutine rotor_map_gam (this) Map gam from vector to matrix format Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: age_wake => rotor_age_wake public  subroutine rotor_age_wake (this, dt) Update age of wake filaments Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt procedure, public,  :: dissipate_wake => rotor_dissipate_wake public  subroutine rotor_dissipate_wake (this, dt, kinematicViscosity) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: kinematicViscosity procedure, public,  :: strain_wake => rotor_strain_wake public  subroutine rotor_strain_wake (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: calcAIC => rotor_calcAIC public  subroutine rotor_calcAIC (this) Compute AIC matrix for rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: vind_bywing => rotor_vind_bywing public  function rotor_vind_bywing (this, P) Compute induced velocity by all wing vortices at P Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vind_bywing_boundVortices => rotor_vind_bywing_boundVortices public  function rotor_vind_bywing_boundVortices (this, P) Compute induced velocity by bound vortices at P Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) procedure, public,  :: vind_bywake => rotor_vind_bywake public  function rotor_vind_bywake (this, P, optionalChar) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P character(len=1), optional :: optionalChar Return Value real(kind=dp), dimension(3) procedure, public,  :: shiftwake => rotor_shiftwake public  subroutine rotor_shiftwake (this) Shift wake locations on rollup Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: shiftFwake => rotor_shiftFwake public  subroutine rotor_shiftFwake (this) Shift wake locations of Fwake for truncation Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: rollup => rotor_rollup public  subroutine rotor_rollup (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: calc_force => rotor_calc_force public  subroutine rotor_calc_force (this, density, dt) Compute force from circulation Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: dt procedure, public,  :: calc_force_alpha => rotor_calc_force_alpha public  subroutine rotor_calc_force_alpha (this, density, velSound) Compute force from sec alpha Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound procedure, public,  :: calc_force_alphaGamma => rotor_calc_force_alphaGamma public  subroutine rotor_calc_force_alphaGamma (this, density, velSound, dt) Compute force from sec alpha Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound real(kind=dp), intent(in) :: dt procedure, public,  :: calc_secAlpha => rotor_calc_secAlpha public  subroutine rotor_calc_secAlpha (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: convectwake => rotor_convectwake public  subroutine rotor_convectwake (this, iter, dt, wakeType) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: iter real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType procedure, public,  :: burst_wake => rotor_burst_wake public  subroutine rotor_burst_wake (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: calc_skew => rotor_calc_skew public  subroutine rotor_calc_skew (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: dirLiftDrag => rotor_dirLiftDrag public  subroutine rotor_dirLiftDrag (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: sumBladeToNetForces => rotor_sumBladeToNetForces public  subroutine rotor_sumBladeToNetForces (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this procedure, public,  :: mirrorGamma => rotor_mirrorGamma public  subroutine rotor_mirrorGamma (this, fromRotor) Mirrors gamma from another rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor procedure, public,  :: mirrorVelCP => rotor_mirrorVelCP public  subroutine rotor_mirrorVelCP (this, fromRotor) Mirrors velCP, velCPm from another rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor procedure, public,  :: mirrorWake => rotor_mirrorWake public  subroutine rotor_mirrorWake (this, fromRotor, wakeType) Mirrors wake positions from another rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor character(len=1), intent(in) :: wakeType procedure, public,  :: toChordsRevs => rotor_toChordsRevs public  subroutine rotor_toChordsRevs (this, nsteps, dt) Converts -ve nsteps to nsteps for corresponding no. of chords or revs Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(inout) :: nsteps real(kind=dp), intent(in) :: dt procedure, public,  :: eraseNwake => rotor_eraseNwake public  subroutine rotor_eraseNwake (this, rowErase) Erase a near wake row by setting gamma to zero Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: rowErase procedure, public,  :: eraseFwake => rotor_eraseFwake public  subroutine rotor_eraseFwake (this, rowErase) Erase a far wake row by setting gamma to zero Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: rowErase procedure, public,  :: updatePrescribedWake => rotor_updatePrescribedWake public  subroutine rotor_updatePrescribedWake (this, dt, wakeType) Attaches prescribed far wake Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType procedure, public,  :: computeBladeDynamics => rotor_computeBladeDynamics public  subroutine rotor_computeBladeDynamics (this, dt) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt procedure, public,  :: getdw public  function getdw (this, w, thrust) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: w real(kind=dp), intent(in) :: thrust Return Value real(kind=dp) procedure, public,  :: computeBodyDynamics => rotor_computeBodyDynamics public  subroutine rotor_computeBodyDynamics (this, dt) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt procedure, public,  :: rotor_write public  subroutine rotor_write (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg generic, public,  :: write(unformatted) => rotor_write public  subroutine rotor_write (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public,  :: rotor_read public  subroutine rotor_read (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg generic, public,  :: read(unformatted) => rotor_read public  subroutine rotor_read (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"type/rotor_class.html"},{"title":"isFloatEqual – VOLCANOR","text":"public  function isFloatEqual(a, b, tol) Checks if a == b within a tolerance Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a Real number a real(kind=dp), intent(in) :: b Real number b real(kind=dp), optional :: tol Tolerance is epsilon if not specified Return Value logical Contents","tags":"","loc":"proc/isfloatequal.html"},{"title":"inv2 – VOLCANOR","text":"public  function inv2(A) result(Ainv) Inverse of a matrix calculated by finding the LU\ndecomposition using LAPACK Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Square matrix A Return Value real(kind=dp), dimension(size(A,1),size(A,2)) Inverse of matrix A Contents","tags":"","loc":"proc/inv2.html"},{"title":"matmul2 – VOLCANOR","text":"public  function matmul2(A, B) result(AB) Matrix multiplication implemented using BLAS Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Matrix A real(kind=dp), intent(in), dimension(:, :) :: B Matrix B Return Value real(kind=dp), dimension(size(A, 1), size(B, 2)) Product of matrices A and B Contents","tags":"","loc":"proc/matmul2.html"},{"title":"matmulAX – VOLCANOR","text":"public  function matmulAX(A, X) result(AX) Matrix multiplication with vector implemented using BLAS Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Matrix A real(kind=dp), intent(in), dimension(:) :: X Vector X Return Value real(kind=dp), dimension(size(A, 1)) Product of matrix A and vector X Contents","tags":"","loc":"proc/matmulax.html"},{"title":"length3d – VOLCANOR","text":"public  function length3d(P1, P2) result(length) Compute length of linesegment between points P1 and P2 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: P1 Coordinates of point P1 real(kind=dp), intent(in), dimension(3) :: P2 Coordinates of point P2 Return Value real(kind=dp) Length of linesegment Contents","tags":"","loc":"proc/length3d.html"},{"title":"linspace – VOLCANOR","text":"public  function linspace(xstart, xend, nx) result(xout) Return linearly-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart Start value of sequence real(kind=dp), intent(in) :: xend End value of sequence integer, intent(in) :: nx Number of points sequence Return Value real(kind=dp), dimension(nx) Array of real numbers Contents","tags":"","loc":"proc/linspace.html"},{"title":"cosspace – VOLCANOR","text":"public  function cosspace(xstart, xend, nx) result(xout) Return cossine-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart real(kind=dp), intent(in) :: xend integer, intent(in) :: nx Return Value real(kind=dp), dimension(nx) Contents","tags":"","loc":"proc/cosspace.html"},{"title":"halfsinspace – VOLCANOR","text":"public  function halfsinspace(xstart, xend, nx) result(xout) Return half sine-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart real(kind=dp), intent(in) :: xend integer, intent(in) :: nx Return Value real(kind=dp), dimension(nx) Contents","tags":"","loc":"proc/halfsinspace.html"},{"title":"tanspace – VOLCANOR","text":"public  function tanspace(xstart, xend, nx) result(xout) Return tan-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart real(kind=dp), intent(in) :: xend integer, intent(in) :: nx Return Value real(kind=dp), dimension(nx) Contents","tags":"","loc":"proc/tanspace.html"},{"title":"cross_product – VOLCANOR","text":"public  function cross_product(aVec, bVec) Compute cross product between two 3d vectors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/cross_product.html"},{"title":"outer_product – VOLCANOR","text":"public  function outer_product(aVec, bVec) Compute outer product between two 3d vectors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp), dimension(3, 3) Contents","tags":"","loc":"proc/outer_product.html"},{"title":"getAngleTan – VOLCANOR","text":"public  function getAngleTan(aVec, bVec) Angle between two 3d vectors using tan formula\nResult will be from -pi to pi Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp) Contents","tags":"","loc":"proc/getangletan.html"},{"title":"getAngleCos – VOLCANOR","text":"public  function getAngleCos(aVec, bVec) Angle between two 3d vectors using cos formula\nAssumes no angle > 180 deg exists Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp) Contents","tags":"","loc":"proc/getanglecos.html"},{"title":"unitVec – VOLCANOR","text":"public  function unitVec(aVec) Normalizes a non-zero 3d vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/unitvec.html"},{"title":"projVec – VOLCANOR","text":"public  function projVec(aVec, dirVec) Returns 3d vector aVec projected along dirVec Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: dirVec Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/projvec.html"},{"title":"noProjVec – VOLCANOR","text":"public  function noProjVec(aVec, dirVec) Removes component along dirVec from a vector aVec Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: dirVec Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/noprojvec.html"},{"title":"inv – VOLCANOR","text":"public  function inv(A) result(Ainv) Native implementation of matrix inverse based on Doolittle method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1), size(A, 1)) Contents","tags":"","loc":"proc/inv.html"},{"title":"isInverse – VOLCANOR","text":"public  function isInverse(A, Ainv) Check if Ainv is inverse of matrix A by multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:, :) :: Ainv Return Value logical Contents","tags":"","loc":"proc/isinverse.html"},{"title":"pwl_interp1d – VOLCANOR","text":"public  function pwl_interp1d(x, y, q) Piecewise linear 1d interpolation Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: q Return Value real(kind=dp) Contents","tags":"","loc":"proc/pwl_interp1d.html"},{"title":"interp1d – VOLCANOR","text":"public  function interp1d(xq, x, y, order) 1-d Interpolation using 1st and 2nd order Lagrange polynomials Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xq real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y integer, intent(in) :: order Return Value real(kind=dp) Contents","tags":"","loc":"proc/interp1d.html"},{"title":"lsq2_scalar – VOLCANOR","text":"public  function lsq2_scalar(xQuery, xData, yData) Linear Least Squares fitting (2nd order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp) Contents","tags":"","loc":"proc/lsq2_scalar.html"},{"title":"lsq2_array – VOLCANOR","text":"public  function lsq2_array(xQuery, xData, yData) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp), dimension(size(xQuery)) Contents","tags":"","loc":"proc/lsq2_array.html"},{"title":"Tbg – VOLCANOR","text":"public  function Tbg(cs_phi, cs_theta, cs_psi) Transformation matrix (body to global frame) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(2) :: cs_phi cos(phi), sin(phi) real(kind=dp), intent(in), dimension(2) :: cs_theta cos(theta), sin(theta) real(kind=dp), intent(in), dimension(2) :: cs_psi cos(psi), sin(psi) Return Value real(kind=dp), dimension(3, 3) 3x3 transformation matrix Contents","tags":"","loc":"proc/tbg.html"},{"title":"Tgb – VOLCANOR","text":"public  function Tgb(cs_phi, cs_theta, cs_psi) Transformation matrix (global to body frame) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(2) :: cs_phi cos(phi), sin(phi) real(kind=dp), intent(in), dimension(2) :: cs_theta cos(theta), sin(theta) real(kind=dp), intent(in), dimension(2) :: cs_psi cos(psi), sin(psi) Return Value real(kind=dp), dimension(3, 3) 3x3 transformation matrix Contents","tags":"","loc":"proc/tgb.html"},{"title":"getTransformAxis – VOLCANOR","text":"public  function getTransformAxis(theta, axisVec) result(TMat) Transformation matrix for theta angular rotation about a 3d axis Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: theta theta angle in radians real(kind=dp), intent(in), dimension(3) :: axisVec 3d axis vector Return Value real(kind=dp), dimension(3, 3) 3x3 transformation matrix Contents","tags":"","loc":"proc/gettransformaxis.html"},{"title":"trapz – VOLCANOR","text":"public  function trapz(y, x) Trapezoid integration with unequal intervals Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) Contents","tags":"","loc":"proc/trapz.html"},{"title":"print_mat – VOLCANOR","text":"public  subroutine print_mat(M) Display in matrix format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: M Contents","tags":"","loc":"proc/print_mat.html"},{"title":"lsq2 – VOLCANOR","text":"public interface lsq2 Contents Module Procedures lsq2_scalar lsq2_array Module Procedures public  function lsq2_scalar (xQuery, xData, yData) Linear Least Squares fitting (2nd order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp) public  function lsq2_array (xQuery, xData, yData) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp), dimension(size(xQuery))","tags":"","loc":"interface/lsq2.html"},{"title":"getCL – VOLCANOR","text":"public  function getCL(this, alphaQuery, machQuery) Returns value of 2-d linear interpolated CL\nfor a given alphaQuery and machQuery values Type Bound C81_class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) Contents","tags":"","loc":"proc/getcl.html"},{"title":"getCD – VOLCANOR","text":"public  function getCD(this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CD\nfor given alphaQuery and machQuery values Type Bound C81_class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) Contents","tags":"","loc":"proc/getcd.html"},{"title":"getCM – VOLCANOR","text":"public  function getCM(this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CM\nfor given alphaQuery and machQuery values Type Bound C81_class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) Contents","tags":"","loc":"proc/getcm.html"},{"title":"writefile – VOLCANOR","text":"public  subroutine writefile(this, C81filename) Writes C81 class data to C81 file Type Bound C81_class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename Contents","tags":"","loc":"proc/writefile.html"},{"title":"readfile – VOLCANOR","text":"public  subroutine readfile(this, C81filename) Reads from C81 file to C81 class Type Bound C81_class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename Contents","tags":"","loc":"proc/readfile.html"},{"title":"vf_vind – VOLCANOR","text":"public  function vf_vind(this, P) result(vind) Uses libMath Compute induced velocity by unit strength vortex filament Type Bound vf_class Arguments Type Intent Optional Attributes Name class( vf_class ) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/vf_vind.html"},{"title":"vr_vind – VOLCANOR","text":"public  function vr_vind(this, P) result(vind) Compute induced velocity by unit strength 4-element vortex ring Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/vr_vind.html"},{"title":"vr_vindSource – VOLCANOR","text":"public  function vr_vindSource(this, P, nCap) result(vind) Compute induced velocity by unit strength 3-element source ring Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in), dimension(3) :: P real(kind=dp), intent(in), dimension(3) :: nCap Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/vr_vindsource.html"},{"title":"vr_getInteriorAngles – VOLCANOR","text":"public  function vr_getInteriorAngles(this) Uses libMath Obtain interior angles of vortex ring Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Return Value real(kind=dp), dimension(4) Contents","tags":"","loc":"proc/vr_getinteriorangles.html"},{"title":"vr_getMedianAngle – VOLCANOR","text":"public  function vr_getMedianAngle(this) Uses libMath Obtain median angle of vortex ring Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Return Value real(kind=dp) Contents","tags":"","loc":"proc/vr_getmedianangle.html"},{"title":"vr_getBimedianCos – VOLCANOR","text":"public  function vr_getBimedianCos(this) Obtain angle between bimedians Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Return Value real(kind=dp) Contents","tags":"","loc":"proc/vr_getbimediancos.html"},{"title":"wingpanel_isCPinsidecore – VOLCANOR","text":"public  function wingpanel_isCPinsidecore(this) Check whether collocation point lies\ninside viscous core region of vortex ring Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ), intent(in) :: this Return Value logical Contents","tags":"","loc":"proc/wingpanel_iscpinsidecore.html"},{"title":"blade_vind_bywing – VOLCANOR","text":"public  function blade_vind_bywing(this, P) Compute induced velocity by blade bound vorticity Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/blade_vind_bywing.html"},{"title":"blade_vindSource_bywing – VOLCANOR","text":"public  function blade_vindSource_bywing(this, P) Compute induced velocity by blade bound vorticity Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/blade_vindsource_bywing.html"},{"title":"blade_vind_bywing_boundVortices – VOLCANOR","text":"public  function blade_vind_bywing_boundVortices(this, P) Compute induced velocity by bound vortices alone Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/blade_vind_bywing_boundvortices.html"},{"title":"blade_vind_bywing_chordwiseVortices – VOLCANOR","text":"public  function blade_vind_bywing_chordwiseVortices(this, P) Compute induced velocity by bound vortices alone Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/blade_vind_bywing_chordwisevortices.html"},{"title":"blade_vind_boundVortex – VOLCANOR","text":"public  function blade_vind_boundVortex(this, ic, is, P) Compute induced velocity by bound vortices alone Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: ic integer, intent(in) :: is real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/blade_vind_boundvortex.html"},{"title":"blade_vind_bywake – VOLCANOR","text":"public  function blade_vind_bywake(this, rowNear, rowFar, P, optionalChar) Compute induced velocity by wake vortex rings Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar real(kind=dp), intent(in), dimension(3) :: P character(len=1), optional :: optionalChar Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/blade_vind_bywake.html"},{"title":"blade_getSecDynamicPressure – VOLCANOR","text":"public  function blade_getSecDynamicPressure(this, density) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in) :: density Return Value real(kind=dp), dimension(this%ns) Contents","tags":"","loc":"proc/blade_getsecdynamicpressure.html"},{"title":"getddflap – VOLCANOR","text":"public  function getddflap(this, flap, dflap, omega, MflapLift) Returns ddflap from blade flap equation Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in) :: flap real(kind=dp), intent(in) :: dflap real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: MflapLift Return Value real(kind=dp) Contents","tags":"","loc":"proc/getddflap.html"},{"title":"rotor_getCamber – VOLCANOR","text":"public  function rotor_getCamber(this, x, y) Uses libMath Get z coordinate on wing from x, y values Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y Return Value real(kind=dp), dimension(size(x), size(y)) Contents","tags":"","loc":"proc/rotor_getcamber.html"},{"title":"rotor_gettheta – VOLCANOR","text":"public  function rotor_gettheta(this, psi, ib) Get pitch angle corresponding to blade azimuthal location Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in) :: psi integer, intent(in) :: ib Return Value real(kind=dp) Contents","tags":"","loc":"proc/rotor_gettheta.html"},{"title":"rotor_getthetadot – VOLCANOR","text":"public  function rotor_getthetadot(this, psi, ib) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in) :: psi integer, intent(in) :: ib Return Value real(kind=dp) Contents","tags":"","loc":"proc/rotor_getthetadot.html"},{"title":"rotor_vind_bywing – VOLCANOR","text":"public  function rotor_vind_bywing(this, P) Compute induced velocity by all wing vortices at P Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/rotor_vind_bywing.html"},{"title":"rotor_vind_bywing_boundVortices – VOLCANOR","text":"public  function rotor_vind_bywing_boundVortices(this, P) Compute induced velocity by bound vortices at P Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/rotor_vind_bywing_boundvortices.html"},{"title":"rotor_vind_bywake – VOLCANOR","text":"public  function rotor_vind_bywake(this, P, optionalChar) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P character(len=1), optional :: optionalChar Return Value real(kind=dp), dimension(3) Contents","tags":"","loc":"proc/rotor_vind_bywake.html"},{"title":"getdw – VOLCANOR","text":"public  function getdw(this, w, thrust) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: w real(kind=dp), intent(in) :: thrust Return Value real(kind=dp) Contents","tags":"","loc":"proc/getdw.html"},{"title":"vf_calclength – VOLCANOR","text":"public  subroutine vf_calclength(this, isOriginal) Compute length of vortex filament Type Bound vf_class Arguments Type Intent Optional Attributes Name class( vf_class ) :: this logical, intent(in) :: isOriginal Contents","tags":"","loc":"proc/vf_calclength.html"},{"title":"vf_strain – VOLCANOR","text":"public  subroutine vf_strain(this) Type Bound vf_class Arguments Type Intent Optional Attributes Name class( vf_class ) :: this Contents","tags":"","loc":"proc/vf_strain.html"},{"title":"vr_assignP – VOLCANOR","text":"public  subroutine vr_assignP(this, n, P) Assign coordinates to nth corner Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: n real(kind=dp), dimension(3) :: P Contents","tags":"","loc":"proc/vr_assignp.html"},{"title":"vr_shiftdP – VOLCANOR","text":"public  subroutine vr_shiftdP(this, n, dshift) Shift coordinates of nth corner by dshift distance \n(usually for U*dt convection) Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: dshift Contents","tags":"","loc":"proc/vr_shiftdp.html"},{"title":"vr_rot – VOLCANOR","text":"public  subroutine vr_rot(this, Tmat, originVec) Rotate vortex ring using Tmat about origin Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in), dimension(3, 3) :: Tmat real(kind=dp), optional, dimension(3) :: originVec Contents","tags":"","loc":"proc/vr_rot.html"},{"title":"vr_calclength – VOLCANOR","text":"public  subroutine vr_calclength(this, isOriginal) Calculate length of filaments in vortex ring Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this logical, intent(in) :: isOriginal Contents","tags":"","loc":"proc/vr_calclength.html"},{"title":"vr_strain – VOLCANOR","text":"public  subroutine vr_strain(this) Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Contents","tags":"","loc":"proc/vr_strain.html"},{"title":"vr_decay – VOLCANOR","text":"public  subroutine vr_decay(this, dt, decayCoeff) Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: decayCoeff Contents","tags":"","loc":"proc/vr_decay.html"},{"title":"vr_mirror – VOLCANOR","text":"public  subroutine vr_mirror(this, coordNum) Mirror gamma and coordinates about a specified plane Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: coordNum Contents","tags":"","loc":"proc/vr_mirror.html"},{"title":"calc_skew – VOLCANOR","text":"public  subroutine calc_skew(this) Compute skew Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Contents","tags":"","loc":"proc/calc_skew.html"},{"title":"vr_burst – VOLCANOR","text":"public  subroutine vr_burst(this, skewLimit) Burst vortex filaments if skewLimit is exceeded Type Bound vr_class Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in) :: skewLimit Contents","tags":"","loc":"proc/vr_burst.html"},{"title":"wingpanel_assignP – VOLCANOR","text":"public  subroutine wingpanel_assignP(this, n, P) Assign coordinates to nth corner Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this integer, intent(in) :: n real(kind=dp), dimension(3) :: P Contents","tags":"","loc":"proc/wingpanel_assignp.html"},{"title":"wingpanel_calcCP – VOLCANOR","text":"public  subroutine wingpanel_calcCP(this, isTriangle) Compute collocation point location Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle Contents","tags":"","loc":"proc/wingpanel_calccp.html"},{"title":"wingpanel_calcN – VOLCANOR","text":"public  subroutine wingpanel_calcN(this, isTriangle) Uses libMath Compute normal vector Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle Contents","tags":"","loc":"proc/wingpanel_calcn.html"},{"title":"wingpanel_invertNcap – VOLCANOR","text":"public  subroutine wingpanel_invertNcap(this) Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this Contents","tags":"","loc":"proc/wingpanel_invertncap.html"},{"title":"wingpanel_calcTau – VOLCANOR","text":"public  subroutine wingpanel_calcTau(this, isTriangle) Uses libMath Compute chordwise and spanwise tangential vectors Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle Contents","tags":"","loc":"proc/wingpanel_calctau.html"},{"title":"wingpanel_rot – VOLCANOR","text":"public  subroutine wingpanel_rot(this, Tmat, originVec) Rotate panel using transformation matrix Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this real(kind=dp), dimension(3, 3) :: Tmat real(kind=dp), optional, dimension(3) :: originVec Contents","tags":"","loc":"proc/wingpanel_rot.html"},{"title":"wingpanel_shiftdP – VOLCANOR","text":"public  subroutine wingpanel_shiftdP(this, dshift) Shift corners of vortex ring by dshift Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift Contents","tags":"","loc":"proc/wingpanel_shiftdp.html"},{"title":"wingpanel_calc_area – VOLCANOR","text":"public  subroutine wingpanel_calc_area(this) Uses libMath Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this Contents","tags":"","loc":"proc/wingpanel_calc_area.html"},{"title":"wingpanel_calc_mean_dimensions – VOLCANOR","text":"public  subroutine wingpanel_calc_mean_dimensions(this) Calculate mean chord and mean span Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this Contents","tags":"","loc":"proc/wingpanel_calc_mean_dimensions.html"},{"title":"wingpanel_calc_chordwiseResVel – VOLCANOR","text":"public  subroutine wingpanel_calc_chordwiseResVel(this) Uses libMath Compute panel resultant velocities using local velocities Type Bound wingpanel_class Arguments Type Intent Optional Attributes Name class( wingpanel_class ), intent(inout) :: this Contents","tags":"","loc":"proc/wingpanel_calc_chordwiseresvel.html"},{"title":"Fwake_shiftdP – VOLCANOR","text":"public  subroutine Fwake_shiftdP(this, n, dshift) Shift coordinates of nth corner by dshift distance\n(usually for Udt convection) Type Bound Fwake_class Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: dshift Contents","tags":"","loc":"proc/fwake_shiftdp.html"},{"title":"Fwake_assignP – VOLCANOR","text":"public  subroutine Fwake_assignP(this, n, P) Assign point to nth endpoint of filament Type Bound Fwake_class Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: P Contents","tags":"","loc":"proc/fwake_assignp.html"},{"title":"Fwake_rot – VOLCANOR","text":"public  subroutine Fwake_rot(this, TMat, originVec) Rotate using TMat about originVec Type Bound Fwake_class Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this real(kind=dp), intent(in), dimension(3, 3) :: TMat real(kind=dp), optional, dimension(3) :: originVec Contents","tags":"","loc":"proc/fwake_rot.html"},{"title":"Fwake_decay – VOLCANOR","text":"public  subroutine Fwake_decay(this, dt, decayCoeff) Type Bound Fwake_class Arguments Type Intent Optional Attributes Name class( Fwake_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: decayCoeff Contents","tags":"","loc":"proc/fwake_decay.html"},{"title":"Fwake_mirror – VOLCANOR","text":"public  subroutine Fwake_mirror(this, coordNum) Mirror gamma and coordinates about a specified plane Type Bound Fwake_class Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: coordNum Contents","tags":"","loc":"proc/fwake_mirror.html"},{"title":"pFwake_update – VOLCANOR","text":"public  subroutine pFwake_update(this, waF, hubCoords, shaftAxis, deltaPsi) Uses libMath Type Bound pFwake_class Arguments Type Intent Optional Attributes Name class( pFwake_class ), intent(inout) :: this type( Fwake_class ), intent(in), dimension(:) :: waF real(kind=dp), intent(in), dimension(3) :: hubCoords real(kind=dp), intent(in), dimension(3) :: shaftAxis real(kind=dp), intent(in) :: deltaPsi Contents","tags":"","loc":"proc/pfwake_update.html"},{"title":"pFwake_rot_wake_axis – VOLCANOR","text":"public  subroutine pFwake_rot_wake_axis(this, theta, axisVec, origin) Uses libMath Type Bound pFwake_class Arguments Type Intent Optional Attributes Name class( pFwake_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta real(kind=dp), intent(in), dimension(3) :: axisVec real(kind=dp), intent(in), dimension(3) :: origin Contents","tags":"","loc":"proc/pfwake_rot_wake_axis.html"},{"title":"blade_move – VOLCANOR","text":"public  subroutine blade_move(this, dshift) Move blade by dshift Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift Contents","tags":"","loc":"proc/blade_move.html"},{"title":"blade_rot_pts – VOLCANOR","text":"public  subroutine blade_rot_pts(this, pts, origin, order) Uses libMath Rotate blade using pts. pts refers to (phi, theta, psi) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: pts real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: order Contents","tags":"","loc":"proc/blade_rot_pts.html"},{"title":"blade_rot_pitch – VOLCANOR","text":"public  subroutine blade_rot_pitch(this, theta) Rotate blade by pitch angle about pivotLE Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta Contents","tags":"","loc":"proc/blade_rot_pitch.html"},{"title":"blade_rot_flap – VOLCANOR","text":"public  subroutine blade_rot_flap(this, beta) Rotate blade by flap angle Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: beta Contents","tags":"","loc":"proc/blade_rot_flap.html"},{"title":"blade_rotate – VOLCANOR","text":"public  subroutine blade_rotate(this, angleRad, axisX, axisY, axisZ, originX, originY, originZ, rotateType) Uses libMath Rotate blade geometry about axis at specified origin\nRotation angle in radians Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), value :: angleRad real(kind=dp), intent(in), value :: axisX real(kind=dp), intent(in), value :: axisY real(kind=dp), intent(in), value :: axisZ real(kind=dp), intent(in), value :: originX real(kind=dp), intent(in), value :: originY real(kind=dp), intent(in), value :: originZ character(len=*), intent(in) :: rotateType Contents","tags":"","loc":"proc/blade_rotate.html"},{"title":"blade_rot_wake_axis – VOLCANOR","text":"public  subroutine blade_rot_wake_axis(this, theta, axisVec, origin, rowNear, rowFar, wakeType) Uses libMath Rotate wake about axis at specified origin Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta real(kind=dp), intent(in), dimension(3) :: axisVec real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: rowNear integer, intent(in) :: rowFar character(len=1), intent(in) :: wakeType Contents","tags":"","loc":"proc/blade_rot_wake_axis.html"},{"title":"blade_convectwake – VOLCANOR","text":"public  subroutine blade_convectwake(this, rowNear, rowFar, dt, wakeType) Convect wake collocation points using velNwake matrix Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType Contents","tags":"","loc":"proc/blade_convectwake.html"},{"title":"blade_limitWakeVel – VOLCANOR","text":"public  subroutine blade_limitWakeVel(this, rowNear, rowFar) Limits all wake velocity to a set value to prevent blow up Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar Contents","tags":"","loc":"proc/blade_limitwakevel.html"},{"title":"blade_wake_continuity – VOLCANOR","text":"public  subroutine blade_wake_continuity(this, rowNear, rowFar, wakeType) Maintain continuity between vortex ring elements after convection\nof wake collocation points Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar character(len=1), intent(in) :: wakeType Contents","tags":"","loc":"proc/blade_wake_continuity.html"},{"title":"blade_calc_force – VOLCANOR","text":"public  subroutine blade_calc_force(this, density, Omega, dt) Uses libMath Compute force using blade circulation Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: Omega real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/blade_calc_force.html"},{"title":"calc_secArea – VOLCANOR","text":"public  subroutine calc_secArea(this) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this Contents","tags":"","loc":"proc/calc_secarea.html"},{"title":"calc_secChord – VOLCANOR","text":"public  subroutine calc_secChord(this) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this Contents","tags":"","loc":"proc/calc_secchord.html"},{"title":"blade_calc_force_alpha – VOLCANOR","text":"public  subroutine blade_calc_force_alpha(this, density, velSound) Compute force using sectional alpha Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound Contents","tags":"","loc":"proc/blade_calc_force_alpha.html"},{"title":"blade_calc_force_alphaGamma – VOLCANOR","text":"public  subroutine blade_calc_force_alphaGamma(this, density, invertGammaSign, velSound, dt) Uses libMath Compute force using alpha approximated from sec circulation Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: invertGammaSign real(kind=dp), intent(in) :: velSound real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/blade_calc_force_alphagamma.html"},{"title":"blade_secCoeffsToSecForces – VOLCANOR","text":"public  subroutine blade_secCoeffsToSecForces(this, density) Uses libMath Convert force coefficients to dimensional forces Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density Contents","tags":"","loc":"proc/blade_seccoeffstosecforces.html"},{"title":"blade_lookup_secCoeffs – VOLCANOR","text":"public  subroutine blade_lookup_secCoeffs(this, velSound) Uses libC81 Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: velSound Contents","tags":"","loc":"proc/blade_lookup_seccoeffs.html"},{"title":"blade_calc_secChordwiseResVel – VOLCANOR","text":"public  subroutine blade_calc_secChordwiseResVel(this) Uses libMath Compute sectional resultant vel by interpolating local panel vel Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this Contents","tags":"","loc":"proc/blade_calc_secchordwiseresvel.html"},{"title":"blade_calc_secAlpha – VOLCANOR","text":"public  subroutine blade_calc_secAlpha(this, verticalAxis) Uses libMath Compute sec alpha using sec resultant velocity Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: verticalAxis Contents","tags":"","loc":"proc/blade_calc_secalpha.html"},{"title":"blade_calc_secLocations – VOLCANOR","text":"public  subroutine blade_calc_secLocations(this, chordwiseFraction, flapHingeRadius) Uses libMath Compute important locations at each section\ncoordinates of collocation point located at chord fraction\nflap moment arm Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: chordwiseFraction real(kind=dp), intent(in) :: flapHingeRadius Contents","tags":"","loc":"proc/blade_calc_seclocations.html"},{"title":"blade_burst_wake – VOLCANOR","text":"public  subroutine blade_burst_wake(this, rowFar, skewLimit, largeCoreRadius) Uses libMath Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowFar real(kind=dp), intent(in) :: skewLimit real(kind=dp), intent(in) :: largeCoreRadius Contents","tags":"","loc":"proc/blade_burst_wake.html"},{"title":"blade_calc_skew – VOLCANOR","text":"public  subroutine blade_calc_skew(this, rowNear) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear Contents","tags":"","loc":"proc/blade_calc_skew.html"},{"title":"blade_dirLiftDrag – VOLCANOR","text":"public  subroutine blade_dirLiftDrag(this, Omega) Uses libMath Compute lift and drag direction vectors Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: Omega Contents","tags":"","loc":"proc/blade_dirliftdrag.html"},{"title":"blade_sumSecToNetForces – VOLCANOR","text":"public  subroutine blade_sumSecToNetForces(this) Sum up sectional forces to net forces Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this Contents","tags":"","loc":"proc/blade_sumsectonetforces.html"},{"title":"blade_calc_stlStats – VOLCANOR","text":"public  subroutine blade_calc_stlStats(this) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this Contents","tags":"","loc":"proc/blade_calc_stlstats.html"},{"title":"blade_computeBladeDynamics – VOLCANOR","text":"public  subroutine blade_computeBladeDynamics(this, dt, omega) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: omega Contents","tags":"","loc":"proc/blade_computebladedynamics.html"},{"title":"blade_write – VOLCANOR","text":"public  subroutine blade_write(this, unit, iostat, iomsg) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Contents","tags":"","loc":"proc/blade_write.html"},{"title":"blade_read – VOLCANOR","text":"public  subroutine blade_read(this, unit, iostat, iomsg) Type Bound blade_class Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Contents","tags":"","loc":"proc/blade_read.html"},{"title":"rotor_readGeom – VOLCANOR","text":"public  subroutine rotor_readGeom(this, filename, outputFilename) Read rotor geometry from geomXX.nml in namelist format Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: outputFilename Contents","tags":"","loc":"proc/rotor_readgeom.html"},{"title":"rotor_init – VOLCANOR","text":"public  subroutine rotor_init(this, rotorNumber, density, dt, nt, switches, sourceRotor) Uses libMath Initialize variables of rotor geometry and wake Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this integer, intent(in) :: rotorNumber real(kind=dp), intent(in) :: density real(kind=dp), intent(inout) :: dt integer, intent(inout) :: nt type( switches_class ), intent(inout) :: switches type( rotor_class ), optional :: sourceRotor Contents","tags":"","loc":"proc/rotor_init.html"},{"title":"rotor_deinit – VOLCANOR","text":"public  subroutine rotor_deinit(this, switches) Deinitialise rotor variables Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this type( switches_class ), intent(in) :: switches Contents","tags":"","loc":"proc/rotor_deinit.html"},{"title":"rotor_plot3dtoblade – VOLCANOR","text":"public  subroutine rotor_plot3dtoblade(this, PLOT3Dfilename) Read blade geometry from PLOT3D formatted file Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: PLOT3Dfilename Contents","tags":"","loc":"proc/rotor_plot3dtoblade.html"},{"title":"rotor_stltoblade – VOLCANOR","text":"public  subroutine rotor_stltoblade(this, stlfilename) Read ASCII stl file for non-lifting surface geometry Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: stlfilename Contents","tags":"","loc":"proc/rotor_stltoblade.html"},{"title":"rotor_calcAIC – VOLCANOR","text":"public  subroutine rotor_calcAIC(this) Uses libMath Compute AIC matrix for rotor Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_calcaic.html"},{"title":"rotor_map_gam – VOLCANOR","text":"public  subroutine rotor_map_gam(this) Map gam from vector to matrix format Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_map_gam.html"},{"title":"rotor_move – VOLCANOR","text":"public  subroutine rotor_move(this, dshift) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift Contents","tags":"","loc":"proc/rotor_move.html"},{"title":"rotor_rot_pts – VOLCANOR","text":"public  subroutine rotor_rot_pts(this, pts, origin, order) Uses libMath Rotate using pts => phi theta psi\nWarning: This rotation is about the global reference frame Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: pts real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: order Contents","tags":"","loc":"proc/rotor_rot_pts.html"},{"title":"rotor_rot_flap – VOLCANOR","text":"public  subroutine rotor_rot_flap(this) Rotate blades by flap angle Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_rot_flap.html"},{"title":"rotor_rot_advance – VOLCANOR","text":"public  subroutine rotor_rot_advance(this, dpsi, nopitch) Rotate rotor by dpsi angle about axis Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dpsi logical, optional :: nopitch Contents","tags":"","loc":"proc/rotor_rot_advance.html"},{"title":"rotor_assignshed – VOLCANOR","text":"public  subroutine rotor_assignshed(this, edge) Assign coordinates to first rowNear of wake from last row of blade Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this character(len=2), intent(in) :: edge Contents","tags":"","loc":"proc/rotor_assignshed.html"},{"title":"rotor_age_wake – VOLCANOR","text":"public  subroutine rotor_age_wake(this, dt) Update age of wake filaments Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/rotor_age_wake.html"},{"title":"rotor_dissipate_wake – VOLCANOR","text":"public  subroutine rotor_dissipate_wake(this, dt, kinematicViscosity) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: kinematicViscosity Contents","tags":"","loc":"proc/rotor_dissipate_wake.html"},{"title":"rotor_strain_wake – VOLCANOR","text":"public  subroutine rotor_strain_wake(this) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_strain_wake.html"},{"title":"rotor_shiftwake – VOLCANOR","text":"public  subroutine rotor_shiftwake(this) Shift wake locations on rollup Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_shiftwake.html"},{"title":"rotor_shiftFwake – VOLCANOR","text":"public  subroutine rotor_shiftFwake(this) Shift wake locations of Fwake for truncation Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_shiftfwake.html"},{"title":"rotor_rollup – VOLCANOR","text":"public  subroutine rotor_rollup(this) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_rollup.html"},{"title":"rotor_calc_force – VOLCANOR","text":"public  subroutine rotor_calc_force(this, density, dt) Compute force from circulation Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/rotor_calc_force.html"},{"title":"rotor_calc_force_alpha – VOLCANOR","text":"public  subroutine rotor_calc_force_alpha(this, density, velSound) Compute force from sec alpha Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound Contents","tags":"","loc":"proc/rotor_calc_force_alpha.html"},{"title":"rotor_calc_force_alphaGamma – VOLCANOR","text":"public  subroutine rotor_calc_force_alphaGamma(this, density, velSound, dt) Compute force from sec alpha Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/rotor_calc_force_alphagamma.html"},{"title":"rotor_calc_secAlpha – VOLCANOR","text":"public  subroutine rotor_calc_secAlpha(this) Uses libMath Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_calc_secalpha.html"},{"title":"rotor_convectwake – VOLCANOR","text":"public  subroutine rotor_convectwake(this, iter, dt, wakeType) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: iter real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType Contents","tags":"","loc":"proc/rotor_convectwake.html"},{"title":"rotor_computeBladeDynamics – VOLCANOR","text":"public  subroutine rotor_computeBladeDynamics(this, dt) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/rotor_computebladedynamics.html"},{"title":"rotor_computeBodyDynamics – VOLCANOR","text":"public  subroutine rotor_computeBodyDynamics(this, dt) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/rotor_computebodydynamics.html"},{"title":"rotor_burst_wake – VOLCANOR","text":"public  subroutine rotor_burst_wake(this) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_burst_wake.html"},{"title":"rotor_calc_skew – VOLCANOR","text":"public  subroutine rotor_calc_skew(this) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_calc_skew.html"},{"title":"rotor_dirLiftDrag – VOLCANOR","text":"public  subroutine rotor_dirLiftDrag(this) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_dirliftdrag.html"},{"title":"rotor_sumBladeToNetForces – VOLCANOR","text":"public  subroutine rotor_sumBladeToNetForces(this) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this Contents","tags":"","loc":"proc/rotor_sumbladetonetforces.html"},{"title":"rotor_mirrorGamma – VOLCANOR","text":"public  subroutine rotor_mirrorGamma(this, fromRotor) Mirrors gamma from another rotor Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor Contents","tags":"","loc":"proc/rotor_mirrorgamma.html"},{"title":"rotor_mirrorVelCP – VOLCANOR","text":"public  subroutine rotor_mirrorVelCP(this, fromRotor) Mirrors velCP, velCPm from another rotor Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor Contents","tags":"","loc":"proc/rotor_mirrorvelcp.html"},{"title":"rotor_mirrorWake – VOLCANOR","text":"public  subroutine rotor_mirrorWake(this, fromRotor, wakeType) Mirrors wake positions from another rotor Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor character(len=1), intent(in) :: wakeType Contents","tags":"","loc":"proc/rotor_mirrorwake.html"},{"title":"rotor_toChordsRevs – VOLCANOR","text":"public  subroutine rotor_toChordsRevs(this, nsteps, dt) Converts -ve nsteps to nsteps for corresponding no. of chords or revs Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(inout) :: nsteps real(kind=dp), intent(in) :: dt Contents","tags":"","loc":"proc/rotor_tochordsrevs.html"},{"title":"rotor_eraseNwake – VOLCANOR","text":"public  subroutine rotor_eraseNwake(this, rowErase) Erase a near wake row by setting gamma to zero Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: rowErase Contents","tags":"","loc":"proc/rotor_erasenwake.html"},{"title":"rotor_eraseFwake – VOLCANOR","text":"public  subroutine rotor_eraseFwake(this, rowErase) Erase a far wake row by setting gamma to zero Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: rowErase Contents","tags":"","loc":"proc/rotor_erasefwake.html"},{"title":"rotor_updatePrescribedWake – VOLCANOR","text":"public  subroutine rotor_updatePrescribedWake(this, dt, wakeType) Attaches prescribed far wake Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType Contents","tags":"","loc":"proc/rotor_updateprescribedwake.html"},{"title":"rotor_read – VOLCANOR","text":"public  subroutine rotor_read(this, unit, iostat, iomsg) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Contents","tags":"","loc":"proc/rotor_read.html"},{"title":"rotor_write – VOLCANOR","text":"public  subroutine rotor_write(this, unit, iostat, iomsg) Type Bound rotor_class Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Contents","tags":"","loc":"proc/rotor_write.html"},{"title":"vind_onNwake_byRotor – VOLCANOR","text":"public  function vind_onNwake_byRotor(rotor, Nwake, optionalChar) result(vindArray) Uses classdef Compute induced velocity by rotor (wing + wake) on Nwake corner points Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(inout) :: rotor Rotor type( Nwake_class ), intent(in), dimension(:, :) :: Nwake Near wake character(len=1), optional :: optionalChar If 'P' is specified, predicted wake of rotor is used Return Value real(kind=dp), dimension(3, size(Nwake, 1), size(Nwake, 2) + 1) Contents","tags":"","loc":"proc/vind_onnwake_byrotor.html"},{"title":"vind_onFwake_byRotor – VOLCANOR","text":"public  function vind_onFwake_byRotor(rotor, Fwake, optionalChar) result(vindArray) Uses classdef Compute induced velocity by rotor (wing + wake) on Fwake corner points Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(inout) :: rotor Rotor type( Fwake_class ), intent(in), dimension(:) :: Fwake Far wake character(len=1), optional :: optionalChar If 'P' is specified, predicted wake of rotor is used Return Value real(kind=dp), dimension(3, size(Fwake, 1)) Contents","tags":"","loc":"proc/vind_onfwake_byrotor.html"},{"title":"vel_order2_Nwake – VOLCANOR","text":"public  function vel_order2_Nwake(v_wake_n, v_wake_np1) Calculate 2nd order accurate induced velocity on near wake Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :, :) :: v_wake_n Induced velocity on wake at timestep n real(kind=dp), intent(in), dimension(:, :, :) :: v_wake_np1 Induced velocity on wake at timestep n+1 Return Value real(kind=dp), dimension(3, size(v_wake_n, 2), size(v_wake_n, 3)) Contents","tags":"","loc":"proc/vel_order2_nwake.html"},{"title":"vel_order2_Fwake – VOLCANOR","text":"public  function vel_order2_Fwake(v_wake_n, v_wake_np1) Calculate 2nd order accurate induced velocity on far wake Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: v_wake_n Induced velocity on wake at timestep n real(kind=dp), intent(in), dimension(:, :) :: v_wake_np1 Induced velocity on wake at timestep n+1 Return Value real(kind=dp), dimension(3, size(v_wake_n, 2)) Contents","tags":"","loc":"proc/vel_order2_fwake.html"},{"title":"readConfig – VOLCANOR","text":"public  subroutine readConfig(filename, outputFilename) Uses classdef Read config.nml input file (in namelist format) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: outputFilename Contents","tags":"","loc":"proc/readconfig.html"},{"title":"print_status – VOLCANOR","text":"public  subroutine print_status(statusMessage) Prints status message (or SUCCESS if left blank) Arguments Type Intent Optional Attributes Name character(len=*), optional :: statusMessage Contents","tags":"","loc":"proc/print_status.html"},{"title":"init_plots – VOLCANOR","text":"public  subroutine init_plots(numOfRotors) Initialise headers for plot files Arguments Type Intent Optional Attributes Name integer, intent(in) :: numOfRotors Contents","tags":"","loc":"proc/init_plots.html"},{"title":"params2file – VOLCANOR","text":"public  subroutine params2file(rotor, nt, dt, nr, density, velSound, switches) Uses classdef Write rotor parameters to json file Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(in) :: rotor integer, intent(in) :: nt real(kind=dp), intent(in) :: dt integer, intent(in) :: nr real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound type( switches_class ), intent(in) :: switches Contents","tags":"","loc":"proc/params2file.html"},{"title":"geom2file – VOLCANOR","text":"public  subroutine geom2file(timestamp, rotor, wakeSuppress) Uses classdef Plot rotor geometry and wake to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor integer, intent(in) :: wakeSuppress Contents","tags":"","loc":"proc/geom2file.html"},{"title":"probes2file – VOLCANOR","text":"public  subroutine probes2file(timestamp, probe, probeVel, rotor, t) Uses classdef Write velocities at probe locations Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp real(kind=dp), intent(in), dimension(:, :) :: probe real(kind=dp), intent(in), dimension(:, :) :: probeVel type( rotor_class ), intent(inout), dimension(:) :: rotor real(kind=dp), intent(in) :: t Contents","tags":"","loc":"proc/probes2file.html"},{"title":"filaments2file – VOLCANOR","text":"public  subroutine filaments2file(timestamp, rotor) Uses classdef Write filaments to file for using with grid-based plots Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in), dimension(:) :: rotor Contents","tags":"","loc":"proc/filaments2file.html"},{"title":"geomSurface2file – VOLCANOR","text":"public  subroutine geomSurface2file(rotor) Uses classdef Plot surface geometry to file Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(in) :: rotor Contents","tags":"","loc":"proc/geomsurface2file.html"},{"title":"tip2file – VOLCANOR","text":"public  subroutine tip2file(timestamp, rotor) Uses classdef Wake tip to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor Contents","tags":"","loc":"proc/tip2file.html"},{"title":"skew2file – VOLCANOR","text":"public  subroutine skew2file(timestamp, rotor) Uses classdef Skew parameter to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor Contents","tags":"","loc":"proc/skew2file.html"},{"title":"force2file – VOLCANOR","text":"public  subroutine force2file(timestamp, rotor) Uses classdef Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor Contents","tags":"","loc":"proc/force2file.html"},{"title":"dynamics2file – VOLCANOR","text":"public  subroutine dynamics2file(timestamp, rotor) Uses classdef Rotor dynamics to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor Contents","tags":"","loc":"proc/dynamics2file.html"},{"title":"inflow2file – VOLCANOR","text":"public  subroutine inflow2file(timestamp, rotorArray, rotorNumber, directionVector) Uses classdef Calculate inflow velocity along directionVector \non the blades of rotor(rotorNumber) at rotor(rotorNumber)%secCP Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(inout), dimension(:) :: rotorArray integer, intent(in) :: rotorNumber real(kind=dp), intent(in), dimension(3) :: directionVector Contents","tags":"","loc":"proc/inflow2file.html"},{"title":"gamma2file – VOLCANOR","text":"public  subroutine gamma2file(timestamp, rotor) Uses classdef Calculate inflow velocity along directionVector on the blades of rotor(rotorNumber)\nat rotor(rotorNumber)%secCP Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor Contents","tags":"","loc":"proc/gamma2file.html"},{"title":"libMath – VOLCANOR","text":"Procedures to manipulate matrices and vectors Contents Variables dp pi eps degToRad radToDeg xAxis yAxis zAxis Interfaces lsq2 Functions isFloatEqual inv2 matmul2 matmulAX length3d linspace cosspace halfsinspace tanspace cross_product outer_product getAngleTan getAngleCos unitVec projVec noProjVec inv isInverse pwl_interp1d interp1d lsq2_scalar lsq2_array Tbg Tgb getTransformAxis trapz Subroutines print_mat Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(1.d0) Double precision setting real(kind=dp), public, parameter :: pi = atan(1._dp)*4._dp Value of pi real(kind=dp), public, parameter :: eps = epsilon(1._dp) Value of machine epsilon real(kind=dp), public, parameter :: degToRad = pi/180._dp For converting degree to radian real(kind=dp), public, parameter :: radToDeg = 180._dp/pi For converting radian to degree real(kind=dp), public, parameter,               dimension(3) :: xAxis = [1._dp, 0._dp, 0._dp] Global x-axis real(kind=dp), public, parameter,               dimension(3) :: yAxis = [0._dp, 1._dp, 0._dp] Global y-axis real(kind=dp), public, parameter,               dimension(3) :: zAxis = [0._dp, 0._dp, 1._dp] Global z-axis Interfaces public        interface lsq2 public  function lsq2_scalar (xQuery, xData, yData) Linear Least Squares fitting (2nd order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp) public  function lsq2_array (xQuery, xData, yData) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp), dimension(size(xQuery)) Functions public  function isFloatEqual (a, b, tol) Checks if a == b within a tolerance Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a Real number a real(kind=dp), intent(in) :: b Real number b real(kind=dp), optional :: tol Tolerance is epsilon if not specified Return Value logical public  function inv2 (A) result(Ainv) Inverse of a matrix calculated by finding the LU\ndecomposition using LAPACK Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Square matrix A Return Value real(kind=dp), dimension(size(A,1),size(A,2)) Inverse of matrix A public  function matmul2 (A, B) result(AB) Matrix multiplication implemented using BLAS Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Matrix A real(kind=dp), intent(in), dimension(:, :) :: B Matrix B Return Value real(kind=dp), dimension(size(A, 1), size(B, 2)) Product of matrices A and B public  function matmulAX (A, X) result(AX) Matrix multiplication with vector implemented using BLAS Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Matrix A real(kind=dp), intent(in), dimension(:) :: X Vector X Return Value real(kind=dp), dimension(size(A, 1)) Product of matrix A and vector X public  function length3d (P1, P2) result(length) Compute length of linesegment between points P1 and P2 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: P1 Coordinates of point P1 real(kind=dp), intent(in), dimension(3) :: P2 Coordinates of point P2 Return Value real(kind=dp) Length of linesegment public  function linspace (xstart, xend, nx) result(xout) Return linearly-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart Start value of sequence real(kind=dp), intent(in) :: xend End value of sequence integer, intent(in) :: nx Number of points sequence Return Value real(kind=dp), dimension(nx) Array of real numbers public  function cosspace (xstart, xend, nx) result(xout) Return cossine-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart real(kind=dp), intent(in) :: xend integer, intent(in) :: nx Return Value real(kind=dp), dimension(nx) public  function halfsinspace (xstart, xend, nx) result(xout) Return half sine-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart real(kind=dp), intent(in) :: xend integer, intent(in) :: nx Return Value real(kind=dp), dimension(nx) public  function tanspace (xstart, xend, nx) result(xout) Return tan-spaced array over a specified interval Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xstart real(kind=dp), intent(in) :: xend integer, intent(in) :: nx Return Value real(kind=dp), dimension(nx) public  function cross_product (aVec, bVec) Compute cross product between two 3d vectors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp), dimension(3) public  function outer_product (aVec, bVec) Compute outer product between two 3d vectors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp), dimension(3, 3) public  function getAngleTan (aVec, bVec) Angle between two 3d vectors using tan formula\nResult will be from -pi to pi Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp) public  function getAngleCos (aVec, bVec) Angle between two 3d vectors using cos formula\nAssumes no angle > 180 deg exists Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: bVec Return Value real(kind=dp) public  function unitVec (aVec) Normalizes a non-zero 3d vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec Return Value real(kind=dp), dimension(3) public  function projVec (aVec, dirVec) Returns 3d vector aVec projected along dirVec Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: dirVec Return Value real(kind=dp), dimension(3) public  function noProjVec (aVec, dirVec) Removes component along dirVec from a vector aVec Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(3) :: aVec real(kind=dp), intent(in), dimension(3) :: dirVec Return Value real(kind=dp), dimension(3) public  function inv (A) result(Ainv) Native implementation of matrix inverse based on Doolittle method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp), dimension(size(A, 1), size(A, 1)) public  function isInverse (A, Ainv) Check if Ainv is inverse of matrix A by multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:, :) :: Ainv Return Value logical public  function pwl_interp1d (x, y, q) Piecewise linear 1d interpolation Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: q Return Value real(kind=dp) public  function interp1d (xq, x, y, order) 1-d Interpolation using 1st and 2nd order Lagrange polynomials Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xq real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y integer, intent(in) :: order Return Value real(kind=dp) public  function lsq2_scalar (xQuery, xData, yData) Linear Least Squares fitting (2nd order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp) public  function lsq2_array (xQuery, xData, yData) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: xQuery real(kind=dp), intent(in), dimension(:) :: xData real(kind=dp), intent(in), dimension(:) :: yData Return Value real(kind=dp), dimension(size(xQuery)) public  function Tbg (cs_phi, cs_theta, cs_psi) Transformation matrix (body to global frame) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(2) :: cs_phi cos(phi), sin(phi) real(kind=dp), intent(in), dimension(2) :: cs_theta cos(theta), sin(theta) real(kind=dp), intent(in), dimension(2) :: cs_psi cos(psi), sin(psi) Return Value real(kind=dp), dimension(3, 3) 3x3 transformation matrix public  function Tgb (cs_phi, cs_theta, cs_psi) Transformation matrix (global to body frame) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(2) :: cs_phi cos(phi), sin(phi) real(kind=dp), intent(in), dimension(2) :: cs_theta cos(theta), sin(theta) real(kind=dp), intent(in), dimension(2) :: cs_psi cos(psi), sin(psi) Return Value real(kind=dp), dimension(3, 3) 3x3 transformation matrix public  function getTransformAxis (theta, axisVec) result(TMat) Transformation matrix for theta angular rotation about a 3d axis Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: theta theta angle in radians real(kind=dp), intent(in), dimension(3) :: axisVec 3d axis vector Return Value real(kind=dp), dimension(3, 3) 3x3 transformation matrix public  function trapz (y, x) Trapezoid integration with unequal intervals Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) Subroutines public  subroutine print_mat (M) Display in matrix format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: M","tags":"","loc":"module/libmath.html"},{"title":"libC81 – VOLCANOR","text":"Procedures to manipulate C81 files and data structure Contents Derived Types C81_class Functions getCL getCD getCM Subroutines writefile readfile Derived Types type, public :: C81_class Base class for C81 performance data Components Type Visibility Attributes Name Initial character(len=30), public :: airfoilName Airfoil name in C81 file integer, public :: ML No. of lift coefficient machs integer, public :: NL No. of lift coefficient alphas integer, public :: MD No. of drag coefficient machs integer, public :: ND No. of drag coefficient alphas integer, public :: MM No. of moment coefficient machs integer, public :: NM No. of moment coefficient alphas real(kind=dp), public, allocatable, dimension(:) :: MaL Machs for lift real(kind=dp), public, allocatable, dimension(:) :: MaD Machs for drag real(kind=dp), public, allocatable, dimension(:) :: MaM Machs for moment real(kind=dp), public, allocatable, dimension(:) :: AL Alphas for lift real(kind=dp), public, allocatable, dimension(:) :: AD Alphas for drag real(kind=dp), public, allocatable, dimension(:) :: AM Alphas for moment real(kind=dp), public, allocatable, dimension(:,:) :: CL Lift coefficient real(kind=dp), public, allocatable, dimension(:,:) :: CD Drag coefficient real(kind=dp), public, allocatable, dimension(:,:) :: CM Moment coefficient Type-Bound Procedures procedure\n                    ,                  public\n,                   :: writefile Subroutine procedure\n                    ,                  public\n,                   :: readfile Subroutine procedure\n                    ,                  public\n,                   :: getCL Function procedure\n                    ,                  public\n,                   :: getCD Function procedure\n                    ,                  public\n,                   :: getCM Function Functions public  function getCL (this, alphaQuery, machQuery) Returns value of 2-d linear interpolated CL\nfor a given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) public  function getCD (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CD\nfor given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) public  function getCM (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CM\nfor given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real(kind=dp), intent(in) :: alphaQuery real(kind=dp), intent(in) :: machQuery Return Value real(kind=dp) Subroutines public  subroutine writefile (this, C81filename) Writes C81 class data to C81 file Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename public  subroutine readfile (this, C81filename) Reads from C81 file to C81 class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename","tags":"","loc":"module/libc81.html"},{"title":"classdef – VOLCANOR","text":"Class and procedures for the various objects Uses libMath libC81 Contents Variables tol Derived Types switches_class vf_class vr_class wingpanel_class Nwake_class Fwake_class pFwake_class blade_class rotor_class Functions vf_vind vr_vind vr_vindSource vr_getInteriorAngles vr_getMedianAngle vr_getBimedianCos wingpanel_isCPinsidecore blade_vind_bywing blade_vindSource_bywing blade_vind_bywing_boundVortices blade_vind_bywing_chordwiseVortices blade_vind_boundVortex blade_vind_bywake blade_getSecDynamicPressure getddflap rotor_getCamber rotor_gettheta rotor_getthetadot rotor_vind_bywing rotor_vind_bywing_boundVortices rotor_vind_bywake getdw Subroutines vf_calclength vf_strain vr_assignP vr_shiftdP vr_rot vr_calclength vr_strain vr_decay vr_mirror calc_skew vr_burst wingpanel_assignP wingpanel_calcCP wingpanel_calcN wingpanel_invertNcap wingpanel_calcTau wingpanel_rot wingpanel_shiftdP wingpanel_calc_area wingpanel_calc_mean_dimensions wingpanel_calc_chordwiseResVel Fwake_shiftdP Fwake_assignP Fwake_rot Fwake_decay Fwake_mirror pFwake_update pFwake_rot_wake_axis blade_move blade_rot_pts blade_rot_pitch blade_rot_flap blade_rotate blade_rot_wake_axis blade_convectwake blade_limitWakeVel blade_wake_continuity blade_calc_force calc_secArea calc_secChord blade_calc_force_alpha blade_calc_force_alphaGamma blade_secCoeffsToSecForces blade_lookup_secCoeffs blade_calc_secChordwiseResVel blade_calc_secAlpha blade_calc_secLocations blade_burst_wake blade_calc_skew blade_dirLiftDrag blade_sumSecToNetForces blade_calc_stlStats blade_computeBladeDynamics blade_write blade_read rotor_readGeom rotor_init rotor_deinit rotor_plot3dtoblade rotor_stltoblade rotor_calcAIC rotor_map_gam rotor_move rotor_rot_pts rotor_rot_flap rotor_rot_advance rotor_assignshed rotor_age_wake rotor_dissipate_wake rotor_strain_wake rotor_shiftwake rotor_shiftFwake rotor_rollup rotor_calc_force rotor_calc_force_alpha rotor_calc_force_alphaGamma rotor_calc_secAlpha rotor_convectwake rotor_computeBladeDynamics rotor_computeBodyDynamics rotor_burst_wake rotor_calc_skew rotor_dirLiftDrag rotor_sumBladeToNetForces rotor_mirrorGamma rotor_mirrorVelCP rotor_mirrorWake rotor_toChordsRevs rotor_eraseNwake rotor_eraseFwake rotor_updatePrescribedWake rotor_read rotor_write Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: tol = 1.E-6 Tolerance for use in unit tests Derived Types type, public :: switches_class Switches that determine solver options Components Type Visibility Attributes Name Initial integer, public :: ntSub No. of timesteps for sub-iterations [+/-n] integer, public :: ntSubInit No. of timesteps for initial sub-iterations [+/-n] integer, public :: wakeDissipation Wake dissipation [0, 1] integer, public :: wakeStrain Wake strain [0, 1] integer, public :: wakeBurst Wake burst on exceeding skew value [0, 1] integer, public :: wakeSuppress Suppress wake (for testing and non-lifting surfaces) [0, 1] integer, public :: slowStart Slow start to avoid large starting vortex [0, 1] integer, public :: slowStartNt Slow start to avoid large starting vortex [+/-n] integer, public :: wakeTipPlot Plot wake tip every nth timestep [+/-n] integer, public :: wakePlot Plot full wake every nth timestep [+/-n] integer, public :: gridPlot Record vortices for field computation every nth timestep [+/-n] integer, public :: rotorForcePlot Plot rotor forces every nth timestep [+/-n] integer, public :: fdScheme Choose finite-difference scheme [0,1,...,5] integer, public :: probe Use probes for recording velocity [0,1] integer, public :: nProbes No. of probes [n] integer, public :: initWakeVelNt Use initial velocity for convecting away starting vortex [0, 1] integer, public :: restartFromNt Restart from nth timestep [n] integer, public :: restartWriteNt Write restart files every nth timestep for restarting later [n] type, public :: vf_class Vortex filament class Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(3, 2) :: fc Filament coords (xyz, 1:2) real(kind=dp), public :: l0 = 0._dp Original length real(kind=dp), public :: lc = 0._dp Current length real(kind=dp), public :: rVc0 = 0._dp Initial vortex core radius real(kind=dp), public :: rVc = 0._dp Current vortex core radius real(kind=dp), public :: age = 0._dp Vortex age (in seconds) real(kind=dp), public :: ageAzimuthal = 0._dp vortex age (in radians) Type-Bound Procedures procedure\n                    ,                  public\n,                   :: vind => vf_vind Function procedure\n                    ,                  public\n,                   :: calclength => vf_calclength Subroutine procedure\n                    ,                  public\n,                   :: strain => vf_strain Subroutine type, public :: vr_class Vortex ring class Components Type Visibility Attributes Name Initial type( vf_class ), public, dimension(4) :: vf real(kind=dp), public :: gam Circulation real(kind=dp), public :: skew Skew parameter Type-Bound Procedures procedure\n                    ,                  public\n,                   :: vind => vr_vind Function procedure\n                    ,                  public\n,                   :: vindSource => vr_vindSource Function procedure\n                    ,                  public\n,                   :: assignP => vr_assignP Subroutine procedure\n                    ,                  public\n,                   :: shiftdP => vr_shiftdP Subroutine procedure\n                    ,                  public\n,                   :: rot => vr_rot Subroutine procedure\n                    ,                  public\n,                   :: calclength => vr_calclength Subroutine procedure\n                    ,                  public\n,                   :: strain => vr_strain Subroutine procedure\n                    ,                  public\n,                   :: decay => vr_decay Subroutine procedure\n                    ,                  public\n,                   :: calc_skew Subroutine procedure\n                    ,                  public\n,                   :: burst => vr_burst Subroutine procedure\n                    ,                  public\n,                   :: mirror => vr_mirror Subroutine type, public :: wingpanel_class Wing panel class Components Type Visibility Attributes Name Initial type( vr_class ), public :: vr real(kind=dp), public :: gamPrev Circulation at previous timestep real(kind=dp), public :: gamTrapz Circulation after trapezoidal integration real(kind=dp), public, dimension(3, 4) :: PC Panel coords (xyz, 1:4) real(kind=dp), public, dimension(3) :: CP Collocation point coords real(kind=dp), public, dimension(3) :: nCap Unit normal vector real(kind=dp), public, dimension(3) :: tauCapChord Unit tangential vector along chord real(kind=dp), public, dimension(3) :: tauCapSpan Unit tangential vector along span real(kind=dp), public, dimension(3) :: velCP Local vel at CP excluding wing vortices real(kind=dp), public, dimension(3) :: velCPTotal Local vel at CP including wing vortices real(kind=dp), public, dimension(3) :: velCPm Local vel at CP due to wing motion real(kind=dp), public, dimension(3) :: normalForce Normal force vector (inertial frame) real(kind=dp), public, dimension(3) :: normalForceUnsteady Unsteady part of normal force vector (inertial frame) real(kind=dp), public, dimension(3) :: chordwiseResVel Chordwise resultant velocity vector real(kind=dp), public :: velPitch Airfoil pitch velocity about rHinge real(kind=dp), public :: delP Pressure difference between upper and lower surfaces at panel real(kind=dp), public :: delPUnsteady Unsteady pressure at panel real(kind=dp), public :: delDiConstant Induced drag (constant part) at panel real(kind=dp), public :: delDiUnsteady Induced drag (unsteady part) at panel real(kind=dp), public :: meanChord Panel mean chord real(kind=dp), public :: meanSpan Panel mean span real(kind=dp), public :: panelArea Panel area for computing lift real(kind=dp), public :: rHinge Dist to point about which airfoil pitching occurs (LE of wing) real(kind=dp), public :: alpha Local angle of attack (in radians) Type-Bound Procedures procedure\n                    ,                  public\n,                   :: assignP => wingpanel_assignP Subroutine procedure\n                    ,                  public\n,                   :: calcCP => wingpanel_calcCP Subroutine procedure\n                    ,                  public\n,                   :: calcN => wingpanel_calcN Subroutine procedure\n                    ,                  public\n,                   :: invertNcap => wingpanel_invertNcap Subroutine procedure\n                    ,                  public\n,                   :: calcTau => wingpanel_calcTau Subroutine procedure\n                    ,                  public\n,                   :: rot => wingpanel_rot Subroutine procedure\n                    ,                  public\n,                   :: shiftdP => wingpanel_shiftdP Subroutine procedure\n                    ,                  public\n,                   :: calc_chordwiseResVel => wingpanel_calc_chordwiseResVel Subroutine procedure\n                    ,                  public\n,                   :: calc_area => wingpanel_calc_area Subroutine procedure\n                    ,                  public\n,                   :: calc_mean_dimensions => wingpanel_calc_mean_dimensions Subroutine procedure\n                    ,                  public\n,                   :: isCPinsidecore => wingpanel_isCPinsidecore Function type, public :: Nwake_class Near wake class Components Type Visibility Attributes Name Initial type( vr_class ), public :: vr type, public :: Fwake_class Far wake class Components Type Visibility Attributes Name Initial type( vf_class ), public :: vf real(kind=dp), public :: gam = 0._dp Circulation Type-Bound Procedures procedure\n                    ,                  public\n,                   :: shiftdP => Fwake_shiftdP Subroutine procedure\n                    ,                  public\n,                   :: assignP => Fwake_assignP Subroutine procedure\n                    ,                  public\n,                   :: rot => Fwake_rot Subroutine procedure\n                    ,                  public\n,                   :: decay => Fwake_decay Subroutine procedure\n                    ,                  public\n,                   :: mirror => Fwake_mirror Subroutine type, public :: pFwake_class Prescribed far wake Components Type Visibility Attributes Name Initial type( Fwake_class ), public, dimension(240) :: waF real(kind=dp), public, dimension(3, 241) :: coords real(kind=dp), public :: nRevs = 10.0 real(kind=dp), public :: helixPitch = 0._dp real(kind=dp), public :: helixRadius = 0._dp real(kind=dp), public :: relaxFactor = 0.5_dp logical, public :: isClockwiseRotor = .True. logical, public :: isPresent = .false. Type-Bound Procedures procedure\n                    ,                  public\n,                   :: update => pFwake_update Subroutine procedure\n                    ,                  public\n,                   :: rot_wake_axis => pFwake_rot_wake_axis Subroutine type, public :: blade_class Single blade class Components Type Visibility Attributes Name Initial character(len=2), public :: id type( wingpanel_class ), public, allocatable, dimension(:, :) :: wiP Wing panel type( Nwake_class ), public, allocatable, dimension(:, :) :: waN Near wake type( Fwake_class ), public, allocatable, dimension(:) :: waF Far wake type( pFwake_class ), public :: wapF Prescribed far wake type( pFwake_class ), public :: wapFPredicted Prescribed far wake type( Nwake_class ), public, allocatable, dimension(:, :) :: waNPredicted type( Fwake_class ), public, allocatable, dimension(:) :: waFPredicted type( C81_class ), public, allocatable, dimension(:) :: C81 integer, public :: nc No. of chordwise panels integer, public :: ns No. of spanwise panels real(kind=dp), public :: theta real(kind=dp), public :: psi real(kind=dp), public :: pivotLE Location of pivot from LE (x/c) for setting pitch angle real(kind=dp), public :: preconeAngle Precone angle for blade real(kind=dp), public :: velWakeMax Max vel on wake collocation points for preventing blowup real(kind=dp), public :: flapInitial real(kind=dp), public :: dflapInitial real(kind=dp), public :: flapPrev real(kind=dp), public :: dflapPrev real(kind=dp), public :: flap real(kind=dp), public :: dflap real(kind=dp), public :: Iflap real(kind=dp), public :: kflap real(kind=dp), public :: cflap real(kind=dp), public :: MflapConstant real(kind=dp), public :: MflapLift real(kind=dp), public :: MflapLiftPrev real(kind=dp), public, dimension(3) :: flapOrigin real(kind=dp), public, dimension(3) :: forceInertial real(kind=dp), public, dimension(3) :: lift real(kind=dp), public, dimension(3) :: drag real(kind=dp), public, dimension(3) :: dragInduced real(kind=dp), public, dimension(3) :: dragProfile real(kind=dp), public, dimension(3) :: liftUnsteady real(kind=dp), public, dimension(3) :: dragUnsteady integer, public, allocatable, dimension(:) :: airfoilNo character(len=30), public, allocatable, dimension(:) :: airfoilFile real(kind=dp), public, allocatable, dimension(:) :: airfoilSectionLimit real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake1 real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake2 real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwake3 real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwakePredicted real(kind=dp), public, allocatable, dimension(:, :, :) :: velNwakeStep real(kind=dp), public, allocatable, dimension(:, :) :: velFwake real(kind=dp), public, allocatable, dimension(:, :) :: velFwake1 real(kind=dp), public, allocatable, dimension(:, :) :: velFwake2 real(kind=dp), public, allocatable, dimension(:, :) :: velFwake3 real(kind=dp), public, allocatable, dimension(:, :) :: velFwakePredicted real(kind=dp), public, allocatable, dimension(:, :) :: velFwakeStep integer, public :: stlNodesCols real(kind=dp), public, allocatable, dimension(:, :) :: stlNodes integer, public, allocatable, dimension(:, :) :: stlElementNodes real(kind=dp), public, dimension(3) :: xAxis real(kind=dp), public, dimension(3) :: yAxis real(kind=dp), public, dimension(3) :: zAxis real(kind=dp), public, dimension(3) :: xAxisAzi real(kind=dp), public, dimension(3) :: yAxisAzi real(kind=dp), public, dimension(3) :: zAxisAzi real(kind=dp), public, dimension(3) :: xAxisAziFlap real(kind=dp), public, dimension(3) :: yAxisAziFlap real(kind=dp), public, dimension(3) :: zAxisAziFlap real(kind=dp), public, allocatable, dimension(:) :: secChord real(kind=dp), public, allocatable, dimension(:) :: secArea real(kind=dp), public, allocatable, dimension(:, :) :: secForceInertial real(kind=dp), public, allocatable, dimension(:, :) :: secLift real(kind=dp), public, allocatable, dimension(:, :) :: secDrag real(kind=dp), public, allocatable, dimension(:, :) :: secLiftDir real(kind=dp), public, allocatable, dimension(:, :) :: secDragDir real(kind=dp), public, allocatable, dimension(:, :) :: secLiftInPlane real(kind=dp), public, allocatable, dimension(:, :) :: secLiftOutPlane real(kind=dp), public, allocatable, dimension(:, :) :: secDragInduced real(kind=dp), public, allocatable, dimension(:, :) :: secDragProfile real(kind=dp), public, allocatable, dimension(:, :) :: secLiftUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secDragUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secLiftInPlaneUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secLiftOutPlaneUnsteady real(kind=dp), public, allocatable, dimension(:, :) :: secTauCapChord real(kind=dp), public, allocatable, dimension(:, :) :: secTauCapSpan real(kind=dp), public, allocatable, dimension(:, :) :: secNormalVec real(kind=dp), public, allocatable, dimension(:, :) :: secCP real(kind=dp), public, allocatable, dimension(:, :) :: secChordwiseResVel real(kind=dp), public, allocatable, dimension(:) :: secAlpha real(kind=dp), public, allocatable, dimension(:) :: secPhi real(kind=dp), public, allocatable, dimension(:) :: secTheta real(kind=dp), public, allocatable, dimension(:) :: secViz real(kind=dp), public, allocatable, dimension(:) :: secVix real(kind=dp), public, allocatable, dimension(:) :: secCD real(kind=dp), public, allocatable, dimension(:) :: secCM real(kind=dp), public, allocatable, dimension(:) :: secMflap real(kind=dp), public, allocatable, dimension(:) :: secMflapArm real(kind=dp), public, allocatable, dimension(:) :: alpha0 real(kind=dp), public, allocatable, dimension(:) :: secCL real(kind=dp), public, allocatable, dimension(:) :: secCLu integer, public :: spanwiseLiftSwitch Type-Bound Procedures procedure\n                    ,                  public\n,                   :: move => blade_move Subroutine procedure\n                    ,                  public\n,                   :: rotate => blade_rotate Subroutine procedure\n                    ,                  public\n,                   :: rot_pitch => blade_rot_pitch Subroutine procedure\n                    ,                  public\n,                   :: rot_wake_axis => blade_rot_wake_axis Subroutine procedure\n                    ,                  public\n,                   :: rot_pts => blade_rot_pts Subroutine procedure\n                    ,                  public\n,                   :: rot_flap => blade_rot_flap Subroutine procedure\n                    ,                  public\n,                   :: vind_bywing => blade_vind_bywing Function procedure\n                    ,                  public\n,                   :: vindSource_bywing => blade_vindSource_bywing Function procedure\n                    ,                  public\n,                   :: vind_bywing_boundVortices => blade_vind_bywing_boundVortices Function procedure\n                    ,                  public\n,                   :: vind_bywing_chordwiseVortices => blade_vind_bywing_chordwiseVortices Function procedure\n                    ,                  public\n,                   :: vind_boundVortex => blade_vind_boundVortex Function procedure\n                    ,                  public\n,                   :: vind_bywake => blade_vind_bywake Function procedure\n                    ,                  public\n,                   :: convectwake => blade_convectwake Subroutine procedure\n                    ,                  public\n,                   :: limitWakeVel => blade_limitWakeVel Subroutine procedure\n                    ,                  public\n,                   :: calc_secChord Subroutine procedure\n                    ,                  public\n,                   :: calc_secArea Subroutine procedure\n                    ,                  public\n,                   :: calc_force => blade_calc_force Subroutine procedure\n                    ,                  public\n,                   :: calc_force_alpha => blade_calc_force_alpha Subroutine procedure\n                    ,                  public\n,                   :: calc_force_alphaGamma => blade_calc_force_alphaGamma Subroutine procedure\n                    ,                  public\n,                   :: calc_secAlpha => blade_calc_secAlpha Subroutine procedure\n                    ,                  public\n,                   :: calc_secChordwiseResVel => blade_calc_secChordwiseResVel Subroutine procedure\n                    ,                  public\n,                   :: burst_wake => blade_burst_wake Subroutine procedure\n                    ,                  public\n,                   :: calc_skew => blade_calc_skew Subroutine procedure\n                    ,                  public\n,                   :: calc_secLocations => blade_calc_secLocations Subroutine procedure\n                    ,                  public\n,                   :: lookup_secCoeffs => blade_lookup_secCoeffs Subroutine procedure\n                    ,                  public\n,                   :: secCoeffsToSecForces => blade_secCoeffsToSecForces Subroutine procedure\n                    ,                  public\n,                   :: dirLiftDrag => blade_dirLiftDrag Subroutine procedure\n                    ,                  public\n,                   :: sumSecToNetForces => blade_sumSecToNetForces Subroutine procedure\n                    ,                  public\n,                   :: calc_stlStats => blade_calc_stlStats Subroutine procedure\n                    ,                  public\n,                   :: computeBladeDynamics => blade_computeBladeDynamics Subroutine procedure\n                    ,                  public\n,                   :: getddflap Function procedure\n                    ,                  public\n,                   :: blade_write Subroutine generic,\n                  public\n,                   :: write(unformatted) => blade_write procedure\n                    ,                  public\n,                   :: blade_read Subroutine generic,\n                  public\n,                   :: read(unformatted) => blade_read type, public :: rotor_class Rotor class Components Type Visibility Attributes Name Initial character(len=2), public :: id integer, public :: nb integer, public :: ns integer, public :: nc integer, public :: nNwake integer, public :: nFwake integer, public :: nbConvect integer, public :: nNwakeEnd integer, public :: nFwakeEnd type( blade_class ), public, allocatable, dimension(:) :: blade real(kind=dp), public :: Omega real(kind=dp), public :: omegaSlow real(kind=dp), public, dimension(3) :: shaftAxis real(kind=dp), public, dimension(3) :: xAxisBody real(kind=dp), public, dimension(3) :: yAxisBody real(kind=dp), public, dimension(3) :: zAxisBody real(kind=dp), public, dimension(3) :: hubCoords real(kind=dp), public, dimension(3) :: cgCoords real(kind=dp), public, dimension(3) :: fromCoords real(kind=dp), public :: radius real(kind=dp), public :: chord real(kind=dp), public :: root_cut real(kind=dp), public :: preconeAngle real(kind=dp), public :: dpitch real(kind=dp), public :: flapInitial real(kind=dp), public :: dflapInitial real(kind=dp), public :: Iflap real(kind=dp), public :: cflap real(kind=dp), public :: kflap real(kind=dp), public :: MflapConstant real(kind=dp), public, dimension(3) :: forceInertial real(kind=dp), public, dimension(3) :: lift real(kind=dp), public, dimension(3) :: liftPrev real(kind=dp), public, dimension(3) :: drag real(kind=dp), public, dimension(3) :: dragInduced real(kind=dp), public, dimension(3) :: dragProfile real(kind=dp), public, dimension(3) :: liftUnsteady real(kind=dp), public, dimension(3) :: dragUnsteady real(kind=dp), public, dimension(3) :: liftUnitVec real(kind=dp), public, dimension(3) :: dragUnitVec real(kind=dp), public, dimension(3) :: sideUnitVec real(kind=dp), public, dimension(3) :: controlPitch real(kind=dp), public :: thetaTwist real(kind=dp), public :: pivotLE real(kind=dp), public :: flapHinge real(kind=dp), public, dimension(3) :: velBody real(kind=dp), public, dimension(3) :: omegaBody real(kind=dp), public, dimension(3) :: velBodyPrev real(kind=dp), public, dimension(3) :: omegaBodyPrev real(kind=dp), public, allocatable, dimension(:, :) :: velBodyHistory real(kind=dp), public, allocatable, dimension(:, :) :: omegaBodyHistory real(kind=dp), public :: psi real(kind=dp), public, dimension(3) :: pts character(len=1), public :: streamwiseCoreSwitch real(kind=dp), public :: spanwiseCore real(kind=dp), public, allocatable, dimension(:) :: streamwiseCoreVec real(kind=dp), public, allocatable, dimension(:, :) :: AIC real(kind=dp), public, allocatable, dimension(:, :) :: AIC_inv real(kind=dp), public, allocatable, dimension(:) :: gamVec real(kind=dp), public, allocatable, dimension(:) :: gamVecPrev real(kind=dp), public, allocatable, dimension(:) :: RHS real(kind=dp), public, allocatable, dimension(:) :: camberSectionLimit real(kind=dp), public, allocatable, dimension(:) :: airfoilSectionLimit real(kind=dp), public, allocatable, dimension(:) :: alpha0 real(kind=dp), public :: initWakeVel real(kind=dp), public :: psiStart real(kind=dp), public :: skewLimit real(kind=dp), public :: apparentViscCoeff real(kind=dp), public :: decayCoeff real(kind=dp), public :: rollupStartRadius real(kind=dp), public :: rollupEndRadius integer, public :: propConvention integer, public :: spanSpacing integer, public :: chordSpacing integer, public :: overrideTauSpan integer, public :: symmetricTau integer, public :: wakeTruncateNt integer, public :: prescWakeNt integer, public :: prescWakeAfterTruncNt integer, public :: prescWakeGenNt integer, public :: rollupStart integer, public :: rollupEnd integer, public :: suppressFwakeSwitch integer, public :: forceCalcSwitch integer, public :: skewPlotSwitch integer, public :: inflowPlotSwitch integer, public :: bladeDynamicsSwitch integer, public :: pitchDynamicsSwitch integer, public :: bodyDynamicsSwitch integer, public :: bodyDynamicsIOVars integer, public :: spanwiseLiftSwitch integer, public :: customTrajectorySwitch integer, public :: gammaPlotSwitch integer, public :: rowNear integer, public :: rowFar integer, public :: nCamberFiles integer, public :: nAirfoils integer, public :: imagePlane integer, public :: imageRotorNum integer, public :: surfaceType integer, public :: axisymmetrySwitch character(len=30), public, allocatable, dimension(:) :: camberFile character(len=30), public, allocatable, dimension(:) :: airfoilFile character(len=30), public :: geometryFile real(kind=dp), public :: nonDimforceDenominator Type-Bound Procedures procedure\n                    ,                  public\n,                   :: readGeom => rotor_readGeom Subroutine procedure\n                    ,                  public\n,                   :: init => rotor_init Subroutine procedure\n                    ,                  public\n,                   :: deinit => rotor_deinit Subroutine procedure\n                    ,                  public\n,                   :: plot3dtoblade => rotor_plot3dtoblade Subroutine procedure\n                    ,                  public\n,                   :: stltoblade => rotor_stltoblade Subroutine procedure\n                    ,                  public\n,                   :: getCamber => rotor_getCamber Function procedure\n                    ,                  public\n,                   :: gettheta => rotor_gettheta Function procedure\n                    ,                  public\n,                   :: getthetadot => rotor_getthetadot Function procedure\n                    ,                  public\n,                   :: move => rotor_move Subroutine procedure\n                    ,                  public\n,                   :: rot_pts => rotor_rot_pts Subroutine procedure\n                    ,                  public\n,                   :: rot_advance => rotor_rot_advance Subroutine procedure\n                    ,                  public\n,                   :: rot_flap => rotor_rot_flap Subroutine procedure\n                    ,                  public\n,                   :: assignshed => rotor_assignshed Subroutine procedure\n                    ,                  public\n,                   :: map_gam => rotor_map_gam Subroutine procedure\n                    ,                  public\n,                   :: age_wake => rotor_age_wake Subroutine procedure\n                    ,                  public\n,                   :: dissipate_wake => rotor_dissipate_wake Subroutine procedure\n                    ,                  public\n,                   :: strain_wake => rotor_strain_wake Subroutine procedure\n                    ,                  public\n,                   :: calcAIC => rotor_calcAIC Subroutine procedure\n                    ,                  public\n,                   :: vind_bywing => rotor_vind_bywing Function procedure\n                    ,                  public\n,                   :: vind_bywing_boundVortices => rotor_vind_bywing_boundVortices Function procedure\n                    ,                  public\n,                   :: vind_bywake => rotor_vind_bywake Function procedure\n                    ,                  public\n,                   :: shiftwake => rotor_shiftwake Subroutine procedure\n                    ,                  public\n,                   :: shiftFwake => rotor_shiftFwake Subroutine procedure\n                    ,                  public\n,                   :: rollup => rotor_rollup Subroutine procedure\n                    ,                  public\n,                   :: calc_force => rotor_calc_force Subroutine procedure\n                    ,                  public\n,                   :: calc_force_alpha => rotor_calc_force_alpha Subroutine procedure\n                    ,                  public\n,                   :: calc_force_alphaGamma => rotor_calc_force_alphaGamma Subroutine procedure\n                    ,                  public\n,                   :: calc_secAlpha => rotor_calc_secAlpha Subroutine procedure\n                    ,                  public\n,                   :: convectwake => rotor_convectwake Subroutine procedure\n                    ,                  public\n,                   :: burst_wake => rotor_burst_wake Subroutine procedure\n                    ,                  public\n,                   :: calc_skew => rotor_calc_skew Subroutine procedure\n                    ,                  public\n,                   :: dirLiftDrag => rotor_dirLiftDrag Subroutine procedure\n                    ,                  public\n,                   :: sumBladeToNetForces => rotor_sumBladeToNetForces Subroutine procedure\n                    ,                  public\n,                   :: mirrorGamma => rotor_mirrorGamma Subroutine procedure\n                    ,                  public\n,                   :: mirrorVelCP => rotor_mirrorVelCP Subroutine procedure\n                    ,                  public\n,                   :: mirrorWake => rotor_mirrorWake Subroutine procedure\n                    ,                  public\n,                   :: toChordsRevs => rotor_toChordsRevs Subroutine procedure\n                    ,                  public\n,                   :: eraseNwake => rotor_eraseNwake Subroutine procedure\n                    ,                  public\n,                   :: eraseFwake => rotor_eraseFwake Subroutine procedure\n                    ,                  public\n,                   :: updatePrescribedWake => rotor_updatePrescribedWake Subroutine procedure\n                    ,                  public\n,                   :: computeBladeDynamics => rotor_computeBladeDynamics Subroutine procedure\n                    ,                  public\n,                   :: getdw Function procedure\n                    ,                  public\n,                   :: computeBodyDynamics => rotor_computeBodyDynamics Subroutine procedure\n                    ,                  public\n,                   :: rotor_write Subroutine generic,\n                  public\n,                   :: write(unformatted) => rotor_write procedure\n                    ,                  public\n,                   :: rotor_read Subroutine generic,\n                  public\n,                   :: read(unformatted) => rotor_read Functions public  function vf_vind (this, P) result(vind) Compute induced velocity by unit strength vortex filament Arguments Type Intent Optional Attributes Name class( vf_class ) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function vr_vind (this, P) result(vind) Compute induced velocity by unit strength 4-element vortex ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function vr_vindSource (this, P, nCap) result(vind) Compute induced velocity by unit strength 3-element source ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in), dimension(3) :: P real(kind=dp), intent(in), dimension(3) :: nCap Return Value real(kind=dp), dimension(3) public  function vr_getInteriorAngles (this) Obtain interior angles of vortex ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Return Value real(kind=dp), dimension(4) public  function vr_getMedianAngle (this) Obtain median angle of vortex ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Return Value real(kind=dp) public  function vr_getBimedianCos (this) Obtain angle between bimedians Arguments Type Intent Optional Attributes Name class( vr_class ) :: this Return Value real(kind=dp) public  function wingpanel_isCPinsidecore (this) Check whether collocation point lies\ninside viscous core region of vortex ring Arguments Type Intent Optional Attributes Name class( wingpanel_class ), intent(in) :: this Return Value logical public  function blade_vind_bywing (this, P) Compute induced velocity by blade bound vorticity Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function blade_vindSource_bywing (this, P) Compute induced velocity by blade bound vorticity Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function blade_vind_bywing_boundVortices (this, P) Compute induced velocity by bound vortices alone Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function blade_vind_bywing_chordwiseVortices (this, P) Compute induced velocity by bound vortices alone Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function blade_vind_boundVortex (this, ic, is, P) Compute induced velocity by bound vortices alone Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: ic integer, intent(in) :: is real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function blade_vind_bywake (this, rowNear, rowFar, P, optionalChar) Compute induced velocity by wake vortex rings Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar real(kind=dp), intent(in), dimension(3) :: P character(len=1), optional :: optionalChar Return Value real(kind=dp), dimension(3) public  function blade_getSecDynamicPressure (this, density) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in) :: density Return Value real(kind=dp), dimension(this%ns) public  function getddflap (this, flap, dflap, omega, MflapLift) Returns ddflap from blade flap equation Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this real(kind=dp), intent(in) :: flap real(kind=dp), intent(in) :: dflap real(kind=dp), intent(in) :: omega real(kind=dp), intent(in) :: MflapLift Return Value real(kind=dp) public  function rotor_getCamber (this, x, y) Get z coordinate on wing from x, y values Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y Return Value real(kind=dp), dimension(size(x), size(y)) public  function rotor_gettheta (this, psi, ib) Get pitch angle corresponding to blade azimuthal location Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in) :: psi integer, intent(in) :: ib Return Value real(kind=dp) public  function rotor_getthetadot (this, psi, ib) Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in) :: psi integer, intent(in) :: ib Return Value real(kind=dp) public  function rotor_vind_bywing (this, P) Compute induced velocity by all wing vortices at P Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function rotor_vind_bywing_boundVortices (this, P) Compute induced velocity by bound vortices at P Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: P Return Value real(kind=dp), dimension(3) public  function rotor_vind_bywake (this, P, optionalChar) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(in) :: this real(kind=dp), intent(in), dimension(3) :: P character(len=1), optional :: optionalChar Return Value real(kind=dp), dimension(3) public  function getdw (this, w, thrust) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: w real(kind=dp), intent(in) :: thrust Return Value real(kind=dp) Subroutines public  subroutine vf_calclength (this, isOriginal) Compute length of vortex filament Arguments Type Intent Optional Attributes Name class( vf_class ) :: this logical, intent(in) :: isOriginal public  subroutine vf_strain (this) Arguments Type Intent Optional Attributes Name class( vf_class ) :: this public  subroutine vr_assignP (this, n, P) Assign coordinates to nth corner Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: n real(kind=dp), dimension(3) :: P public  subroutine vr_shiftdP (this, n, dshift) Shift coordinates of nth corner by dshift distance \n(usually for U*dt convection) Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: dshift public  subroutine vr_rot (this, Tmat, originVec) Rotate vortex ring using Tmat about origin Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in), dimension(3, 3) :: Tmat real(kind=dp), optional, dimension(3) :: originVec public  subroutine vr_calclength (this, isOriginal) Calculate length of filaments in vortex ring Arguments Type Intent Optional Attributes Name class( vr_class ) :: this logical, intent(in) :: isOriginal public  subroutine vr_strain (this) Arguments Type Intent Optional Attributes Name class( vr_class ) :: this public  subroutine vr_decay (this, dt, decayCoeff) Arguments Type Intent Optional Attributes Name class( vr_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: decayCoeff public  subroutine vr_mirror (this, coordNum) Mirror gamma and coordinates about a specified plane Arguments Type Intent Optional Attributes Name class( vr_class ) :: this integer, intent(in) :: coordNum public  subroutine calc_skew (this) Compute skew Arguments Type Intent Optional Attributes Name class( vr_class ) :: this public  subroutine vr_burst (this, skewLimit) Burst vortex filaments if skewLimit is exceeded Arguments Type Intent Optional Attributes Name class( vr_class ) :: this real(kind=dp), intent(in) :: skewLimit public  subroutine wingpanel_assignP (this, n, P) Assign coordinates to nth corner Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this integer, intent(in) :: n real(kind=dp), dimension(3) :: P public  subroutine wingpanel_calcCP (this, isTriangle) Compute collocation point location Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle public  subroutine wingpanel_calcN (this, isTriangle) Compute normal vector Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle public  subroutine wingpanel_invertNcap (this) Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this public  subroutine wingpanel_calcTau (this, isTriangle) Compute chordwise and spanwise tangential vectors Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this logical, optional :: isTriangle public  subroutine wingpanel_rot (this, Tmat, originVec) Rotate panel using transformation matrix Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this real(kind=dp), dimension(3, 3) :: Tmat real(kind=dp), optional, dimension(3) :: originVec public  subroutine wingpanel_shiftdP (this, dshift) Shift corners of vortex ring by dshift Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift public  subroutine wingpanel_calc_area (this) Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this public  subroutine wingpanel_calc_mean_dimensions (this) Calculate mean chord and mean span Arguments Type Intent Optional Attributes Name class( wingpanel_class ) :: this public  subroutine wingpanel_calc_chordwiseResVel (this) Compute panel resultant velocities using local velocities Arguments Type Intent Optional Attributes Name class( wingpanel_class ), intent(inout) :: this public  subroutine Fwake_shiftdP (this, n, dshift) Shift coordinates of nth corner by dshift distance\n(usually for Udt convection) Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: dshift public  subroutine Fwake_assignP (this, n, P) Assign point to nth endpoint of filament Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: n real(kind=dp), intent(in), dimension(3) :: P public  subroutine Fwake_rot (this, TMat, originVec) Rotate using TMat about originVec Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this real(kind=dp), intent(in), dimension(3, 3) :: TMat real(kind=dp), optional, dimension(3) :: originVec public  subroutine Fwake_decay (this, dt, decayCoeff) Arguments Type Intent Optional Attributes Name class( Fwake_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: decayCoeff public  subroutine Fwake_mirror (this, coordNum) Mirror gamma and coordinates about a specified plane Arguments Type Intent Optional Attributes Name class( Fwake_class ) :: this integer, intent(in) :: coordNum public  subroutine pFwake_update (this, waF, hubCoords, shaftAxis, deltaPsi) Arguments Type Intent Optional Attributes Name class( pFwake_class ), intent(inout) :: this type( Fwake_class ), intent(in), dimension(:) :: waF real(kind=dp), intent(in), dimension(3) :: hubCoords real(kind=dp), intent(in), dimension(3) :: shaftAxis real(kind=dp), intent(in) :: deltaPsi public  subroutine pFwake_rot_wake_axis (this, theta, axisVec, origin) Arguments Type Intent Optional Attributes Name class( pFwake_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta real(kind=dp), intent(in), dimension(3) :: axisVec real(kind=dp), intent(in), dimension(3) :: origin public  subroutine blade_move (this, dshift) Move blade by dshift Arguments Type Intent Optional Attributes Name class( blade_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift public  subroutine blade_rot_pts (this, pts, origin, order) Rotate blade using pts. pts refers to (phi, theta, psi) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: pts real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: order public  subroutine blade_rot_pitch (this, theta) Rotate blade by pitch angle about pivotLE Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta public  subroutine blade_rot_flap (this, beta) Rotate blade by flap angle Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: beta public  subroutine blade_rotate (this, angleRad, axisX, axisY, axisZ, originX, originY, originZ, rotateType) Rotate blade geometry about axis at specified origin\nRotation angle in radians Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), value :: angleRad real(kind=dp), intent(in), value :: axisX real(kind=dp), intent(in), value :: axisY real(kind=dp), intent(in), value :: axisZ real(kind=dp), intent(in), value :: originX real(kind=dp), intent(in), value :: originY real(kind=dp), intent(in), value :: originZ character(len=*), intent(in) :: rotateType public  subroutine blade_rot_wake_axis (this, theta, axisVec, origin, rowNear, rowFar, wakeType) Rotate wake about axis at specified origin Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: theta real(kind=dp), intent(in), dimension(3) :: axisVec real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: rowNear integer, intent(in) :: rowFar character(len=1), intent(in) :: wakeType public  subroutine blade_convectwake (this, rowNear, rowFar, dt, wakeType) Convect wake collocation points using velNwake matrix Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType public  subroutine blade_limitWakeVel (this, rowNear, rowFar) Limits all wake velocity to a set value to prevent blow up Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar public  subroutine blade_wake_continuity (this, rowNear, rowFar, wakeType) Maintain continuity between vortex ring elements after convection\nof wake collocation points Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear integer, intent(in) :: rowFar character(len=1), intent(in) :: wakeType public  subroutine blade_calc_force (this, density, Omega, dt) Compute force using blade circulation Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: Omega real(kind=dp), intent(in) :: dt public  subroutine calc_secArea (this) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this public  subroutine calc_secChord (this) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this public  subroutine blade_calc_force_alpha (this, density, velSound) Compute force using sectional alpha Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound public  subroutine blade_calc_force_alphaGamma (this, density, invertGammaSign, velSound, dt) Compute force using alpha approximated from sec circulation Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: invertGammaSign real(kind=dp), intent(in) :: velSound real(kind=dp), intent(in) :: dt public  subroutine blade_secCoeffsToSecForces (this, density) Convert force coefficients to dimensional forces Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: density public  subroutine blade_lookup_secCoeffs (this, velSound) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: velSound public  subroutine blade_calc_secChordwiseResVel (this) Compute sectional resultant vel by interpolating local panel vel Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this public  subroutine blade_calc_secAlpha (this, verticalAxis) Compute sec alpha using sec resultant velocity Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: verticalAxis public  subroutine blade_calc_secLocations (this, chordwiseFraction, flapHingeRadius) Compute important locations at each section\ncoordinates of collocation point located at chord fraction\nflap moment arm Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: chordwiseFraction real(kind=dp), intent(in) :: flapHingeRadius public  subroutine blade_burst_wake (this, rowFar, skewLimit, largeCoreRadius) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowFar real(kind=dp), intent(in) :: skewLimit real(kind=dp), intent(in) :: largeCoreRadius public  subroutine blade_calc_skew (this, rowNear) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: rowNear public  subroutine blade_dirLiftDrag (this, Omega) Compute lift and drag direction vectors Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: Omega public  subroutine blade_sumSecToNetForces (this) Sum up sectional forces to net forces Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this public  subroutine blade_calc_stlStats (this) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this public  subroutine blade_computeBladeDynamics (this, dt, omega) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: omega public  subroutine blade_write (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public  subroutine blade_read (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( blade_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public  subroutine rotor_readGeom (this, filename, outputFilename) Read rotor geometry from geomXX.nml in namelist format Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: outputFilename public  subroutine rotor_init (this, rotorNumber, density, dt, nt, switches, sourceRotor) Initialize variables of rotor geometry and wake Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this integer, intent(in) :: rotorNumber real(kind=dp), intent(in) :: density real(kind=dp), intent(inout) :: dt integer, intent(inout) :: nt type( switches_class ), intent(inout) :: switches type( rotor_class ), optional :: sourceRotor public  subroutine rotor_deinit (this, switches) Deinitialise rotor variables Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this type( switches_class ), intent(in) :: switches public  subroutine rotor_plot3dtoblade (this, PLOT3Dfilename) Read blade geometry from PLOT3D formatted file Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: PLOT3Dfilename public  subroutine rotor_stltoblade (this, stlfilename) Read ASCII stl file for non-lifting surface geometry Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this character(len=*), intent(in) :: stlfilename public  subroutine rotor_calcAIC (this) Compute AIC matrix for rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_map_gam (this) Map gam from vector to matrix format Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_move (this, dshift) Arguments Type Intent Optional Attributes Name class( rotor_class ) :: this real(kind=dp), intent(in), dimension(3) :: dshift public  subroutine rotor_rot_pts (this, pts, origin, order) Rotate using pts => phi theta psi\nWarning: This rotation is about the global reference frame Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in), dimension(3) :: pts real(kind=dp), intent(in), dimension(3) :: origin integer, intent(in) :: order public  subroutine rotor_rot_flap (this) Rotate blades by flap angle Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_rot_advance (this, dpsi, nopitch) Rotate rotor by dpsi angle about axis Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dpsi logical, optional :: nopitch public  subroutine rotor_assignshed (this, edge) Assign coordinates to first rowNear of wake from last row of blade Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this character(len=2), intent(in) :: edge public  subroutine rotor_age_wake (this, dt) Update age of wake filaments Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt public  subroutine rotor_dissipate_wake (this, dt, kinematicViscosity) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt real(kind=dp), intent(in) :: kinematicViscosity public  subroutine rotor_strain_wake (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_shiftwake (this) Shift wake locations on rollup Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_shiftFwake (this) Shift wake locations of Fwake for truncation Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_rollup (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_calc_force (this, density, dt) Compute force from circulation Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: dt public  subroutine rotor_calc_force_alpha (this, density, velSound) Compute force from sec alpha Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound public  subroutine rotor_calc_force_alphaGamma (this, density, velSound, dt) Compute force from sec alpha Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound real(kind=dp), intent(in) :: dt public  subroutine rotor_calc_secAlpha (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_convectwake (this, iter, dt, wakeType) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: iter real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType public  subroutine rotor_computeBladeDynamics (this, dt) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt public  subroutine rotor_computeBodyDynamics (this, dt) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt public  subroutine rotor_burst_wake (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_calc_skew (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_dirLiftDrag (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_sumBladeToNetForces (this) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this public  subroutine rotor_mirrorGamma (this, fromRotor) Mirrors gamma from another rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor public  subroutine rotor_mirrorVelCP (this, fromRotor) Mirrors velCP, velCPm from another rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor public  subroutine rotor_mirrorWake (this, fromRotor, wakeType) Mirrors wake positions from another rotor Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this class( rotor_class ), intent(in) :: fromRotor character(len=1), intent(in) :: wakeType public  subroutine rotor_toChordsRevs (this, nsteps, dt) Converts -ve nsteps to nsteps for corresponding no. of chords or revs Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(inout) :: nsteps real(kind=dp), intent(in) :: dt public  subroutine rotor_eraseNwake (this, rowErase) Erase a near wake row by setting gamma to zero Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: rowErase public  subroutine rotor_eraseFwake (this, rowErase) Erase a far wake row by setting gamma to zero Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: rowErase public  subroutine rotor_updatePrescribedWake (this, dt, wakeType) Attaches prescribed far wake Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this real(kind=dp), intent(in) :: dt character(len=1), intent(in) :: wakeType public  subroutine rotor_read (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(inout) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public  subroutine rotor_write (this, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( rotor_class ), intent(in) :: this integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"module/classdef.html"},{"title":"libCommon – VOLCANOR","text":"Utility procedures and those to compute induced velocity of rotors Uses classdef Contents Variables rotor nt nr dt iterStart t density velSound kinematicVisc timestamp rotorChar rotorFile currentTime fileExists subIterResidual i is ic row iter ir jr ib rowErase switches probe probeVel Functions vind_onNwake_byRotor vind_onFwake_byRotor vel_order2_Nwake vel_order2_Fwake Subroutines readConfig print_status Variables Type Visibility Attributes Name Initial type( rotor_class ), public, allocatable, dimension(:) :: rotor integer, public :: nt No. of timesteps integer, public :: nr No. of rotors real(kind=dp), public :: dt Timestep size integer, public :: iterStart real(kind=dp), public :: t Time real(kind=dp), public :: density Density real(kind=dp), public :: velSound Velocity of sound to compute Mach real(kind=dp), public :: kinematicVisc Kinematic viscosity character(len=5), public :: timestamp character(len=2), public :: rotorChar character(len=10), public :: rotorFile character(len=10), public :: currentTime logical, public :: fileExists real(kind=dp), public :: subIterResidual integer, public :: i integer, public :: is integer, public :: ic integer, public :: row integer, public :: iter integer, public :: ir integer, public :: jr integer, public :: ib integer, public :: rowErase type( switches_class ), public :: switches real(kind=dp), public, allocatable, dimension(:, :) :: probe real(kind=dp), public, allocatable, dimension(:, :) :: probeVel Functions public  function vind_onNwake_byRotor (rotor, Nwake, optionalChar) result(vindArray) Compute induced velocity by rotor (wing + wake) on Nwake corner points Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(inout) :: rotor Rotor type( Nwake_class ), intent(in), dimension(:, :) :: Nwake Near wake character(len=1), optional :: optionalChar If 'P' is specified, predicted wake of rotor is used Return Value real(kind=dp), dimension(3, size(Nwake, 1), size(Nwake, 2) + 1) public  function vind_onFwake_byRotor (rotor, Fwake, optionalChar) result(vindArray) Compute induced velocity by rotor (wing + wake) on Fwake corner points Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(inout) :: rotor Rotor type( Fwake_class ), intent(in), dimension(:) :: Fwake Far wake character(len=1), optional :: optionalChar If 'P' is specified, predicted wake of rotor is used Return Value real(kind=dp), dimension(3, size(Fwake, 1)) public  function vel_order2_Nwake (v_wake_n, v_wake_np1) Calculate 2nd order accurate induced velocity on near wake Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :, :) :: v_wake_n Induced velocity on wake at timestep n real(kind=dp), intent(in), dimension(:, :, :) :: v_wake_np1 Induced velocity on wake at timestep n+1 Return Value real(kind=dp), dimension(3, size(v_wake_n, 2), size(v_wake_n, 3)) public  function vel_order2_Fwake (v_wake_n, v_wake_np1) Calculate 2nd order accurate induced velocity on far wake Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: v_wake_n Induced velocity on wake at timestep n real(kind=dp), intent(in), dimension(:, :) :: v_wake_np1 Induced velocity on wake at timestep n+1 Return Value real(kind=dp), dimension(3, size(v_wake_n, 2)) Subroutines public  subroutine readConfig (filename, outputFilename) Read config.nml input file (in namelist format) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: outputFilename public  subroutine print_status (statusMessage) Prints status message (or SUCCESS if left blank) Arguments Type Intent Optional Attributes Name character(len=*), optional :: statusMessage","tags":"","loc":"module/libcommon.html"},{"title":"libPostprocess – VOLCANOR","text":"Procedures to write out results of simulations Uses libMath Contents Variables ResultsDir Subroutines init_plots params2file geom2file probes2file filaments2file geomSurface2file tip2file skew2file force2file dynamics2file inflow2file gamma2file Variables Type Visibility Attributes Name Initial character(len=8), public :: ResultsDir = 'Results/' Subroutines public  subroutine init_plots (numOfRotors) Initialise headers for plot files Arguments Type Intent Optional Attributes Name integer, intent(in) :: numOfRotors public  subroutine params2file (rotor, nt, dt, nr, density, velSound, switches) Write rotor parameters to json file Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(in) :: rotor integer, intent(in) :: nt real(kind=dp), intent(in) :: dt integer, intent(in) :: nr real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: velSound type( switches_class ), intent(in) :: switches public  subroutine geom2file (timestamp, rotor, wakeSuppress) Plot rotor geometry and wake to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor integer, intent(in) :: wakeSuppress public  subroutine probes2file (timestamp, probe, probeVel, rotor, t) Write velocities at probe locations Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp real(kind=dp), intent(in), dimension(:, :) :: probe real(kind=dp), intent(in), dimension(:, :) :: probeVel type( rotor_class ), intent(inout), dimension(:) :: rotor real(kind=dp), intent(in) :: t public  subroutine filaments2file (timestamp, rotor) Write filaments to file for using with grid-based plots Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in), dimension(:) :: rotor public  subroutine geomSurface2file (rotor) Plot surface geometry to file Arguments Type Intent Optional Attributes Name type( rotor_class ), intent(in) :: rotor public  subroutine tip2file (timestamp, rotor) Wake tip to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor public  subroutine skew2file (timestamp, rotor) Skew parameter to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor public  subroutine force2file (timestamp, rotor) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor public  subroutine dynamics2file (timestamp, rotor) Rotor dynamics to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor public  subroutine inflow2file (timestamp, rotorArray, rotorNumber, directionVector) Calculate inflow velocity along directionVector \non the blades of rotor(rotorNumber) at rotor(rotorNumber)%secCP Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(inout), dimension(:) :: rotorArray integer, intent(in) :: rotorNumber real(kind=dp), intent(in), dimension(3) :: directionVector public  subroutine gamma2file (timestamp, rotor) Calculate inflow velocity along directionVector on the blades of rotor(rotorNumber)\nat rotor(rotorNumber)%secCP Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timestamp type( rotor_class ), intent(in) :: rotor","tags":"","loc":"module/libpostprocess.html"},{"title":"main – VOLCANOR","text":"Uses libMath libCommon libPostprocess Contents None","tags":"","loc":"program/main.html"},{"title":"gridgen – VOLCANOR","text":"Uses libMath libCommon classdef Contents Variables nx ny nz xyzMin xyzMax vel fileRange fileRangeStart fileRangeStep fileRangeEnd ix iy iz ifil xVec yVec zVec grid gridCentre velCentre nx_char ny_char nz_char filetimestamp nVrWing nVrNwake nVfNwakeTE nVfFwake vrWing vrNwake vfFwake vfNwakeTE gamFwake gamNwakeTE fileFormatVersion currentTemplateVersion Variables Type Attributes Name Initial integer :: nx integer :: ny integer :: nz real(kind=dp), dimension(3) :: xyzMin real(kind=dp), dimension(3) :: xyzMax real(kind=dp), dimension(3) :: vel integer :: fileRange integer :: fileRangeStart integer :: fileRangeStep integer :: fileRangeEnd integer :: ix integer :: iy integer :: iz integer :: ifil real(kind=dp), allocatable, dimension(:) :: xVec real(kind=dp), allocatable, dimension(:) :: yVec real(kind=dp), allocatable, dimension(:) :: zVec real(kind=dp), allocatable, dimension(:, :, :, :) :: grid real(kind=dp), allocatable, dimension(:, :, :, :) :: gridCentre real(kind=dp), allocatable, dimension(:, :, :, :) :: velCentre character(len=5) :: nx_char character(len=5) :: ny_char character(len=5) :: nz_char character(len=5) :: filetimestamp integer :: nVrWing integer :: nVrNwake integer :: nVfNwakeTE integer :: nVfFwake type( vr_class ), allocatable, dimension(:) :: vrWing type( vr_class ), allocatable, dimension(:) :: vrNwake type( vf_class ), allocatable, dimension(:) :: vfFwake type( vf_class ), allocatable, dimension(:) :: vfNwakeTE real(kind=dp), allocatable, dimension(:) :: gamFwake real(kind=dp), allocatable, dimension(:) :: gamNwakeTE character(len=10) :: fileFormatVersion character(len=10) :: currentTemplateVersion","tags":"","loc":"program/gridgen.html"},{"title":"libMath.f90 – VOLCANOR","text":"Module definition for libMath module Contents Modules libMath Source Code libMath.f90 Source Code !! Module definition for libMath module module libMath !! Procedures to manipulate matrices and vectors implicit none integer , parameter :: dp = kind ( 1.d0 ) !! Double precision setting real ( dp ), parameter :: pi = atan ( 1._dp ) * 4._dp !! Value of pi real ( dp ), parameter :: eps = epsilon ( 1._dp ) !! Value of machine epsilon real ( dp ), parameter :: degToRad = pi / 18 0._dp !! For converting degree to radian real ( dp ), parameter :: radToDeg = 18 0._dp / pi !! For converting radian to degree real ( dp ), parameter , dimension ( 3 ) :: xAxis = [ 1._dp , 0._dp , 0._dp ] !! Global x-axis real ( dp ), parameter , dimension ( 3 ) :: yAxis = [ 0._dp , 1._dp , 0._dp ] !! Global y-axis real ( dp ), parameter , dimension ( 3 ) :: zAxis = [ 0._dp , 0._dp , 1._dp ] !! Global z-axis interface lsq2 module procedure lsq2_scalar , lsq2_array end interface contains function isFloatEqual ( a , b , tol ) !! Checks if a == b within a tolerance real ( dp ), intent ( in ) :: a !! Real number a real ( dp ), intent ( in ) :: b !! Real number b real ( dp ), optional :: tol !! Tolerance is epsilon if not specified logical :: isFloatEqual if (. not . present ( tol )) then isFloatEqual = abs ( a - b ) < eps else isFloatEqual = abs ( a - b ) < tol endif end function isFloatEqual function inv2 ( A ) result ( Ainv ) !! Inverse of a matrix calculated by finding the LU !! decomposition using LAPACK real ( dp ), dimension (:, :), intent ( in ) :: A !! Square matrix A real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: Ainv !! Inverse of matrix A real ( dp ), dimension ( size ( A , 1 )) :: work ! work array for LAPACK integer , dimension ( size ( A , 1 )) :: ipiv ! pivot indices integer :: n , info external DGETRF external DGETRI ! Store A in Ainv to prevent it from being overwritten by LAPACK Ainv = A n = size ( A , 1 ) ! DGETRF computes an LU factorization of a general M-by-N matrix A ! using partial pivoting with row interchanges. call DGETRF ( n , n , Ainv , n , ipiv , info ) if ( info /= 0 ) then error stop 'Matrix is numerically singular!' end if ! DGETRI computes the inverse of a matrix using the LU factorization ! computed by DGETRF. call DGETRI ( n , Ainv , n , ipiv , work , n , info ) if ( info /= 0 ) then error stop 'Matrix inversion failed!' end if end function inv2 function matmul2 ( A , B ) result ( AB ) !! Matrix multiplication implemented using BLAS real ( dp ), dimension (:, :), intent ( in ) :: A !! Matrix A real ( dp ), dimension (:, :), intent ( in ) :: B !! Matrix B real ( dp ), dimension ( size ( A , 1 ), size ( B , 2 )) :: AB !! Product of matrices A and B integer :: m , k external DGEMM m = size ( A , 1 ) k = size ( A , 2 ) AB = 0._dp call DGEMM ( 'N' , 'N' , m , size ( B , 2 ), k , 1._dp , A , m , B , k , 0._dp , AB , m ) end function matmul2 function matmulAX ( A , X ) result ( AX ) !! Matrix multiplication with vector implemented using BLAS real ( dp ), dimension (:, :), intent ( in ) :: A !! Matrix A real ( dp ), dimension (:), intent ( in ) :: X !! Vector X real ( dp ), dimension ( size ( A , 1 )) :: AX !! Product of matrix A and vector X integer :: m , n external DGEMV m = size ( A , 1 ) n = size ( A , 2 ) call DGEMV ( 'N' , m , n , 1._dp , A , m , X , 1 , 0._dp , AX , 1 ) end function matmulAX function length3d ( P1 , P2 ) result ( length ) !! Compute length of linesegment between points P1 and P2 real ( dp ), intent ( in ), dimension ( 3 ) :: P1 !! Coordinates of point P1 real ( dp ), intent ( in ), dimension ( 3 ) :: P2 !! Coordinates of point P2 real ( dp ) :: length !! Length of linesegment real ( dp ), dimension ( 3 ) :: delta delta = P1 - P2 length = norm2 ( delta ) end function length3d function linspace ( xstart , xend , nx ) result ( xout ) !! Return linearly-spaced array over a specified interval real ( dp ), intent ( in ) :: xstart !! Start value of sequence real ( dp ), intent ( in ) :: xend !! End value of sequence integer , intent ( in ) :: nx !! Number of points sequence real ( dp ), dimension ( nx ) :: xout !! Array of real numbers integer :: i real ( dp ) :: dx dx = ( xend - xstart ) / ( nx - 1 ) xout = [(( i * dx ), i = 0 , nx - 1 )] xout = xout + xstart end function linspace function cosspace ( xstart , xend , nx ) result ( xout ) !! Return cossine-spaced array over a specified interval real ( dp ), intent ( in ) :: xstart , xend integer , intent ( in ) :: nx real ( dp ), dimension ( nx ) :: xout real ( dp ), dimension ( nx ) :: theta_spacing theta_spacing = linspace ( 0._dp , pi , nx ) xout = xstart + ( xend - xstart ) * 0.5_dp * & ( 1._dp - cos ( theta_spacing )) end function cosspace function halfsinspace ( xstart , xend , nx ) result ( xout ) !! Return half sine-spaced array over a specified interval real ( dp ), intent ( in ) :: xstart , xend integer , intent ( in ) :: nx real ( dp ), dimension ( nx ) :: xout real ( dp ), dimension ( nx ) :: theta_spacing theta_spacing = linspace ( 0._dp , pi * 0.5_dp , nx ) xout = xstart + ( xend - xstart ) * sin ( theta_spacing ) end function halfsinspace function tanspace ( xstart , xend , nx ) result ( xout ) !! Return tan-spaced array over a specified interval real ( dp ), intent ( in ) :: xstart , xend integer , intent ( in ) :: nx real ( dp ) :: thetaLimits real ( dp ), dimension ( nx ) :: xout real ( dp ), dimension ( nx ) :: theta_spacing thetaLimits = 1.2_dp theta_spacing = linspace ( - 1._dp * thetaLimits , thetaLimits , nx ) xout = xstart + ( xend - xstart ) * tan ( theta_spacing ) / tan ( thetaLimits ) end function tanspace function cross_product ( aVec , bVec ) !! Compute cross product between two 3d vectors real ( dp ), intent ( in ), dimension ( 3 ) :: aVec , bVec real ( dp ), dimension ( 3 ) :: cross_product cross_product ( 1 ) = aVec ( 2 ) * bVec ( 3 ) - aVec ( 3 ) * bVec ( 2 ) cross_product ( 2 ) = aVec ( 3 ) * bVec ( 1 ) - aVec ( 1 ) * bVec ( 3 ) cross_product ( 3 ) = aVec ( 1 ) * bVec ( 2 ) - aVec ( 2 ) * bVec ( 1 ) end function cross_product function outer_product ( aVec , bVec ) !! Compute outer product between two 3d vectors real ( dp ), intent ( in ), dimension ( 3 ) :: aVec , bVec real ( dp ), dimension ( 3 , 3 ) :: outer_product outer_product (:, 1 ) = [ aVec ( 1 ) * bVec ( 1 ), aVec ( 2 ) * bVec ( 1 ), aVec ( 3 ) * bVec ( 1 )] outer_product (:, 2 ) = [ aVec ( 1 ) * bVec ( 2 ), aVec ( 2 ) * bVec ( 2 ), aVec ( 3 ) * bVec ( 2 )] outer_product (:, 3 ) = [ aVec ( 1 ) * bVec ( 2 ), aVec ( 2 ) * bVec ( 3 ), aVec ( 3 ) * bVec ( 3 )] end function outer_product function getAngleTan ( aVec , bVec ) !! Angle between two 3d vectors using tan formula !! Result will be from -pi to pi real ( dp ), intent ( in ), dimension ( 3 ) :: aVec , bVec real ( dp ) :: getAngleTan real ( dp ) :: mag2A , mag2B , dotAB mag2A = sum ( aVec ** 2._dp ) mag2B = sum ( bVec ** 2._dp ) dotAB = dot_product ( aVec , bVec ) getAngleTan = atan2 ( sqrt ( mag2A * mag2B - dotAB * dotAB ), dotAB ) end function getAngleTan function getAngleCos ( aVec , bVec ) !! Angle between two 3d vectors using cos formula !! Assumes no angle > 180 deg exists real ( dp ), intent ( in ), dimension ( 3 ) :: aVec , bVec real ( dp ) :: getAngleCos getAngleCos = acos ( dot_product ( aVec , bVec ) / & ( sqrt ( sum ( aVec ** 2._dp ) * sum ( bVec ** 2._dp )))) end function getAngleCos function unitVec ( aVec ) !! Normalizes a non-zero 3d vector real ( dp ), intent ( in ), dimension ( 3 ) :: aVec real ( dp ), dimension ( 3 ) :: unitVec real ( dp ) :: normVal normVal = norm2 ( aVec ) if ( normVal > eps ) then unitVec = aVec / normVal else unitVec = 0.0 endif end function unitVec function projVec ( aVec , dirVec ) !! Returns 3d vector aVec projected along dirVec real ( dp ), intent ( in ), dimension ( 3 ) :: aVec , dirVec real ( dp ), dimension ( 3 ) :: projVec real ( dp ) :: normSq normSq = sum ( dirVec ** 2._dp ) if ( normSq > eps ) then projVec = dot_product ( aVec , dirVec ) * dirVec / normSq else projVec = 0._dp endif end function projVec function noProjVec ( aVec , dirVec ) !! Removes component along dirVec from a vector aVec real ( dp ), intent ( in ), dimension ( 3 ) :: aVec , dirVec real ( dp ), dimension ( 3 ) :: noProjVec real ( dp ) :: normSq normSq = sum ( dirVec ** 2._dp ) if ( normSq > eps ) then noProjVec = aVec - dot_product ( aVec , dirVec ) * dirVec / normSq else noProjVec = aVec endif end function noProjVec function inv ( A ) result ( Ainv ) !! Native implementation of matrix inverse based on Doolittle method ! Matrix Inversion algorithm ! Ax=b ! PA = LU or A=P'LU ! P'LUx=b ! LUx=Pb ! Solve Ld=Pb using Forward  sub where d=Ux ! Solve Ux=d using Backward sub real ( dp ), intent ( in ), dimension (:, :) :: A real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: Ainv integer :: n integer :: i , j , k , bb ! Running variables ! Variables for calculating Permutation matrix real ( dp ) :: max_elem real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: A_dummy real ( dp ), dimension ( size ( A , 1 )) :: P_swap , A_swap ! Variables for LU Decomposition real ( dp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: L , U , P real ( dp ), dimension ( size ( A , 1 )) :: Pb , d , x , bvec real ( dp ) :: sumu , suml real ( dp ), dimension ( size ( A , 1 )) :: diagonalTerms n = size ( A , 1 ) A_dummy = A ! Find Permutation Matrix for partial pivoting ! Creating P as Identity Matrix P = 0._dp do i = 1 , n P ( i , i ) = 1. enddo do j = 1 , n max_elem = maxval ( A_dummy ( j : n , j )) do i = j , n if ( A ( i , j ) - max_elem . lt . eps ) then P_swap = P ( i , :) P ( i , :) = P ( j , :) P ( j , :) = P_swap A_swap = A_dummy ( i , :) A_dummy ( i , :) = A_dummy ( j , :) A_dummy ( j , :) = A_swap exit endif enddo enddo ! LU decomposition using Doolittle algorithm on PA ! A_dummy is now P*A U ( 1 , :) = A_dummy ( 1 , :) L (:, 1 ) = A_dummy (:, 1 ) / A_dummy ( 1 , 1 ) sumu = 0._dp suml = 0._dp do i = 2 , n do j = 2 , n sumu = 0._dp suml = 0._dp do k = 1 , i - 1 sumu = sumu + L ( i , k ) * U ( k , j ) suml = suml + L ( j , k ) * U ( k , i ) enddo U ( i , j ) = A_dummy ( i , j ) - sumu if ( abs ( U ( i , i )) . gt . eps ) L ( j , i ) = ( A_dummy ( j , i ) - suml ) / U ( i , i ) enddo enddo ! Assigning all zero elements in triangular matrices do i = 1 , n diagonalTerms ( i ) = U ( i , i ) do j = 1 , n if ( i > j ) then U ( i , j ) = 0._dp elseif ( j > i ) then L ( i , j ) = 0._dp endif enddo enddo ! Checking diagonal elements for zero ! If determinant is computed here by multiplication, ! for large matrices it may produce floating point overflow do i = 1 , n if ( abs ( diagonalTerms ( i )) < eps ) then print * print * , 'ERROR: Matrix is Singular or Ill-conditioned!!' print * , 'A-matrix:' call print_mat ( A ) print * , 'U-matrix:' call print_mat ( U ) stop 404 endif enddo ! Changing RHS loop do bb = 1 , n bvec = 0._dp bvec ( bb ) = 1._dp Pb = matmul ( P , bvec ) d = 0._dp x = 0._dp ! Forward Substitution d ( 1 ) = Pb ( 1 ) do i = 2 , n suml = 0._dp do k = 1 , i - 1 suml = suml + L ( i , k ) * d ( k ) enddo d ( i ) = Pb ( i ) - suml enddo ! Backward Substitution x ( n ) = d ( n ) / U ( n , n ) do i = n - 1 , 1 , - 1 sumu = 0._dp do k = i + 1 , n sumu = sumu + U ( i , k ) * x ( k ) enddo x ( i ) = ( d ( i ) - sumu ) / U ( i , i ) enddo Ainv (:, bb ) = x enddo end function inv function isInverse ( A , Ainv ) !! Check if Ainv is inverse of matrix A by multiplication logical :: isInverse real ( dp ), intent ( in ), dimension (:, :) :: A , Ainv real ( dp ), dimension ( size ( A , 1 ), size ( A , 2 )) :: productMat integer :: i , j real ( dp ) :: tol productMat = matmul2 ( A , Ainv ) isInverse = . TRUE . tol = 1E-04 do j = 1 , size ( A , 2 ) do i = 1 , size ( A , 1 ) if ( i . ne . j ) then ! Check if off-diagonal values are 0._dp if ( productMat ( i , j ) > tol ) then isInverse = . FALSE . !print*,i,j,'Off-diagonal values non-zero',productMat(i,j) endif else ! Check if on-diagonal values are 1._dp if ( productMat ( i , j ) - 1._dp > tol ) then isInverse = . FALSE . !print*,i,'Diagonal values non-unity',productMat(i,j) endif endif enddo enddo end function isInverse subroutine print_mat ( M ) !! Display in matrix format real ( dp ), intent ( in ), dimension (:, :) :: M real ( dp ), dimension ( size ( M , 1 ), size ( M , 2 )) :: M_dummy integer :: i , j M_dummy = M do i = 1 , size ( M , 1 ) do j = 1 , size ( M , 1 ) if ( abs ( M ( i , j )) < eps ) M_dummy ( i , j ) = 0.0 write ( * , 100 , advance = 'no' ) M_dummy ( i , j ) enddo write ( * , * ) enddo 100 format ( ES14 . 3 ) end subroutine print_mat function pwl_interp1d ( x , y , q ) !! Piecewise linear 1d interpolation real ( dp ), intent ( in ), dimension (:) :: x , y real ( dp ), intent ( in ) :: q integer :: n , i , idx real ( dp ) :: pwl_interp1d logical , dimension ( size ( x )) :: truthArray n = size ( x ) ! Edge cases if ( isFloatEqual ( x ( 1 ), q )) then pwl_interp1d = y ( 1 ) return elseif ( isFloatEqual ( x ( n ), q )) then pwl_interp1d = y ( n ) return endif if ( x ( 1 ) < x ( n ) ) then ! Ascending truthArray = ( x <= q ) elseif ( x ( 1 ) > x ( n )) then ! Descending truthArray = ( x >= q ) else error stop 'ERROR: Neither ascending nor descending' endif if ( all ( truthArray )) error stop \"ERROR: Out of range (1)\" if ( all (. not . truthArray )) error stop \"ERROR: Out of range (2)\" do i = 1 , n if (. not . truthArray ( i )) then idx = i - 1 exit endif enddo pwl_interp1d = y ( idx ) + ( y ( idx + 1 ) - y ( idx )) / ( x ( idx + 1 ) - x ( idx )) * ( q - x ( idx )) end function pwl_interp1d function interp1d ( xq , x , y , order ) !! 1-d Interpolation using 1st and 2nd order Lagrange polynomials real ( dp ), intent ( in ) :: xq real ( dp ), intent ( in ), dimension (:) :: x , y integer , intent ( in ) :: order real ( dp ) :: interp1d logical , dimension ( size ( x )) :: TFvec integer :: i , ix real ( dp ) :: L0 , L1 , L2 !! Lagrange's basis functions TFVec = ( xq <= x ) do i = 1 , size ( x ) if ( TFvec ( i )) then ix = i exit endif enddo if ( abs ( xq - x ( ix )) <= eps ) then interp1d = y ( ix ) else select case ( order ) case ( 1 ) if ( norm2 ( y ( ix - 1 : ix )) <= eps ) then interp1d = 0._dp else interp1d = y ( ix - 1 ) + ( xq - x ( ix - 1 )) * ( y ( ix ) - y ( ix - 1 )) / ( x ( ix ) - x ( ix - 1 )) endif case ( 2 ) if ( norm2 ( y ( ix - 1 : ix )) <= eps ) then interp1d = 0._dp else if ( size ( x ) == 2 ) then interp1d = y ( ix - 1 ) + ( xq - x ( ix - 1 )) * ( y ( ix ) - y ( ix - 1 )) / ( x ( ix ) - x ( ix - 1 )) elseif ( ix == 2 ) then L0 = ( xq - x ( ix )) * ( xq - x ( ix + 1 )) / (( x ( ix - 1 ) - x ( ix )) * ( x ( ix - 1 ) - x ( ix + 1 ))) L1 = ( xq - x ( ix - 1 )) * ( xq - x ( ix + 1 )) / (( x ( ix ) - x ( ix - 1 )) * ( x ( ix ) - x ( ix + 1 ))) L2 = ( xq - x ( ix - 1 )) * ( xq - x ( ix )) / (( x ( ix + 1 ) - x ( ix - 1 )) * ( x ( ix + 1 ) - x ( ix ))) interp1d = y ( ix - 1 ) * L0 + y ( ix ) * L1 + y ( ix + 1 ) * L2 else L0 = ( xq - x ( ix - 1 )) * ( xq - x ( ix )) / (( x ( ix - 2 ) - x ( ix - 1 )) * ( x ( ix - 2 ) - x ( ix ))) L1 = ( xq - x ( ix - 2 )) * ( xq - x ( ix )) / (( x ( ix - 1 ) - x ( ix - 2 )) * ( x ( ix - 1 ) - x ( ix ))) L2 = ( xq - x ( ix - 2 )) * ( xq - x ( ix - 1 )) / (( x ( ix ) - x ( ix - 2 )) * ( x ( ix ) - x ( ix - 1 ))) interp1d = y ( ix - 2 ) * L0 + y ( ix - 1 ) * L1 + y ( ix ) * L2 endif endif case default error stop \"Specified order not implemented\" end select endif end function interp1d function lsq2_scalar ( xQuery , xData , yData ) !! Linear Least Squares fitting (2nd order) real ( dp ), intent ( in ) :: xQuery real ( dp ), intent ( in ), dimension (:) :: xData , yData real ( dp ), dimension ( 3 ) :: coeff , RHS real ( dp ), dimension ( 3 , 3 ) :: Amat real ( dp ) :: lsq2_scalar if ( size ( xData ) . ne . size ( yData )) error stop 'ERROR: size of xData and yData have to be equal' Amat ( 1 , 1 ) = size ( xData ) Amat ( 1 , 2 ) = sum ( xData ) Amat ( 1 , 3 ) = sum ( xData ** 2._dp ) Amat ( 2 , 1 ) = Amat ( 1 , 2 ) Amat ( 2 , 2 ) = Amat ( 1 , 3 ) Amat ( 2 , 3 ) = sum ( xData ** 3._dp ) Amat ( 3 , 1 ) = Amat ( 1 , 3 ) Amat ( 3 , 2 ) = Amat ( 2 , 3 ) Amat ( 3 , 3 ) = sum ( xData ** 4._dp ) RHS ( 1 ) = sum ( yData ) RHS ( 2 ) = sum ( yData * xData ) RHS ( 3 ) = sum ( yData * xData ** 2._dp ) coeff = matmul ( inv ( Amat ), RHS ) lsq2_scalar = coeff ( 1 ) + coeff ( 2 ) * xQuery + coeff ( 3 ) * xQuery * xQuery end function lsq2_scalar function lsq2_array ( xQuery , xData , yData ) real ( dp ), intent ( in ), dimension (:) :: xQuery real ( dp ), intent ( in ), dimension (:) :: xData , yData real ( dp ), dimension ( 3 ) :: coeff , RHS real ( dp ), dimension ( 3 , 3 ) :: Amat real ( dp ), dimension ( size ( xQuery )) :: lsq2_array integer :: i if ( size ( xData ) . ne . size ( yData )) error stop 'ERROR: size of xData and yData have to be equal' Amat ( 1 , 1 ) = size ( xData ) Amat ( 1 , 2 ) = sum ( xData ) Amat ( 1 , 3 ) = sum ( xData ** 2._dp ) Amat ( 2 , 1 ) = Amat ( 1 , 2 ) Amat ( 2 , 2 ) = Amat ( 1 , 3 ) Amat ( 2 , 3 ) = sum ( xData ** 3._dp ) Amat ( 3 , 1 ) = Amat ( 1 , 3 ) Amat ( 3 , 2 ) = Amat ( 2 , 3 ) Amat ( 3 , 3 ) = sum ( xData ** 4._dp ) RHS ( 1 ) = sum ( yData ) RHS ( 2 ) = sum ( yData * xData ) RHS ( 3 ) = sum ( yData * xData ** 2._dp ) coeff = matmul ( inv ( Amat ), RHS ) do i = 1 , size ( xQuery ) lsq2_array ( i ) = coeff ( 1 ) + coeff ( 2 ) * xQuery ( i ) + coeff ( 3 ) * xQuery ( i ) * xQuery ( i ) enddo end function lsq2_array !--------------------------------------------------------! !--------------------------------------------------------! ! Code to generate Transformation matrices in Octave ! ! clc; clear; ! pkg load symbolic; ! syms p t s ! Rp=[[1,0,0];[0,cos(p),sin(p)];[0,-sin(p),cos(p)]]; ! Rt=[[cos(t),0,-sin(t)];[0,1,0];[sin(t),0,cos(t)]]; ! Rs=[[cos(s),sin(s),0];[-sin(s),cos(s),0];[0,0,1]]; ! Tbg=Rp*Rt*Rs ! Tgb=Rs'*Rt'*Rp' function Tbg ( cs_phi , cs_theta , cs_psi ) !! Transformation matrix (body to global frame) real ( dp ), dimension ( 2 ), intent ( in ) :: cs_phi !! cos(phi), sin(phi) real ( dp ), dimension ( 2 ), intent ( in ) :: cs_theta !! cos(theta), sin(theta) real ( dp ), dimension ( 2 ), intent ( in ) :: cs_psi !! cos(psi), sin(psi) real ( dp ), dimension ( 3 , 3 ) :: Tbg !! 3x3 transformation matrix Tbg ( 1 , :) = [ cs_psi ( 1 ) * cs_theta ( 1 ), cs_theta ( 1 ) * cs_psi ( 2 ), - 1._dp * cs_theta ( 2 )] Tbg ( 2 , 1 ) = cs_psi ( 1 ) * cs_phi ( 2 ) * cs_theta ( 2 ) - cs_phi ( 1 ) * cs_psi ( 2 ) Tbg ( 2 , 2 ) = cs_phi ( 1 ) * cs_psi ( 1 ) + cs_phi ( 2 ) * cs_psi ( 2 ) * cs_theta ( 2 ) Tbg ( 2 , 3 ) = cs_theta ( 1 ) * cs_phi ( 2 ) Tbg ( 3 , 1 ) = cs_phi ( 1 ) * cs_psi ( 1 ) * cs_theta ( 2 ) + cs_phi ( 2 ) * cs_psi ( 2 ) Tbg ( 3 , 2 ) = cs_phi ( 1 ) * cs_psi ( 2 ) * cs_theta ( 2 ) - cs_psi ( 1 ) * cs_phi ( 2 ) Tbg ( 3 , 3 ) = cs_phi ( 1 ) * cs_theta ( 1 ) end function Tbg function Tgb ( cs_phi , cs_theta , cs_psi ) !! Transformation matrix (global to body frame) real ( dp ), dimension ( 2 ), intent ( in ) :: cs_phi !! cos(phi), sin(phi) real ( dp ), dimension ( 2 ), intent ( in ) :: cs_theta !! cos(theta), sin(theta) real ( dp ), dimension ( 2 ), intent ( in ) :: cs_psi !! cos(psi), sin(psi) real ( dp ), dimension ( 3 , 3 ) :: Tgb !! 3x3 transformation matrix Tgb ( 1 , 1 ) = cs_psi ( 1 ) * cs_theta ( 1 ) Tgb ( 1 , 2 ) = cs_phi ( 2 ) * cs_theta ( 2 ) * cs_psi ( 1 ) - cs_psi ( 2 ) * cs_phi ( 1 ) Tgb ( 1 , 3 ) = cs_phi ( 2 ) * cs_psi ( 2 ) + cs_theta ( 2 ) * cs_phi ( 1 ) * cs_psi ( 1 ) Tgb ( 2 , 1 ) = cs_psi ( 2 ) * cs_theta ( 1 ) Tgb ( 2 , 2 ) = cs_phi ( 2 ) * cs_psi ( 2 ) * cs_theta ( 2 ) + cs_phi ( 1 ) * cs_psi ( 1 ) Tgb ( 2 , 3 ) = cs_psi ( 2 ) * cs_theta ( 2 ) * cs_phi ( 1 ) - cs_phi ( 2 ) * cs_psi ( 1 ) Tgb ( 3 , 1 ) = - cs_theta ( 2 ) Tgb ( 3 , 2 ) = cs_phi ( 2 ) * cs_theta ( 1 ) Tgb ( 3 , 3 ) = cs_phi ( 1 ) * cs_theta ( 1 ) end function Tgb function getTransformAxis ( theta , axisVec ) result ( TMat ) !! Transformation matrix for theta angular rotation about a 3d axis real ( dp ), intent ( in ) :: theta !! theta angle in radians real ( dp ), dimension ( 3 ), intent ( in ) :: axisVec !! 3d axis vector real ( dp ), dimension ( 3 , 3 ) :: TMat !! 3x3 transformation matrix real ( dp ), dimension ( 3 ) :: axis real ( dp ) :: ct , st , omct ! Ensure axis is normalized axis = axisVec / norm2 ( axisVec ) ! Calculate TMat ct = cos ( theta ) st = sin ( theta ) omct = 1._dp - ct Tmat (:, 1 ) = [ ct + axis ( 1 ) * axis ( 1 ) * omct , & & axis ( 3 ) * st + axis ( 2 ) * axis ( 1 ) * omct , & & - axis ( 2 ) * st + axis ( 3 ) * axis ( 1 ) * omct ] Tmat (:, 2 ) = [ - axis ( 3 ) * st + axis ( 1 ) * axis ( 2 ) * omct , & & ct + axis ( 2 ) * axis ( 2 ) * omct , & & axis ( 1 ) * st + axis ( 3 ) * axis ( 2 ) * omct ] Tmat (:, 3 ) = [ axis ( 2 ) * st + axis ( 1 ) * axis ( 3 ) * omct , & & - axis ( 1 ) * st + axis ( 2 ) * axis ( 3 ) * omct , & & ct + axis ( 3 ) * axis ( 3 ) * omct ] end function getTransformAxis function trapz ( y , x ) !! Trapezoid integration with unequal intervals real ( dp ) :: trapz real ( dp ), intent ( in ), dimension (:) :: x , y integer :: i if ( size ( x ) . ne . size ( y )) then error stop 'ERROR: Sizes of vectors do not match' endif trapz = 0._dp do i = 2 , size ( x ) trapz = trapz + ( x ( i ) - x ( i - 1 )) * ( y ( i ) + y ( i - 1 )) enddo trapz = 0.5_dp * trapz end function trapz end module libMath","tags":"","loc":"sourcefile/libmath.f90.html"},{"title":"libC81.f90 – VOLCANOR","text":"Module definition for libC81 Contents Modules libC81 Source Code libC81.f90 Source Code !! Module definition for libC81 module libC81 !! Procedures to manipulate C81 files and data structure implicit none integer , parameter , private :: dp = kind ( 1.d0 ) !! Double precision setting type C81_class !! Base class for C81 performance data character ( len = 30 ) :: airfoilName !! Airfoil name in C81 file integer :: ML !! No. of lift coefficient machs integer :: NL !! No. of lift coefficient alphas integer :: MD !! No. of drag coefficient machs integer :: ND !! No. of drag coefficient alphas integer :: MM !! No. of moment coefficient machs integer :: NM !! No. of moment coefficient alphas real ( dp ), allocatable , dimension (:) :: MaL !! Machs for lift real ( dp ), allocatable , dimension (:) :: MaD !! Machs for drag real ( dp ), allocatable , dimension (:) :: MaM !! Machs for moment real ( dp ), allocatable , dimension (:) :: AL !! Alphas for lift real ( dp ), allocatable , dimension (:) :: AD !! Alphas for drag real ( dp ), allocatable , dimension (:) :: AM !! Alphas for moment real ( dp ), allocatable , dimension (:,:) :: CL !! Lift coefficient real ( dp ), allocatable , dimension (:,:) :: CD !! Drag coefficient real ( dp ), allocatable , dimension (:,:) :: CM !! Moment coefficient contains procedure :: writefile procedure :: readfile procedure :: getCL procedure :: getCD procedure :: getCM end type C81_class private :: getBilinearInterp private :: getInterval private :: getTable contains subroutine writefile ( this , C81filename ) !! Writes C81 class data to C81 file class ( C81_class ) :: this character ( len =* ), intent ( in ) :: C81filename integer :: i , j logical :: fileExists character ( len = 10 ) :: formatChar character ( len = 1 ) :: overwriteOption inquire ( file = C81filename , exist = fileExists ) if ( fileExists ) then print * , 'File ' // trim ( C81filename ) // ' already exists!' write ( * , '(A)' , advance = 'no' ) ' Okay to overwrite (y/n)? ' read ( * , * ) overwriteOption print * if (( overwriteOption . ne . 'y' ) . and . ( overwriteOption . ne . 'Y' )) stop endif open ( unit = 10 , file = C81filename , action = 'write' ) this % ML = size ( this % MaL , 1 ) this % MD = size ( this % MaD , 1 ) this % MM = size ( this % MaM , 1 ) this % NL = size ( this % AL , 1 ) this % ND = size ( this % AD , 1 ) this % NM = size ( this % AM , 1 ) write ( 10 , 100 ) this % airfoilName , this % ML , this % NL , this % MD , this % ND , this % MM , this % NM ! Lift write ( 10 , 101 ) ( this % MaL ( i ), i = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % ML - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaL ( i ), i = 10 , this % ML ) endif do i = 1 , this % NL write ( 10 , 102 ) this % AL ( i ), ( this % CL ( i , j ), j = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) write ( 10 , formatChar ) ( this % CL ( i , j ), j = 10 , this % ML ) enddo ! Drag write ( 10 , 101 ) ( this % MaD ( i ), i = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MD - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaD ( i ), i = 10 , this % MD ) endif do i = 1 , this % ND write ( 10 , 102 ) this % AD ( i ), ( this % CD ( i , j ), j = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) write ( 10 , formatChar ) ( this % CD ( i , j ), j = 10 , this % MD ) enddo ! Moment write ( 10 , 101 ) ( this % MaM ( i ), i = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MM - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaM ( i ), i = 10 , this % MM ) endif do i = 1 , this % NM write ( 10 , 102 ) this % AM ( i ), ( this % CM ( i , j ), j = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) write ( 10 , formatChar ) ( this % CM ( i , j ), j = 10 , this % MM ) enddo close ( 10 ) 100 format ( A30 , 6 I0 . 2 ) 101 format ( 7 X , 9 F7 . 3 ) 102 format ( F7 . 2 , 9 F7 . 3 ) end subroutine writefile subroutine readfile ( this , C81filename ) !! Reads from C81 file to C81 class class ( C81_class ) :: this character ( len =* ), intent ( in ) :: C81filename integer :: i , j integer :: stat character ( len = 10 ) :: formatChar open ( unit = 10 , file = C81filename , status = 'old' , action = 'read' , iostat = stat ) if ( stat > 0 ) error stop 'ERROR: File not found' read ( 10 , 100 ) this % airfoilName , this % ML , this % NL , this % MD , this % ND , this % MM , this % NM allocate ( this % MaL ( this % ML )) allocate ( this % MaD ( this % MD )) allocate ( this % MaM ( this % MM )) allocate ( this % AL ( this % NL )) allocate ( this % AD ( this % ND )) allocate ( this % AM ( this % NM )) allocate ( this % CL ( this % NL , this % ML )) allocate ( this % CD ( this % ND , this % MD )) allocate ( this % CM ( this % NM , this % MM )) ! Lift read ( 10 , 101 ) ( this % MaL ( i ), i = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % ML - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaL ( i ), i = 10 , this % ML ) endif do i = 1 , this % NL read ( 10 , 102 ) this % AL ( i ), ( this % CL ( i , j ), j = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) read ( 10 , formatChar ) ( this % CL ( i , j ), j = 10 , this % ML ) enddo ! Drag read ( 10 , 101 ) ( this % MaD ( i ), i = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MD - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaD ( i ), i = 10 , this % MD ) endif do i = 1 , this % ND read ( 10 , 102 ) this % AD ( i ), ( this % CD ( i , j ), j = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) read ( 10 , formatChar ) ( this % CD ( i , j ), j = 10 , this % MD ) enddo ! Moment read ( 10 , 101 ) ( this % MaM ( i ), i = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MM - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaM ( i ), i = 10 , this % MM ) endif do i = 1 , this % NM read ( 10 , 102 ) this % AM ( i ), ( this % CM ( i , j ), j = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) read ( 10 , formatChar ) ( this % CM ( i , j ), j = 10 , this % MM ) enddo close ( 10 ) 100 format ( A30 , 6 I2 ) 101 format ( 7 X , 9 F7 . 0 ) 102 format ( 10 F7 . 0 ) end subroutine readfile function getCL ( this , alphaQuery , machQuery ) !! Returns value of 2-d linear interpolated CL !! for a given alphaQuery and machQuery values class ( C81_class ) :: this real ( dp ), intent ( in ) :: alphaQuery , machQuery real ( dp ) :: getCL integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AL , alphaQuery ) machIndx = getInterval ( this % MaL , machQuery ) if ( alphaIndx ( 1 ) . eq . alphaIndx ( 2 )) then if ( machIndx ( 1 ) . eq . machIndx ( 2 )) then getCL = this % CL ( alphaIndx ( 1 ), machIndx ( 1 )) else getCL = this % CL ( alphaIndx ( 1 ), machIndx ( 1 )) + & ( machQuery - this % MaL ( machIndx ( 1 ))) * & ( this % CL ( alphaIndx ( 1 ), machIndx ( 2 )) - this % CL ( alphaIndx ( 1 ), machIndx ( 1 ))) / & ( this % MaL ( machIndx ( 2 )) - this % MaL ( machIndx ( 1 ))) endif elseif ( machIndx ( 1 ) . eq . machIndx ( 2 )) then getCL = this % CL ( alphaIndx ( 1 ), machIndx ( 1 )) + & ( alphaQuery - this % AL ( alphaIndx ( 1 ))) * & ( this % CL ( alphaIndx ( 2 ), machIndx ( 1 )) - this % CL ( alphaIndx ( 1 ), machIndx ( 1 ))) / & ( this % AL ( alphaIndx ( 2 )) - this % AL ( alphaIndx ( 1 ))) else getCL = getBilinearInterp ( alphaQuery , machQuery , & [ this % AL ( alphaIndx ( 1 )), this % AL ( alphaIndx ( 2 ))], & [ this % MaL ( machIndx ( 1 )), this % MaL ( machIndx ( 2 ))], & this % CL ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CL ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CL ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CL ( alphaIndx ( 2 ), machIndx ( 2 ))) endif end function getCL function getCD ( this , alphaQuery , machQuery ) !! Returns value of 2-d linearly interpolated CD !! for given alphaQuery and machQuery values class ( C81_class ) :: this real ( dp ), intent ( in ) :: alphaQuery , machQuery real ( dp ) :: getCD integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AD , alphaQuery ) machIndx = getInterval ( this % MaD , machQuery ) if ( alphaIndx ( 1 ) . eq . alphaIndx ( 2 )) then if ( machIndx ( 1 ) . eq . machIndx ( 2 )) then getCD = this % CD ( alphaIndx ( 1 ), machIndx ( 1 )) else getCD = this % CD ( alphaIndx ( 1 ), machIndx ( 1 )) + & ( machQuery - this % MaD ( machIndx ( 1 ))) * & ( this % CD ( alphaIndx ( 1 ), machIndx ( 2 )) - & this % CD ( alphaIndx ( 1 ), machIndx ( 1 ))) / & ( this % MaD ( machIndx ( 2 )) - this % MaD ( machIndx ( 1 ))) endif elseif ( machIndx ( 1 ) . eq . machIndx ( 2 )) then getCD = this % CD ( alphaIndx ( 1 ), machIndx ( 1 )) + & ( alphaQuery - this % AD ( alphaIndx ( 1 ))) * & ( this % CD ( alphaIndx ( 2 ), machIndx ( 1 )) - & this % CD ( alphaIndx ( 1 ), machIndx ( 1 ))) / & ( this % AD ( alphaIndx ( 2 )) - this % AD ( alphaIndx ( 1 ))) else getCD = getBilinearInterp ( alphaQuery , machQuery , & [ this % AD ( alphaIndx ( 1 )), this % AD ( alphaIndx ( 2 ))], & [ this % MaD ( machIndx ( 1 )), this % MaD ( machIndx ( 2 ))], & this % CD ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CD ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CD ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CD ( alphaIndx ( 2 ), machIndx ( 2 ))) endif end function getCD function getCM ( this , alphaQuery , machQuery ) !! Returns value of 2-d linearly interpolated CM !! for given alphaQuery and machQuery values class ( C81_class ) :: this real ( dp ), intent ( in ) :: alphaQuery , machQuery real ( dp ) :: getCM integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AM , alphaQuery ) machIndx = getInterval ( this % MaM , machQuery ) if ( alphaIndx ( 1 ) . eq . alphaIndx ( 2 )) then if ( machIndx ( 1 ) . eq . machIndx ( 2 )) then getCM = this % CM ( alphaIndx ( 1 ), machIndx ( 1 )) else getCM = this % CM ( alphaIndx ( 1 ), machIndx ( 1 )) + & ( machQuery - this % MaM ( machIndx ( 1 ))) * & ( this % CM ( alphaIndx ( 1 ), machIndx ( 2 )) - & this % CM ( alphaIndx ( 1 ), machIndx ( 1 ))) / & ( this % MaM ( machIndx ( 2 )) - this % MaM ( machIndx ( 1 ))) endif elseif ( machIndx ( 1 ) . eq . machIndx ( 2 )) then getCM = this % CM ( alphaIndx ( 1 ), machIndx ( 1 )) + & ( alphaQuery - this % AM ( alphaIndx ( 1 ))) * & ( this % CM ( alphaIndx ( 2 ), machIndx ( 1 )) - & this % CM ( alphaIndx ( 1 ), machIndx ( 1 ))) / & ( this % AM ( alphaIndx ( 2 )) - this % AM ( alphaIndx ( 1 ))) else getCM = getBilinearInterp ( alphaQuery , machQuery , & [ this % AM ( alphaIndx ( 1 )), this % AM ( alphaIndx ( 2 ))], & [ this % MaM ( machIndx ( 1 )), this % MaM ( machIndx ( 2 ))], & this % CM ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CM ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CM ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CM ( alphaIndx ( 2 ), machIndx ( 2 ))) endif end function getCM function getInterval ( A , x ) result ( indx ) !! Return interval of a vector A in which x lies inside real ( dp ), intent ( in ), dimension (:) :: A real ( dp ), intent ( in ) :: x integer , dimension ( 2 ) :: indx ! Left and right indices integer :: n , i n = size ( A , 1 ) indx ( 1 ) = 1 indx ( 2 ) = n ! Binary search algorithm do while (( indx ( 1 ) . ne . indx ( 2 )) . and . ( indx ( 2 ) . ne . ( indx ( 1 ) + 1 ))) i = floor (( indx ( 1 ) + indx ( 2 )) * 0.5 ) if ( x < A ( i )) then indx ( 2 ) = i elseif ( x > A ( i )) then indx ( 1 ) = i else indx ( 1 ) = i indx ( 2 ) = i endif enddo ! Check end cases if ( abs ( A ( indx ( 1 )) - x ) . le . epsilon ( 1. )) then indx ( 2 ) = indx ( 1 ) elseif ( abs ( A ( indx ( 2 )) - x ) . le . epsilon ( 1. )) then indx ( 1 ) = indx ( 2 ) endif end function getInterval function getBilinearInterp ( x , y , xvec , yvec , f11 , f12 , f21 , f22 ) !! Returns bilinearly interpolated values at (x,y) real ( dp ), intent ( in ) :: x !! Queried x real ( dp ), intent ( in ) :: y !! Queried y real ( dp ), intent ( in ), dimension ( 2 ) :: xvec real ( dp ), intent ( in ), dimension ( 2 ) :: yvec real ( dp ), intent ( in ) :: f11 , f12 , f21 , f22 real ( dp ) :: getBilinearInterp real ( dp ), dimension ( 2 , 2 ) :: fMat fMat ( 1 ,:) = [ f11 , f12 ] fMat ( 2 ,:) = [ f21 , f22 ] getBilinearInterp = dot_product ([ xvec ( 2 ) - x , x - xvec ( 1 )], & & matmul ( fMat ,( / yvec ( 2 ) - y , y - yvec ( 1 ) / ))) getBilinearInterp = getBilinearInterp / ( xvec ( 2 ) - xvec ( 1 )) / ( yvec ( 2 ) - yvec ( 1 )) end function getBilinearInterp function getTable ( filename , rows , cols ) !! Returns data from csv formatted file character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: rows !! No. of rows integer , intent ( in ) :: cols !! No. of columns integer :: i , j integer :: stat real ( dp ), dimension ( rows , cols ) :: getTable open ( unit = 10 , file = filename , status = 'old' , action = 'read' , iostat = stat ) if ( stat > 0 ) then print * , 'ERROR: ' // trim ( filename ) // ' file not found' error stop endif do i = 1 , rows read ( 10 , * ) ( getTable ( i , j ), j = 1 , cols ) enddo close ( 10 ) end function getTable end module libC81","tags":"","loc":"sourcefile/libc81.f90.html"},{"title":"classdef.f90 – VOLCANOR","text":"Module definition for various objects that are used Contents Modules classdef Source Code classdef.f90 Source Code !! Module definition for various objects that are used module classdef !! Class and procedures for the various objects use libMath , only : dp , pi , eps , degToRad , radToDeg use libC81 , only : C81_class implicit none real ( dp ), parameter :: tol = 1.E-6 !! Tolerance for use in unit tests real ( dp ), parameter , private :: invTol2 = 1.E06 real ( dp ), parameter , private :: inv4pi = 0.25_dp / pi real ( dp ), parameter , private :: twoPi = 2.0_dp * pi type switches_class !! Switches that determine solver options integer :: ntSub !! No. of timesteps for sub-iterations [+/-n] integer :: ntSubInit !! No. of timesteps for initial sub-iterations [+/-n] integer :: wakeDissipation !! Wake dissipation [0, 1] integer :: wakeStrain !! Wake strain [0, 1] integer :: wakeBurst !! Wake burst on exceeding skew value [0, 1] integer :: wakeSuppress !! Suppress wake (for testing and non-lifting surfaces) [0, 1] integer :: slowStart !! Slow start to avoid large starting vortex [0, 1] integer :: slowStartNt !! Slow start to avoid large starting vortex [+/-n] integer :: wakeTipPlot !! Plot wake tip every nth timestep [+/-n] integer :: wakePlot !! Plot full wake every nth timestep [+/-n] integer :: gridPlot !! Record vortices for field computation every nth timestep [+/-n] integer :: rotorForcePlot !! Plot rotor forces every nth timestep [+/-n] integer :: fdScheme !! Choose finite-difference scheme [0,1,...,5] integer :: probe !! Use probes for recording velocity [0,1] integer :: nProbes !! No. of probes [n] integer :: initWakeVelNt !! Use initial velocity for convecting away starting vortex [0, 1] integer :: restartFromNt !! Restart from nth timestep [n] integer :: restartWriteNt !! Write restart files every nth timestep for restarting later [n] end type switches_class type vf_class !! Vortex filament class real ( dp ), dimension ( 3 , 2 ) :: fc !! Filament coords (xyz, 1:2) real ( dp ) :: l0 = 0._dp !! Original length real ( dp ) :: lc = 0._dp !! Current length real ( dp ) :: rVc0 = 0._dp !! Initial vortex core radius real ( dp ) :: rVc = 0._dp !! Current vortex core radius real ( dp ) :: age = 0._dp !! Vortex age (in seconds) real ( dp ) :: ageAzimuthal = 0._dp !! vortex age (in radians) contains procedure :: vind => vf_vind procedure :: calclength => vf_calclength procedure :: strain => vf_strain end type vf_class type vr_class !! Vortex ring class type ( vf_class ), dimension ( 4 ) :: vf real ( dp ) :: gam !! Circulation real ( dp ) :: skew !! Skew parameter contains procedure :: vind => vr_vind procedure :: vindSource => vr_vindSource procedure :: assignP => vr_assignP procedure :: shiftdP => vr_shiftdP procedure :: rot => vr_rot procedure :: calclength => vr_calclength procedure :: strain => vr_strain procedure :: decay => vr_decay procedure :: calc_skew => calc_skew procedure :: burst => vr_burst procedure , private :: getInteriorAngles => vr_getInteriorAngles procedure , private :: getMedianAngle => vr_getMedianAngle procedure , private :: getBimedianCos => vr_getBimedianCos procedure :: mirror => vr_mirror end type vr_class type wingpanel_class !! Wing panel class ! Panel coordinates ! o-------> Y along span ! | ! |   1-------4  - Leading edge ! |   |   4   | ! |   |1     3| ! |   |   2   | ! |   2-------3  - Trailing edge ! | ! V X along chord type ( vr_class ) :: vr real ( dp ) :: gamPrev !! Circulation at previous timestep real ( dp ) :: gamTrapz !! Circulation after trapezoidal integration real ( dp ), dimension ( 3 , 4 ) :: PC !! Panel coords (xyz, 1:4) real ( dp ), dimension ( 3 ) :: CP !! Collocation point coords real ( dp ), dimension ( 3 ) :: nCap !! Unit normal vector real ( dp ), dimension ( 3 ) :: tauCapChord !! Unit tangential vector along chord real ( dp ), dimension ( 3 ) :: tauCapSpan !! Unit tangential vector along span real ( dp ), dimension ( 3 ) :: velCP !! Local vel at CP excluding wing vortices real ( dp ), dimension ( 3 ) :: velCPTotal !! Local vel at CP including wing vortices real ( dp ), dimension ( 3 ) :: velCPm !! Local vel at CP due to wing motion real ( dp ), dimension ( 3 ) :: normalForce !! Normal force vector (inertial frame) real ( dp ), dimension ( 3 ) :: normalForceUnsteady !! Unsteady part of normal force vector (inertial frame) real ( dp ), dimension ( 3 ) :: chordwiseResVel !! Chordwise resultant velocity vector real ( dp ) :: velPitch !! Airfoil pitch velocity about rHinge real ( dp ) :: delP !! Pressure difference between upper and lower surfaces at panel real ( dp ) :: delPUnsteady !! Unsteady pressure at panel real ( dp ) :: delDiConstant !! Induced drag (constant part) at panel real ( dp ) :: delDiUnsteady !! Induced drag (unsteady part) at panel real ( dp ) :: meanChord !! Panel mean chord real ( dp ) :: meanSpan !! Panel mean span real ( dp ) :: panelArea !! Panel area for computing lift real ( dp ) :: rHinge !! Dist to point about which airfoil pitching occurs (LE of wing) real ( dp ) :: alpha !! Local angle of attack (in radians) contains procedure :: assignP => wingpanel_assignP procedure :: calcCP => wingpanel_calcCP procedure :: calcN => wingpanel_calcN procedure :: invertNcap => wingpanel_invertNcap procedure :: calcTau => wingpanel_calcTau procedure :: rot => wingpanel_rot procedure :: shiftdP => wingpanel_shiftdP procedure :: calc_chordwiseResVel => wingpanel_calc_chordwiseResVel procedure :: calc_area => wingpanel_calc_area procedure :: calc_mean_dimensions => wingpanel_calc_mean_dimensions procedure :: isCPinsidecore => wingpanel_isCPinsidecore end type wingpanel_class type Nwake_class !! Near wake class ! VR coordinates ! o-------> Y along span ! | ! |   1-------4 ! |   |   4   | ! |   |1     3| ! |   |   2   | ! |   2-------3 ! | ! V X along chord type ( vr_class ) :: vr end type Nwake_class type Fwake_class !! Far wake class ! VF coordinates ! o-------> Y along span ! | ! |   2 - Leading edge ! |   | ! |   |1 ! |   | ! |   1 - Trailing edge ! | ! V X along chord type ( vf_class ) :: vf real ( dp ) :: gam = 0._dp !! Circulation contains procedure :: shiftdP => Fwake_shiftdP procedure :: assignP => Fwake_assignP procedure :: rot => Fwake_rot procedure :: decay => Fwake_decay procedure :: mirror => Fwake_mirror end type Fwake_class type pFwake_class !! Prescribed far wake ! 10 revs with 15 deg vortex filaments type ( Fwake_class ), dimension ( 240 ) :: waF real ( dp ), dimension ( 3 , 241 ) :: coords real ( dp ) :: nRevs = 1 0.0 real ( dp ) :: helixPitch = 0._dp real ( dp ) :: helixRadius = 0._dp real ( dp ) :: relaxFactor = 0.5_dp logical :: isClockwiseRotor = . True . logical :: isPresent = . false . contains procedure :: update => pFwake_update procedure :: rot_wake_axis => pFwake_rot_wake_axis end type pFwake_class type blade_class !! Single blade class !    _____________________       Y ! O o---------------------|------> !   |________BLADE________| !   | !   | ! X V ! character ( len = 2 ) :: id type ( wingpanel_class ), allocatable , dimension (:, :) :: wiP !! Wing panel type ( Nwake_class ), allocatable , dimension (:, :) :: waN !! Near wake type ( Fwake_class ), allocatable , dimension (:) :: waF !! Far wake type ( pFwake_class ) :: wapF !! Prescribed far wake type ( pFwake_class ) :: wapFPredicted !! Prescribed far wake type ( Nwake_class ), allocatable , dimension (:, :) :: waNPredicted type ( Fwake_class ), allocatable , dimension (:) :: waFPredicted type ( C81_class ), allocatable , dimension (:) :: C81 integer :: nc !! No. of chordwise panels integer :: ns !! No. of spanwise panels real ( dp ) :: theta , psi real ( dp ) :: pivotLE !! Location of pivot from LE (x/c) for setting pitch angle real ( dp ) :: preconeAngle !! Precone angle for blade real ( dp ) :: velWakeMax !! Max vel on wake collocation points for preventing blowup ! Flap dynamics parameters real ( dp ) :: flapInitial , dflapInitial , flapPrev , dflapPrev real ( dp ) :: flap , dflap , Iflap , kflap , cflap , MflapConstant real ( dp ) :: MflapLift , MflapLiftPrev real ( dp ), dimension ( 3 ) :: flapOrigin real ( dp ), dimension ( 3 ) :: forceInertial real ( dp ), dimension ( 3 ) :: lift , drag real ( dp ), dimension ( 3 ) :: dragInduced , dragProfile real ( dp ), dimension ( 3 ) :: liftUnsteady , dragUnsteady integer , allocatable , dimension (:) :: airfoilNo character ( len = 30 ), allocatable , dimension (:) :: airfoilFile real ( dp ), allocatable , dimension (:) :: airfoilSectionLimit real ( dp ), allocatable , dimension (:, :, :) :: velNwake , velNwake1 real ( dp ), allocatable , dimension (:, :, :) :: velNwake2 , velNwake3 real ( dp ), allocatable , dimension (:, :, :) :: velNwakePredicted real ( dp ), allocatable , dimension (:, :, :) :: velNwakeStep real ( dp ), allocatable , dimension (:, :) :: velFwake , velFwake1 real ( dp ), allocatable , dimension (:, :) :: velFwake2 , velFwake3 real ( dp ), allocatable , dimension (:, :) :: velFwakePredicted real ( dp ), allocatable , dimension (:, :) :: velFwakeStep integer :: stlNodesCols ! Cols of stlNodes array real ( dp ), allocatable , dimension (:, :) :: stlNodes ! (3, stlNodesCols) ! 3 Vertices of each element in stlElementNodes integer , allocatable , dimension (:, :) :: stlElementNodes real ( dp ), dimension ( 3 ) :: xAxis , yAxis , zAxis real ( dp ), dimension ( 3 ) :: xAxisAzi , yAxisAzi , zAxisAzi real ( dp ), dimension ( 3 ) :: xAxisAziFlap , yAxisAziFlap , zAxisAziFlap ! Sectional quantities real ( dp ), allocatable , dimension (:) :: secChord , secArea real ( dp ), allocatable , dimension (:, :) :: secForceInertial real ( dp ), allocatable , dimension (:, :) :: secLift , secDrag real ( dp ), allocatable , dimension (:, :) :: secLiftDir , secDragDir real ( dp ), allocatable , dimension (:, :) :: secLiftInPlane , secLiftOutPlane real ( dp ), allocatable , dimension (:, :) :: secDragInduced , secDragProfile real ( dp ), allocatable , dimension (:, :) :: secLiftUnsteady , secDragUnsteady real ( dp ), allocatable , dimension (:, :) :: secLiftInPlaneUnsteady real ( dp ), allocatable , dimension (:, :) :: secLiftOutPlaneUnsteady real ( dp ), allocatable , dimension (:, :) :: secTauCapChord , secTauCapSpan real ( dp ), allocatable , dimension (:, :) :: secNormalVec , secCP real ( dp ), allocatable , dimension (:, :) :: secChordwiseResVel real ( dp ), allocatable , dimension (:) :: secAlpha , secPhi , secTheta real ( dp ), allocatable , dimension (:) :: secViz , secVix real ( dp ), allocatable , dimension (:) :: secCD , secCM , secMflap , secMflapArm real ( dp ), allocatable , dimension (:) :: alpha0 , secCL , secCLu integer :: spanwiseLiftSwitch contains procedure :: move => blade_move procedure :: rotate => blade_rotate procedure :: rot_pitch => blade_rot_pitch procedure :: rot_wake_axis => blade_rot_wake_axis procedure :: rot_pts => blade_rot_pts procedure :: rot_flap => blade_rot_flap procedure :: vind_bywing => blade_vind_bywing procedure :: vindSource_bywing => blade_vindSource_bywing procedure :: vind_bywing_boundVortices => blade_vind_bywing_boundVortices procedure :: vind_bywing_chordwiseVortices => & & blade_vind_bywing_chordwiseVortices procedure :: vind_boundVortex => blade_vind_boundVortex procedure :: vind_bywake => blade_vind_bywake procedure :: convectwake => blade_convectwake procedure :: limitWakeVel => blade_limitWakeVel procedure , private :: wake_continuity => blade_wake_continuity procedure , private :: getSecDynamicPressure => blade_getSecDynamicPressure procedure :: calc_secArea , calc_secChord procedure :: calc_force => blade_calc_force ! procedure :: calc_force_gamma => blade_calc_force_gamma procedure :: calc_force_alpha => blade_calc_force_alpha procedure :: calc_force_alphaGamma => blade_calc_force_alphaGamma procedure :: calc_secAlpha => blade_calc_secAlpha procedure :: calc_secChordwiseResVel => blade_calc_secChordwiseResVel procedure :: burst_wake => blade_burst_wake procedure :: calc_skew => blade_calc_skew procedure :: calc_secLocations => blade_calc_secLocations procedure :: lookup_secCoeffs => blade_lookup_secCoeffs procedure :: secCoeffsToSecForces => blade_secCoeffsTosecForces procedure :: dirLiftDrag => blade_dirLiftDrag procedure :: sumSecToNetForces => blade_sumSecToNetForces procedure :: calc_stlStats => blade_calc_stlStats procedure :: computeBladeDynamics => blade_computeBladeDynamics procedure :: getddflap ! I/O subroutines procedure :: blade_write generic :: write ( unformatted ) => blade_write procedure :: blade_read generic :: read ( unformatted ) => blade_read end type blade_class type rotor_class !! Rotor class character ( len = 2 ) :: id integer :: nb , ns , nc , nNwake , nFwake , nbConvect , nNwakeEnd , nFwakeEnd type ( blade_class ), allocatable , dimension (:) :: blade real ( dp ) :: Omega , omegaSlow real ( dp ), dimension ( 3 ) :: shaftAxis real ( dp ), dimension ( 3 ) :: xAxisBody , yAxisBody , zAxisBody real ( dp ), dimension ( 3 ) :: hubCoords , cgCoords , fromCoords real ( dp ) :: radius , chord , root_cut real ( dp ) :: preconeAngle , dpitch real ( dp ) :: flapInitial , dflapInitial , Iflap , cflap , kflap , MflapConstant real ( dp ), dimension ( 3 ) :: forceInertial , lift , liftPrev , drag real ( dp ), dimension ( 3 ) :: dragInduced , dragProfile real ( dp ), dimension ( 3 ) :: liftUnsteady , dragUnsteady real ( dp ), dimension ( 3 ) :: liftUnitVec , dragUnitVec , sideUnitVec real ( dp ), dimension ( 3 ) :: controlPitch ! theta0,thetaC,thetaS real ( dp ) :: thetaTwist real ( dp ) :: pivotLE ! pivot location from LE [x/c] real ( dp ) :: flapHinge ! hinge location from centre [x/R] real ( dp ), dimension ( 3 ) :: velBody , omegaBody real ( dp ), dimension ( 3 ) :: velBodyPrev , omegaBodyPrev real ( dp ), allocatable , dimension (:, :) :: velBodyHistory real ( dp ), allocatable , dimension (:, :) :: omegaBodyHistory real ( dp ) :: psi real ( dp ), dimension ( 3 ) :: pts ! phi,theta,psi about cgCoords character ( len = 1 ) :: streamwiseCoreSwitch real ( dp ) :: spanwiseCore real ( dp ), allocatable , dimension (:) :: streamwiseCoreVec real ( dp ), allocatable , dimension (:, :) :: AIC , AIC_inv real ( dp ), allocatable , dimension (:) :: gamVec , gamVecPrev , RHS real ( dp ), allocatable , dimension (:) :: camberSectionLimit real ( dp ), allocatable , dimension (:) :: airfoilSectionLimit real ( dp ), allocatable , dimension (:) :: alpha0 real ( dp ) :: initWakeVel , psiStart , skewLimit real ( dp ) :: apparentViscCoeff , decayCoeff real ( dp ) :: rollupStartRadius , rollupEndRadius integer :: propConvention , spanSpacing , chordSpacing integer :: overrideTauSpan , symmetricTau integer :: wakeTruncateNt integer :: prescWakeNt , prescWakeAfterTruncNt , prescWakeGenNt integer :: rollupStart , rollupEnd integer :: suppressFwakeSwitch integer :: forceCalcSwitch , skewPlotSwitch integer :: inflowPlotSwitch , bladeDynamicsSwitch , pitchDynamicsSwitch integer :: bodyDynamicsSwitch , bodyDynamicsIOVars integer :: spanwiseLiftSwitch , customTrajectorySwitch integer :: gammaPlotSwitch integer :: rowNear , rowFar integer :: nCamberFiles , nAirfoils integer :: imagePlane , imageRotorNum integer :: surfaceType integer :: axisymmetrySwitch character ( len = 30 ), allocatable , dimension (:) :: camberFile , airfoilFile character ( len = 30 ) :: geometryFile real ( dp ) :: nonDimforceDenominator contains procedure :: readGeom => rotor_readGeom procedure :: init => rotor_init procedure :: deinit => rotor_deinit procedure :: plot3dtoblade => rotor_plot3dtoblade procedure :: stltoblade => rotor_stltoblade procedure :: getCamber => rotor_getCamber procedure :: gettheta => rotor_gettheta procedure :: getthetadot => rotor_getthetadot procedure :: move => rotor_move procedure :: rot_pts => rotor_rot_pts procedure :: rot_advance => rotor_rot_advance procedure :: rot_flap => rotor_rot_flap procedure :: assignshed => rotor_assignshed procedure :: map_gam => rotor_map_gam procedure :: age_wake => rotor_age_wake procedure :: dissipate_wake => rotor_dissipate_wake procedure :: strain_wake => rotor_strain_wake procedure :: calcAIC => rotor_calcAIC procedure :: vind_bywing => rotor_vind_bywing procedure :: vind_bywing_boundVortices => rotor_vind_bywing_boundVortices procedure :: vind_bywake => rotor_vind_bywake procedure :: shiftwake => rotor_shiftwake procedure :: shiftFwake => rotor_shiftFwake procedure :: rollup => rotor_rollup procedure :: calc_force => rotor_calc_force ! procedure :: calc_force_gamma => rotor_calc_force_gamma procedure :: calc_force_alpha => rotor_calc_force_alpha procedure :: calc_force_alphaGamma => rotor_calc_force_alphaGamma procedure :: calc_secAlpha => rotor_calc_secAlpha procedure :: convectwake => rotor_convectwake procedure :: burst_wake => rotor_burst_wake procedure :: calc_skew => rotor_calc_skew procedure :: dirLiftDrag => rotor_dirLiftDrag procedure :: sumBladeToNetForces => rotor_sumBladeToNetForces procedure :: mirrorGamma => rotor_mirrorGamma procedure :: mirrorVelCP => rotor_mirrorVelCP procedure :: mirrorWake => rotor_mirrorWake procedure :: toChordsRevs => rotor_toChordsRevs procedure :: eraseNwake => rotor_eraseNwake procedure :: eraseFwake => rotor_eraseFwake procedure :: updatePrescribedWake => rotor_updatePrescribedWake procedure :: computeBladeDynamics => rotor_computeBladeDynamics procedure :: getdw procedure :: computeBodyDynamics => rotor_computeBodyDynamics ! I/O subroutines procedure :: rotor_write generic :: write ( unformatted ) => rotor_write procedure :: rotor_read generic :: read ( unformatted ) => rotor_read end type rotor_class contains !------+-- ! ++++ | vf_class Methods !------+-- ! Efficient implementation to vind calculation function vf_vind ( this , P ) result ( vind ) !! Compute induced velocity by unit strength vortex filament use libMath , only : unitVec class ( vf_class ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: vind real ( dp ), dimension ( 3 ) :: r1 , r2 , r0 , r1Xr2 real ( dp ) :: r1Xr2Abs2 r1 = P - this % fc (:, 1 ) r2 = P - this % fc (:, 2 ) r0 = r1 - r2 ! Cross product (inlined to avoid function call) r1Xr2 ( 1 ) = r1 ( 2 ) * r2 ( 3 ) - r1 ( 3 ) * r2 ( 2 ) r1Xr2 ( 2 ) = r1 ( 3 ) * r2 ( 1 ) - r1 ( 1 ) * r2 ( 3 ) r1Xr2 ( 3 ) = r1 ( 1 ) * r2 ( 2 ) - r1 ( 2 ) * r2 ( 1 ) r1Xr2Abs2 = dot_product ( r1Xr2 , r1Xr2 ) vind = 0. if ( r1Xr2Abs2 > eps * eps ) then ! Vatistas core model vind = ( r1Xr2 * inv4pi * dot_product ( r0 , unitVec ( r1 ) - unitVec ( r2 ))) & / sqrt (( this % rVc * norm2 ( r0 )) ** 4._dp + r1Xr2Abs2 ** 2._dp ) endif end function vf_vind subroutine vf_calclength ( this , isOriginal ) !! Compute length of vortex filament class ( vf_class ) :: this logical , intent ( in ) :: isOriginal real ( dp ), dimension ( 3 ) :: delta delta = this % fc (:, 1 ) - this % fc (:, 2 ) this % lc = norm2 ( delta ) if ( isOriginal . eqv . . TRUE .) this % l0 = norm2 ( delta ) end subroutine vf_calclength subroutine vf_strain ( this ) ! Changes core radius according to change in vortex length class ( vf_class ) :: this this % rVc = this % rVc0 * sqrt ( this % l0 / this % lc ) end subroutine vf_strain !------+-- ! ++++ | vr_class Methods !------+-- function vr_vind ( this , P ) result ( vind ) !! Compute induced velocity by unit strength 4-element vortex ring class ( vr_class ) :: this real ( dp ), dimension ( 3 ) :: P , vind real ( dp ), dimension ( 4 , 3 ) :: vindMat integer :: i vind = 0._dp do i = 1 , 4 vindMat ( i , :) = this % vf ( i )% vind ( P ) enddo vind = sum ( vindMat , 1 ) end function vr_vind function vr_vindSource ( this , P , nCap ) result ( vind ) !! Compute induced velocity by unit strength 3-element source ring class ( vr_class ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P , nCap real ( dp ), dimension ( 3 ) :: vind ! Add velocity induced by 3d source triangle here ! This dummy code prevents warnings during compilation vind = 0._dp * nCap * this % vf ( 1 )% vind ( P ) end function vr_vindSource ! Panel coordinates ! o---------> Y along span ! | ! |   1-----------4 ! |   |     4     | ! |   |           | ! |   |1         3| ! |   |           | ! |   |     2     | ! |   2-----------3 ! | ! V X along chord subroutine vr_assignP ( this , n , P ) !! Assign coordinates to nth corner class ( vr_class ) :: this integer , intent ( in ) :: n real ( dp ), dimension ( 3 ) :: P select case ( n ) case ( 1 ) this % vf ( 4 )% fc (:, 2 ) = P this % vf ( 1 )% fc (:, 1 ) = P case ( 2 ) this % vf ( 1 )% fc (:, 2 ) = P this % vf ( 2 )% fc (:, 1 ) = P case ( 3 ) this % vf ( 2 )% fc (:, 2 ) = P this % vf ( 3 )% fc (:, 1 ) = P case ( 4 ) this % vf ( 3 )% fc (:, 2 ) = P this % vf ( 4 )% fc (:, 1 ) = P case default error stop 'n may only take values 1,2,3 or 4' end select end subroutine vr_assignP subroutine vr_shiftdP ( this , n , dshift ) !! Shift coordinates of nth corner by dshift distance !! (usually for U*dt convection) class ( vr_class ) :: this integer , intent ( in ) :: n real ( dp ), intent ( in ), dimension ( 3 ) :: dshift integer :: ifil select case ( n ) case ( 0 ) do ifil = 1 , 4 this % vf ( ifil )% fc (:, 1 ) = this % vf ( ifil )% fc (:, 1 ) + dshift this % vf ( ifil )% fc (:, 2 ) = this % vf ( ifil )% fc (:, 2 ) + dshift enddo case ( 1 ) this % vf ( 4 )% fc (:, 2 ) = this % vf ( 4 )% fc (:, 2 ) + dshift this % vf ( 1 )% fc (:, 1 ) = this % vf ( 1 )% fc (:, 1 ) + dshift case ( 2 ) this % vf ( 1 )% fc (:, 2 ) = this % vf ( 1 )% fc (:, 2 ) + dshift this % vf ( 2 )% fc (:, 1 ) = this % vf ( 2 )% fc (:, 1 ) + dshift case ( 3 ) this % vf ( 2 )% fc (:, 2 ) = this % vf ( 2 )% fc (:, 2 ) + dshift this % vf ( 3 )% fc (:, 1 ) = this % vf ( 3 )% fc (:, 1 ) + dshift case ( 4 ) this % vf ( 3 )% fc (:, 2 ) = this % vf ( 3 )% fc (:, 2 ) + dshift this % vf ( 4 )% fc (:, 1 ) = this % vf ( 4 )% fc (:, 1 ) + dshift case default error stop 'n may only take values 1,2,3 or 4' end select end subroutine vr_shiftdP subroutine vr_rot ( this , Tmat , originVec ) !! Rotate vortex ring using Tmat about origin class ( vr_class ) :: this real ( dp ), intent ( in ), dimension ( 3 , 3 ) :: Tmat real ( dp ), dimension ( 3 ), optional :: originVec real ( dp ), dimension ( 3 ) :: origin integer :: i origin = [ 0._dp , 0._dp , 0._dp ] if ( present ( originVec )) origin = originVec do i = 1 , 4 this % vf ( i )% fc (:, 1 ) = matmul ( Tmat , this % vf ( i )% fc (:, 1 ) - origin ) + origin this % vf ( i )% fc (:, 2 ) = matmul ( Tmat , this % vf ( i )% fc (:, 2 ) - origin ) + origin enddo end subroutine vr_rot subroutine vr_calclength ( this , isOriginal ) !! Calculate length of filaments in vortex ring class ( vr_class ) :: this logical , intent ( in ) :: isOriginal integer :: i do i = 1 , 4 call this % vf ( i )% calclength ( isOriginal ) enddo end subroutine vr_calclength subroutine vr_strain ( this ) class ( vr_class ) :: this integer :: i do i = 1 , 4 call this % vf ( i )% strain () enddo end subroutine vr_strain subroutine vr_decay ( this , dt , decayCoeff ) class ( vr_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt , decayCoeff this % gam = this % gam * exp ( - decayCoeff * dt ) end subroutine vr_decay function vr_getInteriorAngles ( this ) !! Obtain interior angles of vortex ring use libMath , only : getAngleCos class ( vr_class ) :: this real ( dp ), dimension ( 4 ) :: vr_getInteriorAngles real ( dp ), dimension ( 3 ) :: p1 , p2 , p3 , p4 p1 = this % vf ( 1 )% fc (:, 1 ) p2 = this % vf ( 2 )% fc (:, 1 ) p3 = this % vf ( 3 )% fc (:, 1 ) p4 = this % vf ( 4 )% fc (:, 1 ) vr_getInteriorAngles = 0._dp vr_getInteriorAngles ( 1 ) = getAngleCos ( p2 - p1 , p4 - p1 ) vr_getInteriorAngles ( 2 ) = getAngleCos ( p3 - p2 , p1 - p2 ) vr_getInteriorAngles ( 3 ) = getAngleCos ( p4 - p3 , p2 - p3 ) vr_getInteriorAngles ( 4 ) = getAngleCos ( p3 - p4 , p1 - p4 ) end function vr_getInteriorAngles function vr_getMedianAngle ( this ) !! Obtain median angle of vortex ring use libMath , only : getAngleCos class ( vr_class ) :: this real ( dp ) :: vr_getMedianAngle real ( dp ), dimension ( 3 ) :: p1 , p2 , p3 , p4 p1 = this % vf ( 1 )% fc (:, 1 ) p2 = this % vf ( 2 )% fc (:, 1 ) p3 = this % vf ( 3 )% fc (:, 1 ) p4 = this % vf ( 4 )% fc (:, 1 ) vr_getMedianAngle = getAngleCos ( p3 + p4 - p1 - p2 , p4 + p1 - p2 - p3 ) end function vr_getMedianAngle function vr_getBimedianCos ( this ) !! Obtain angle between bimedians class ( vr_class ) :: this real ( dp ) :: vr_getBimedianCos real ( dp ), dimension ( 3 ) :: p1 , p2 , p3 , p4 real ( dp ), dimension ( 3 ) :: x1Vec , x2Vec p1 = this % vf ( 1 )% fc (:, 1 ) p2 = this % vf ( 2 )% fc (:, 1 ) p3 = this % vf ( 3 )% fc (:, 1 ) p4 = this % vf ( 4 )% fc (:, 1 ) x1Vec = p3 + p4 - p1 - p2 x2Vec = p4 + p1 - p2 - p3 vr_getBimedianCos = abs ( dot_product ( x1Vec , x2Vec ) / & sqrt ( dot_product ( x1Vec , x1Vec ) * dot_product ( x2Vec , x2Vec ))) end function vr_getBimedianCos subroutine vr_mirror ( this , coordNum ) !! Mirror gamma and coordinates about a specified plane class ( vr_class ) :: this integer , intent ( in ) :: coordNum integer :: ifil , i do ifil = 1 , 4 do i = 1 , 2 this % vf ( ifil )% fc ( coordNum , i ) = & & - 1._dp * this % vf ( ifil )% fc ( coordNum , i ) enddo enddo this % gam = - 1._dp * this % gam end subroutine vr_mirror subroutine calc_skew ( this ) !! Compute skew class ( vr_class ) :: this if ( abs ( this % gam ) > eps ) then ! skew:  0-good, 1-bad this % skew = this % getBimedianCos () else this % skew = 0._dp endif end subroutine calc_skew subroutine vr_burst ( this , skewLimit ) !! Burst vortex filaments if skewLimit is exceeded class ( vr_class ) :: this real ( dp ), intent ( in ) :: skewLimit real ( dp ) :: skewVal if (( abs ( this % gam ) > eps ) . and . ( skewLimit > eps )) then ! skew:  0-good, 1-bad skewVal = this % getBimedianCos () if ( skewVal . ge . skewLimit ) this % gam = 0._dp endif this % skew = skewVal end subroutine vr_burst !------+-- ! ++++ | wingpanel_class Methods !------+-- subroutine wingpanel_assignP ( this , n , P ) !! Assign coordinates to nth corner class ( wingpanel_class ) :: this integer , intent ( in ) :: n real ( dp ), dimension ( 3 ) :: P if ( n > 0 . and . n < 5 ) then this % pc (:, n ) = P else error stop 'n may only take values 1,2,3 or 4' endif end subroutine wingpanel_assignP subroutine wingpanel_calcCP ( this , isTriangle ) !! Compute collocation point location class ( wingpanel_class ) :: this logical , optional :: isTriangle logical :: triPanel triPanel = . false . ! Assumes quad panel by default if ( present ( isTriangle )) triPanel = isTriangle if ( triPanel ) then this % CP = ( this % PC (:, 1 ) + this % PC (:, 2 ) + this % PC (:, 3 )) / 3.0_dp else this % CP = (( this % PC (:, 1 ) + this % PC (:, 4 )) * 0.25_dp & + ( this % PC (:, 2 ) + this % PC (:, 3 )) * 0.75_dp ) * 0.5_dp endif end subroutine wingpanel_calcCP subroutine wingpanel_calcN ( this , isTriangle ) !! Compute normal vector use libMath , only : unitVec , cross_product class ( wingpanel_class ) :: this logical , optional :: isTriangle logical :: triPanel triPanel = . false . ! Assumes quad panel by default if ( present ( isTriangle )) triPanel = isTriangle if ( triPanel ) then this % nCap = unitvec ( this % nCap ) else this % nCap = unitVec ( cross_product ( this % pc (:, 3 ) - this % pc (:, 1 ), & this % pc (:, 4 ) - this % pc (:, 2 ))) endif end subroutine wingpanel_calcN subroutine wingpanel_invertNcap ( this ) ! Invert normal vector class ( wingpanel_class ) :: this this % nCap = - 1._dp * this % nCap end subroutine wingpanel_invertNcap subroutine wingpanel_calcTau ( this , isTriangle ) !! Compute chordwise and spanwise tangential vectors use libMath , only : unitVec class ( wingpanel_class ) :: this logical , optional :: isTriangle logical :: triPanel triPanel = . false . ! Assumes quad panel by default if ( present ( isTriangle )) triPanel = isTriangle if ( triPanel ) then this % tauCapChord = unitvec ( this % PC (:, 3 ) - this % PC (:, 1 )) this % tauCapSpan = unitvec ( this % PC (:, 4 ) - this % PC (:, 2 )) else this % tauCapChord = unitVec ( 0.5_dp * (( this % pc (:, 2 ) + this % pc (:, 3 )) & - ( this % pc (:, 1 ) + this % pc (:, 4 )))) this % tauCapSpan = unitVec ( 0.5_dp * (( this % pc (:, 3 ) + this % pc (:, 4 )) & - ( this % pc (:, 2 ) + this % pc (:, 1 )))) endif end subroutine wingpanel_calcTau subroutine wingpanel_rot ( this , Tmat , originVec ) !! Rotate panel using transformation matrix class ( wingpanel_class ) :: this real ( dp ), dimension ( 3 , 3 ) :: Tmat real ( dp ), dimension ( 3 ), optional :: originVec real ( dp ), dimension ( 3 ) :: origin integer :: i origin = [ 0._dp , 0._dp , 0._dp ] if ( present ( originVec )) origin = originVec do i = 1 , 4 this % pc (:, i ) = matmul ( Tmat , this % pc (:, i ) - origin ) + origin enddo call this % vr % rot ( Tmat , origin ) this % CP = matmul ( Tmat , this % CP - origin ) + origin this % nCap = matmul ( Tmat , this % nCap ) this % tauCapChord = matmul ( Tmat , this % tauCapChord ) this % tauCapSpan = matmul ( Tmat , this % tauCapSpan ) end subroutine wingpanel_rot subroutine wingpanel_shiftdP ( this , dshift ) !! Shift corners of vortex ring by dshift class ( wingpanel_class ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: dshift integer :: i this % CP = this % CP + dshift do i = 1 , 4 this % pc (:, i ) = this % pc (:, i ) + dshift call this % vr % shiftdP ( i , dshift ) enddo end subroutine wingpanel_shiftdP subroutine wingpanel_calc_area ( this ) use libMath , only : cross_product class ( wingpanel_class ) :: this this % panelArea = 0.5_dp * norm2 ( cross_product ( this % pc (:, 3 ) & - this % pc (:, 1 ), this % pc (:, 4 ) - this % pc (:, 2 ))) end subroutine wingpanel_calc_area subroutine wingpanel_calc_mean_dimensions ( this ) !! Calculate mean chord and mean span class ( wingpanel_class ) :: this this % meanSpan = 0.5_dp * ( norm2 ( this % pc (:, 4 ) - this % pc (:, 1 )) & + norm2 ( this % pc (:, 3 ) - this % pc (:, 2 ))) this % meanChord = 0.5_dp * ( norm2 ( this % pc (:, 2 ) - this % pc (:, 1 )) & + norm2 ( this % pc (:, 3 ) - this % pc (:, 4 ))) end subroutine wingpanel_calc_mean_dimensions function wingpanel_isCPinsidecore ( this ) !! Check whether collocation point lies !! inside viscous core region of vortex ring class ( wingpanel_class ), intent ( in ) :: this logical :: wingpanel_isCPinsidecore real ( dp ) :: deltaxby4 , deltayby2 deltaxby4 = 0.25_dp * abs ( this % vr % vf ( 1 )% fc ( 1 , 1 ) - this % vr % vf ( 2 )% fc ( 1 , 1 )) deltayby2 = 0.5_dp * abs ( this % vr % vf ( 1 )% fc ( 2 , 1 ) - this % vr % vf ( 4 )% fc ( 2 , 1 )) wingpanel_isCPinsidecore = . false . if ( deltayby2 . lt . this % vr % vf ( 1 )% rVc ) then wingpanel_isCPinsidecore = . true . ! Left edge elseif ( deltayby2 . lt . this % vr % vf ( 3 )% rVc ) then wingpanel_isCPinsidecore = . true . ! Right edge elseif ( deltaxby4 . lt . this % vr % vf ( 2 )% rVc ) then wingpanel_isCPinsidecore = . true . ! Upper edge elseif ( 3._dp * deltaxby4 . lt . this % vr % vf ( 4 )% rVc ) then wingpanel_isCPinsidecore = . true . ! Bottom edge endif end function wingpanel_isCPinsidecore subroutine wingpanel_calc_chordwiseResVel ( this ) !! Compute panel resultant velocities using local velocities use libMath , only : noProjVec class ( wingpanel_class ), intent ( inout ) :: this this % chordwiseResVel = noProjVec ( this % velCPTotal , this % tauCapSpan ) end subroutine wingpanel_calc_chordwiseResVel !------+-- ! ++++ | Nwake_class Methods !------+-- !------+-- ! ++++ | Fwake_class Methods !------+-- subroutine Fwake_shiftdP ( this , n , dshift ) !! Shift coordinates of nth corner by dshift distance !! (usually for Udt convection) class ( Fwake_class ) :: this integer , intent ( in ) :: n real ( dp ), intent ( in ), dimension ( 3 ) :: dshift if ( n < 0 . or . n > 2 ) & error stop 'n may only take values 0, 1 or 2 in Fwake_shiftdP()' if ( n == 0 ) then this % vf % fc (:, 1 ) = this % vf % fc (:, 1 ) + dshift this % vf % fc (:, 2 ) = this % vf % fc (:, 2 ) + dshift else this % vf % fc (:, n ) = this % vf % fc (:, n ) + dshift endif end subroutine Fwake_shiftdP subroutine Fwake_assignP ( this , n , P ) !! Assign point to nth endpoint of filament class ( Fwake_class ) :: this integer , intent ( in ) :: n real ( dp ), intent ( in ), dimension ( 3 ) :: P if ( n /= 1 . and . n /= 2 ) & error stop 'n may only take values 1 or 2 in Fwake_assignP()' this % vf % fc (:, n ) = P end subroutine Fwake_assignP subroutine Fwake_rot ( this , TMat , originVec ) !! Rotate using TMat about originVec class ( Fwake_class ) :: this real ( dp ), intent ( in ), dimension ( 3 , 3 ) :: TMat real ( dp ), dimension ( 3 ), optional :: originVec real ( dp ), dimension ( 3 ) :: origin origin = [ 0._dp , 0._dp , 0._dp ] if ( present ( originVec )) origin = originVec this % vf % fc (:, 1 ) = matmul ( TMat , this % vf % fc (:, 1 ) - origin ) + origin this % vf % fc (:, 2 ) = matmul ( TMat , this % vf % fc (:, 2 ) - origin ) + origin end subroutine Fwake_rot subroutine Fwake_decay ( this , dt , decayCoeff ) class ( Fwake_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt , decayCoeff this % gam = this % gam * exp ( - decayCoeff * dt ) end subroutine Fwake_decay subroutine Fwake_mirror ( this , coordNum ) !! Mirror gamma and coordinates about a specified plane class ( Fwake_class ) :: this integer , intent ( in ) :: coordNum integer :: i do i = 1 , 2 this % vf % fc ( coordNum , i ) = & & - 1._dp * this % vf % fc ( coordNum , i ) enddo this % gam = - 1._dp * this % gam end subroutine Fwake_mirror !------+-- ! ++++ | pFwake_class Methods !------+-- subroutine pFwake_update ( this , waF , hubCoords , shaftAxis , deltaPsi ) use libMath , only : linspace class ( pFwake_class ), intent ( inout ) :: this type ( Fwake_class ), intent ( in ), dimension (:) :: waF real ( dp ), intent ( in ), dimension ( 3 ) :: hubCoords , shaftAxis real ( dp ), intent ( in ) :: deltaPsi real ( dp ), dimension ( size ( this % coords , 2 )) :: theta real ( dp ), dimension ( 3 ) :: anchor real ( dp ) :: helixRadiusCurrent , helixPitchCurrent , deltaZ , dTheta integer :: i , npFwake , nFwake if ( abs ( shaftAxis ( 1 )) > eps . or . abs ( shaftAxis ( 2 )) > eps ) then error stop \"Prescribed far wake only implemented for shaft along Z-axis\" endif this % isPresent = . true . ! Find helix parameters nFwake = size ( waF ) anchor = waF ( nFwake )% vf % fc (:, 1 ) ! Radius and pitch of helix computed using ! average radius and slope of all far wake filaments helixPitchCurrent = 0._dp helixRadiusCurrent = 0._dp do i = 1 , nFwake helixRadiusCurrent = helixRadiusCurrent + & & norm2 ([ waF ( i )% vf % fc ( 2 , 1 ), waF ( i )% vf % fc ( 1 , 1 )]) if ( i < size ( waF )) then helixPitchCurrent = helixPitchCurrent + & & waF ( i )% vf % fc ( 3 , 1 ) - waF ( i + 1 )% vf % fc ( 3 , 1 ) endif enddo helixPitchCurrent = abs ( helixPitchCurrent ) * ( - twoPi / deltaPsi ) / ( nFwake - 1 ) helixRadiusCurrent = helixRadiusCurrent / nFwake ! Update pitch and radius using a relaxation factor ! to avoid sudden variations this % helixPitch = this % relaxFactor * helixPitchCurrent + & & ( 1 - this % relaxFactor ) * this % helixPitch this % helixRadius = this % relaxFactor * helixRadiusCurrent + & & ( 1 - this % relaxFactor ) * this % helixRadius ! Angle by which unit helix has to be rotated dTheta = atan2 ( anchor ( 2 ), anchor ( 1 )) ! delta z by which unit helix has to be translated deltaZ = anchor ( 3 ) - hubCoords ( 3 ) theta = linspace ( 0._dp , twoPi * this % nRevs , size ( theta , 1 )) if ( this % isClockwiseRotor ) theta = - 1._dp * theta this % coords ( 1 , :) = this % helixRadius * cos ( theta + dTheta ) this % coords ( 2 , :) = this % helixRadius * sin ( theta + dTheta ) this % coords ( 3 , :) = this % helixPitch * abs ( theta ) / twoPi + deltaZ ! Assign to prescribed wake npFwake = size ( this % waF ) do i = 1 , npFwake call this % waF ( i )% assignP ( 2 , hubCoords + this % coords (:, i )) call this % waF ( i )% assignP ( 1 , hubCoords + this % coords (:, i + 1 )) enddo ! To maintain continuity call this % waF ( 1 )% assignP ( 2 , anchor ) this % waF % gam = waF ( nFwake )% gam this % waF % vf % rVc = waF ( nFwake )% vf % rVc end subroutine pFwake_update subroutine pFwake_rot_wake_axis ( this , theta , axisVec , origin ) use libMath , only : getTransformAxis class ( pFwake_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: theta real ( dp ), intent ( in ), dimension ( 3 ) :: axisVec real ( dp ), intent ( in ), dimension ( 3 ) :: origin real ( dp ), dimension ( 3 , 3 ) :: Tmat integer :: i if ( abs ( theta ) > eps ) then TMat = getTransformAxis ( theta , axisVec ) !$omp parallel do do i = 1 , size ( this % waF ) call this % waF ( i )% rot ( TMat , origin ) enddo !$omp end parallel do endif end subroutine pFwake_rot_wake_axis !------+-- ! ++++ | blade_class Methods !------+-- subroutine blade_move ( this , dshift ) !! Move blade by dshift class ( blade_class ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: dshift integer :: i , j !$omp parallel do collapse(2) do j = 1 , this % ns do i = 1 , this % nc call this % wiP ( i , j )% shiftdP ( dshift ) enddo enddo !$omp end parallel do do i = 1 , size ( this % secCP , 2 ) this % secCP (:, i ) = this % secCP (:, i ) + dshift enddo this % flapOrigin = this % flapOrigin + dshift end subroutine blade_move subroutine blade_rot_pts ( this , pts , origin , order ) !! Rotate blade using pts. pts refers to (phi, theta, psi) use libMath , only : Tbg , Tgb class ( blade_class ), intent ( inout ) :: this real ( dp ), dimension ( 3 ), intent ( in ) :: pts ! pts => phi,theta,psi real ( dp ), dimension ( 3 ), intent ( in ) :: origin ! rotation about integer , intent ( in ) :: order ! [1]gb & +ve theta , [2]bg & -ve theta integer :: i , j real ( dp ), dimension ( 3 , 3 ) :: TMat select case ( order ) case ( 2 ) TMat = Tbg ([ cos ( pts ( 1 )), sin ( pts ( 1 ))], & [ cos ( pts ( 2 )), sin ( pts ( 2 ))], & [ cos ( pts ( 3 )), sin ( pts ( 3 ))]) case ( 1 ) TMat = Tgb ([ cos ( pts ( 1 )), sin ( pts ( 1 ))], & [ cos ( pts ( 2 )), sin ( pts ( 2 ))], & [ cos ( pts ( 3 )), sin ( pts ( 3 ))]) case default error stop 'ERROR: Wrong option for order' end select !$omp parallel do do j = 1 , this % ns do i = 1 , this % nc call this % wiP ( i , j )% rot ( TMat , origin ) enddo this % secCP (:, j ) = matmul ( TMat , this % secCP (:, j ) - origin ) + origin ! Rotate sec vectors this % secTauCapChord (:, j ) = matmul ( TMat , this % secTauCapChord (:, j )) this % secNormalVec (:, j ) = matmul ( TMat , this % secNormalVec (:, j )) enddo !$omp end parallel do this % xAxis = matmul ( Tmat , this % xAxis ) this % yAxis = matmul ( Tmat , this % yAxis ) this % zAxis = matmul ( Tmat , this % zAxis ) this % xAxisAzi = matmul ( Tmat , this % xAxisAzi ) this % yAxisAzi = matmul ( Tmat , this % yAxisAzi ) this % zAxisAzi = matmul ( Tmat , this % zAxisAzi ) this % xAxisAziFlap = matmul ( Tmat , this % xAxisAziFlap ) this % yAxisAziFlap = matmul ( Tmat , this % yAxisAziFlap ) this % zAxisAziFlap = matmul ( Tmat , this % zAxisAziFlap ) end subroutine blade_rot_pts subroutine blade_rot_pitch ( this , theta ) !! Rotate blade by pitch angle about pivotLE ! Pivot point calculated using straight line joining ! LE of first panel and TE of last panel at hub class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: theta real ( dp ), dimension ( 3 ) :: axisOrigin if ( abs ( theta ) > eps ) then axisOrigin = this % wiP ( 1 , 1 )% PC (:, 1 ) * ( 1._dp - this % pivotLE ) & & + this % wiP ( this % nc , 1 )% PC (:, 2 ) * this % pivotLE call this % rotate ( theta , & & this % yAxis ( 1 ), this % yAxis ( 2 ), this % yAxis ( 3 ), & & axisOrigin ( 1 ), axisOrigin ( 2 ), axisOrigin ( 3 ), & & 'pitch' ) endif end subroutine blade_rot_pitch subroutine blade_rot_flap ( this , beta ) !! Rotate blade by flap angle class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: beta call this % rotate ( beta , & & this % xAxisAzi ( 1 ), this % xAxisAzi ( 2 ), this % xAxisAzi ( 3 ), & & this % flapOrigin ( 1 ), this % flapOrigin ( 2 ), this % flapOrigin ( 3 ), & & 'flap' ) end subroutine blade_rot_flap subroutine blade_rotate ( this , angleRad , axisX , axisY , axisZ , & & originX , originY , originZ , rotateType ) !! Rotate blade geometry about axis at specified origin !! Rotation angle in radians use libMath , only : getTransformAxis class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ), value :: angleRad real ( dp ), intent ( in ), value :: axisX , axisY , axisZ real ( dp ), intent ( in ), value :: originX , originY , originZ real ( dp ), dimension ( 3 , 3 ) :: Tmat character ( len =* ), intent ( in ) :: rotateType integer :: i , j if ( abs ( angleRad ) > eps ) then ! Translate to origin call this % move ( - 1._dp * [ originX , originY , originZ ]) ! Rotate about axis = (axisX, axisY, axisZ) Tmat = getTransformAxis ( angleRad , [ axisX , axisY , axisZ ]) do j = 1 , this % ns do i = 1 , this % nc call this % wiP ( i , j )% rot ( TMat ) enddo enddo ! Untranslate from origin call this % move ([ originX , originY , originZ ]) ! Rotate secCP also !$omp parallel do do i = 1 , this % ns this % secCP (:, i ) = matmul ( TMat , this % secCP (:, i ) - & & [ originX , originY , originZ ]) + [ originX , originY , originZ ] ! Rotate sec vectors also along with blade this % secTauCapChord (:, i ) = matmul ( TMat , this % secTauCapChord (:, i )) this % secTauCapSpan (:, i ) = matmul ( TMat , this % secTauCapSpan (:, i )) this % secNormalVec (:, i ) = matmul ( TMat , this % secNormalVec (:, i )) enddo !$omp end parallel do ! Rotate reference frames select case ( rotateType ) case ( 'azimuth' ) this % xAxisAziFlap = matmul ( TMat , this % xAxisAziFlap ) this % yAxisAziFlap = matmul ( TMat , this % yAxisAziFlap ) this % zAxisAziFlap = matmul ( TMat , this % zAxisAziFlap ) this % xAxisAzi = matmul ( TMat , this % xAxisAzi ) this % yAxisAzi = matmul ( TMat , this % yAxisAzi ) this % zAxisAzi = matmul ( TMat , this % zAxisAzi ) this % xAxis = matmul ( TMat , this % xAxis ) this % yAxis = matmul ( TMat , this % yAxis ) this % zAxis = matmul ( TMat , this % zAxis ) case ( 'flap' ) this % xAxisAziFlap = matmul ( TMat , this % xAxisAziFlap ) this % yAxisAziFlap = matmul ( TMat , this % yAxisAziFlap ) this % zAxisAziFlap = matmul ( TMat , this % zAxisAziFlap ) this % xAxis = matmul ( TMat , this % xAxis ) this % yAxis = matmul ( TMat , this % yAxis ) this % zAxis = matmul ( TMat , this % zAxis ) case ( 'pitch' ) this % xAxis = matmul ( TMat , this % xAxis ) this % yAxis = matmul ( TMat , this % yAxis ) this % zAxis = matmul ( TMat , this % zAxis ) case default this % xAxisAziFlap = matmul ( TMat , this % xAxisAziFlap ) this % yAxisAziFlap = matmul ( TMat , this % yAxisAziFlap ) this % zAxisAziFlap = matmul ( TMat , this % zAxisAziFlap ) this % xAxisAzi = matmul ( TMat , this % xAxisAzi ) this % yAxisAzi = matmul ( TMat , this % yAxisAzi ) this % zAxisAzi = matmul ( TMat , this % zAxisAzi ) this % xAxis = matmul ( TMat , this % xAxis ) this % yAxis = matmul ( TMat , this % yAxis ) this % zAxis = matmul ( TMat , this % zAxis ) end select endif end subroutine blade_rotate subroutine blade_rot_wake_axis ( this , theta , axisVec , origin , & & rowNear , rowFar , wakeType ) !! Rotate wake about axis at specified origin use libMath , only : getTransformAxis class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: theta real ( dp ), intent ( in ), dimension ( 3 ) :: axisVec real ( dp ), intent ( in ), dimension ( 3 ) :: origin integer , intent ( in ) :: rowNear , rowFar character ( len = 1 ), intent ( in ) :: wakeType ! For predicted wake integer :: nNwake , nFwake real ( dp ), dimension ( 3 , 3 ) :: Tmat integer :: i , j if ( abs ( theta ) > eps ) then TMat = getTransformAxis ( theta , axisVec ) select case ( wakeType ) case ( 'C' ) ! Start procedure for wake rotation nNwake = size ( this % waN , 1 ) nFwake = size ( this % waF , 1 ) !$omp parallel do collapse(2) do j = 1 , this % ns do i = rowNear , nNwake call this % waN ( i , j )% vr % rot ( TMat , origin ) enddo enddo !$omp end parallel do !$omp parallel do do i = rowFar , nFwake call this % waF ( i )% rot ( TMat , origin ) enddo !$omp end parallel do case ( 'P' ) ! Start procedure for wake rotation nNwake = size ( this % waNPredicted , 1 ) nFwake = size ( this % waFPredicted , 1 ) !$omp parallel do collapse(2) do j = 1 , this % ns do i = rowNear , nNwake call this % waNPredicted ( i , j )% vr % rot ( TMat , origin ) enddo enddo !$omp end parallel do !$omp parallel do do i = rowFar , nFwake call this % waFPredicted ( i )% rot ( TMat , origin ) enddo !$omp end parallel do end select endif end subroutine blade_rot_wake_axis function blade_vind_bywing ( this , P ) !! Compute induced velocity by blade bound vorticity class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: blade_vind_bywing integer :: i , j blade_vind_bywing = 0._dp do j = 1 , this % ns do i = 1 , this % nc blade_vind_bywing = blade_vind_bywing + & & this % wiP ( i , j )% vr % vind ( P ) * this % wiP ( i , j )% vr % gam enddo enddo end function blade_vind_bywing function blade_vindSource_bywing ( this , P ) !! Compute induced velocity by blade bound vorticity class ( blade_class ), intent ( in ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: blade_vindSource_bywing integer :: i , j blade_vindSource_bywing = 0._dp do j = 1 , this % ns do i = 1 , this % nc blade_vindSource_bywing = blade_vindSource_bywing + & this % wiP ( i , j )% vr % vindSource ( P , this % wiP ( i , j )% nCap ) * & & this % wiP ( i , j )% vr % gam enddo enddo end function blade_vindSource_bywing function blade_vind_bywing_boundVortices ( this , P ) !! Compute induced velocity by bound vortices alone class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: blade_vind_bywing_boundVortices integer :: i , j blade_vind_bywing_boundVortices = 0._dp do j = 1 , this % ns do i = 1 , this % nc blade_vind_bywing_boundVortices = blade_vind_bywing_boundVortices + & & ( this % wiP ( i , j )% vr % vf ( 2 )% vind ( P ) + & & this % wiP ( i , j )% vr % vf ( 4 )% vind ( P )) * this % wiP ( i , j )% vr % gam enddo enddo do j = 1 , this % ns blade_vind_bywing_boundVortices = blade_vind_bywing_boundVortices - & this % wiP ( this % nc , j )% vr % vf ( 2 )% vind ( P ) * this % wiP ( this % nc , j )% vr % gam enddo end function blade_vind_bywing_boundVortices function blade_vind_bywing_chordwiseVortices ( this , P ) !! Compute induced velocity by bound vortices alone class ( blade_class ), intent ( in ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: blade_vind_bywing_chordwiseVortices integer :: i , j blade_vind_bywing_chordwiseVortices = 0._dp do j = 1 , this % ns do i = 1 , this % nc blade_vind_bywing_chordwiseVortices = blade_vind_bywing_chordwiseVortices + & ( this % wiP ( i , j )% vr % vf ( 1 )% vind ( P ) + this % wiP ( i , j )% vr % vf ( 3 )% vind ( P )) * & this % wiP ( i , j )% vr % gam enddo enddo do j = 1 , this % ns blade_vind_bywing_chordwiseVortices = & & blade_vind_bywing_chordwiseVortices + & & this % wiP ( this % nc , j )% vr % vf ( 2 )% vind ( P ) * this % wiP ( this % nc , j )% vr % gam enddo end function blade_vind_bywing_chordwiseVortices function blade_vind_boundVortex ( this , ic , is , P ) !! Compute induced velocity by bound vortices alone class ( blade_class ), intent ( inout ) :: this integer , intent ( in ) :: ic , is real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: blade_vind_boundVortex if ( ic > 1 ) then blade_vind_boundVortex = this % wiP ( ic , is )% vr % vf ( 4 )% vind ( P ) & * this % wiP ( ic , is )% vr % gam & + this % wiP ( ic - 1 , is )% vr % vf ( 2 )% vind ( P ) * this % wiP ( ic - 1 , is )% vr % gam else blade_vind_boundVortex = this % wiP ( ic , is )% vr % vf ( 4 )% vind ( P ) & * this % wiP ( ic , is )% vr % gam endif end function blade_vind_boundVortex function blade_vind_bywake ( this , rowNear , rowFar , P , optionalChar ) !! Compute induced velocity by wake vortex rings class ( blade_class ), intent ( in ) :: this integer , intent ( in ) :: rowNear , rowFar real ( dp ), intent ( in ), dimension ( 3 ) :: P character ( len = 1 ), optional :: optionalChar real ( dp ), dimension ( 3 ) :: blade_vind_bywake integer :: i , j , nNwake , nFwake nNwake = size ( this % waN , 1 ) nFwake = size ( this % waF , 1 ) blade_vind_bywake = 0._dp if (. not . present ( optionalChar )) then do j = 1 , size ( this % waN , 2 ) do i = rowNear , nNwake if ( abs ( this % waN ( i , j )% vr % gam ) . gt . eps ) & blade_vind_bywake = blade_vind_bywake + & this % waN ( i , j )% vr % vind ( P ) * this % waN ( i , j )% vr % gam enddo enddo if ( rowFar . le . nFwake ) then ! Last row of Nwake is made of horseshoe vortices, if Fwake is generated do j = 1 , size ( this % waN , 2 ) blade_vind_bywake = blade_vind_bywake - & this % waN ( nNwake , j )% vr % vf ( 2 )% vind ( P ) * this % waN ( nNwake , j )% vr % gam enddo do i = rowFar , nFwake if ( abs ( this % waF ( i )% gam ) . gt . eps ) & blade_vind_bywake = blade_vind_bywake & + this % waF ( i )% vf % vind ( P ) * this % waF ( i )% gam enddo do i = 1 , size ( this % wapF % waF ) if ( abs ( this % wapF % waF ( i )% gam ) . gt . eps ) then blade_vind_bywake = blade_vind_bywake & & + this % wapF % waF ( i )% vf % vind ( P ) * this % wapF % waF ( i )% gam endif enddo endif elseif (( optionalChar . eq . 'P' ) . or . ( optionalChar . eq . 'p' )) then do j = 1 , size ( this % waN , 2 ) do i = rowNear , nNwake if ( abs ( this % waNPredicted ( i , j )% vr % gam ) . gt . eps ) & blade_vind_bywake = blade_vind_bywake & + this % waNPredicted ( i , j )% vr % vind ( P ) * this % waNPredicted ( i , j )% vr % gam enddo enddo if ( rowFar . le . nFwake ) then ! Last row of Nwake is made of horseshoe vortices, if Fwake is generated do j = 1 , size ( this % waN , 2 ) blade_vind_bywake = blade_vind_bywake & - this % waNPredicted ( nNwake , j )% vr % vf ( 2 )% vind ( P ) * this % waNPredicted ( nNwake , j )% vr % gam enddo do i = rowFar , nFwake if ( abs ( this % waFPredicted ( i )% gam ) . gt . eps ) & blade_vind_bywake = blade_vind_bywake & + this % waFPredicted ( i )% vf % vind ( P ) * this % waFPredicted ( i )% gam enddo do i = 1 , size ( this % wapFPredicted % waF ) if ( abs ( this % wapFPredicted % waF ( i )% gam ) . gt . eps ) then blade_vind_bywake = blade_vind_bywake & & + this % wapFPredicted % waF ( i )% vf % vind ( P ) & & * this % wapFPredicted % waF ( i )% gam endif enddo endif else error stop 'ERROR: Wrong character flag for blade_vind_bywake()' endif end function blade_vind_bywake subroutine blade_convectwake ( this , rowNear , rowFar , dt , wakeType ) !! Convect wake collocation points using velNwake matrix class ( blade_class ), intent ( inout ) :: this integer , intent ( in ) :: rowNear , rowFar real ( dp ), intent ( in ) :: dt character ( len = 1 ), intent ( in ) :: wakeType ! For predicted wake integer :: i , j , nNwake , nFwake nNwake = size ( this % waN , 1 ) select case ( wakeType ) case ( 'C' ) ! [C]urrent wake !$omp parallel do collapse(2) do j = 1 , this % ns do i = rowNear , nNwake call this % waN ( i , j )% vr % shiftdP ( 2 , this % velNwake (:, i , j ) * dt ) enddo enddo !$omp end parallel do !$omp parallel do do i = rowNear , nNwake call this % waN ( i , this % ns )% vr % shiftdP ( 3 , this % velNwake (:, i , this % ns + 1 ) * dt ) enddo !$omp end parallel do nFwake = size ( this % waF , 1 ) !$omp parallel do do i = rowFar , nFwake call this % waF ( i )% shiftdP ( 1 , this % velFwake (:, i ) * dt ) ! Shift only TE enddo !$omp end parallel do case ( 'P' ) ! [P]redicted wake !$omp parallel do collapse(2) do j = 1 , this % ns do i = 1 , rowNear , nNwake call this % waNPredicted ( i , j )% vr % shiftdP ( 2 , this % velNwake (:, i , j ) * dt ) enddo enddo !$omp end parallel do !$omp parallel do do i = 1 , rowNear , nNwake call this % waNPredicted ( i , this % ns )% vr % shiftdP ( 3 , this % velNwake (:, i , this % ns + 1 ) * dt ) enddo !$omp end parallel do nFwake = size ( this % waF , 1 ) !$omp parallel do do i = rowFar , nFwake call this % waFPredicted ( i )% shiftdP ( 1 , this % velFwake (:, i ) * dt ) ! Shift only TE enddo !$omp end parallel do end select call this % wake_continuity ( rowNear , rowFar , wakeType ) end subroutine blade_convectwake subroutine blade_limitWakeVel ( this , rowNear , rowFar ) !! Limits all wake velocity to a set value to prevent blow up class ( blade_class ), intent ( inout ) :: this integer , intent ( in ) :: rowNear , rowFar integer :: i , j , di , nNwake , nFwake nNwake = size ( this % waN , 1 ) nFwake = size ( this % waF , 1 ) !$omp parallel do collapse(2) do j = 1 , this % ns do i = rowNear , nNwake do di = 1 , 3 this % velNwake ( di , i , j ) = sign ( & & min ( abs ( this % velNwake ( di , i , j )), this % velWakeMax ), & & this % velNwake ( di , i , j )) enddo enddo enddo !$omp end parallel do !$omp parallel do do i = rowFar , nFwake do di = 1 , 3 this % velFwake ( di , i ) = sign ( & & min ( abs ( this % velFwake ( di , i )), this % velWakeMax ), & & this % velFwake ( di , i )) enddo enddo !$omp end parallel do end subroutine blade_limitWakeVel subroutine blade_wake_continuity ( this , rowNear , rowFar , wakeType ) !! Maintain continuity between vortex ring elements after convection !! of wake collocation points class ( blade_class ), intent ( inout ) :: this integer , intent ( in ) :: rowNear , rowFar character ( len = 1 ), intent ( in ) :: wakeType ! For predicted wake integer :: i , j , nNwake , nFwake nNwake = size ( this % waN , 1 ) select case ( wakeType ) case ( 'C' ) !$omp parallel do collapse(2) do j = 1 , this % ns - 1 do i = rowNear + 1 , nNwake call this % waN ( i , j )% vr % assignP ( 1 , this % waN ( i - 1 , j )% vr % vf ( 2 )% fc (:, 1 )) call this % waN ( i , j )% vr % assignP ( 3 , this % waN ( i , j + 1 )% vr % vf ( 2 )% fc (:, 1 )) call this % waN ( i , j )% vr % assignP ( 4 , this % waN ( i - 1 , j + 1 )% vr % vf ( 2 )% fc (:, 1 )) enddo enddo !$omp end parallel do !$omp parallel do do j = 1 , this % ns - 1 call this % waN ( rowNear , j )% vr % assignP ( 3 , this % waN ( rowNear , j + 1 )% vr % vf ( 2 )% fc (:, 1 )) enddo !$omp end parallel do !$omp parallel do do i = rowNear + 1 , nNwake call this % waN ( i , this % ns )% vr % assignP ( 1 , this % waN ( i - 1 , this % ns )% vr % vf ( 2 )% fc (:, 1 )) call this % waN ( i , this % ns )% vr % assignP ( 4 , this % waN ( i - 1 , this % ns )% vr % vf ( 3 )% fc (:, 1 )) enddo !$omp end parallel do nFwake = size ( this % waF , 1 ) !$omp parallel do do i = rowFar + 1 , nFwake call this % waF ( i )% assignP ( 2 , this % waF ( i - 1 )% vf % fc (:, 1 )) enddo !$omp end parallel do case ( 'P' ) ! For predicted wake !$omp parallel do collapse(2) do j = 1 , this % ns - 1 do i = rowNear + 1 , nNwake call this % waNPredicted ( i , j )% vr % assignP ( 1 , this % waNPredicted ( i - 1 , j )% vr % vf ( 2 )% fc (:, 1 )) call this % waNPredicted ( i , j )% vr % assignP ( 3 , this % waNPredicted ( i , j + 1 )% vr % vf ( 2 )% fc (:, 1 )) call this % waNPredicted ( i , j )% vr % assignP ( 4 , this % waNPredicted ( i - 1 , j + 1 )% vr % vf ( 2 )% fc (:, 1 )) enddo enddo !$omp end parallel do !$omp parallel do do j = 1 , this % ns - 1 call this % waNPredicted ( rowNear , j )% vr % assignP ( 3 , this % waNPredicted ( rowNear , j + 1 )% vr % vf ( 2 )% fc (:, 1 )) enddo !$omp end parallel do !$omp parallel do do i = rowNear + 1 , nNwake call this % waNPredicted ( i , this % ns )% vr % assignP ( 1 , this % waNPredicted ( i - 1 , this % ns )% vr % vf ( 2 )% fc (:, 1 )) call this % waNPredicted ( i , this % ns )% vr % assignP ( 4 , this % waNPredicted ( i - 1 , this % ns )% vr % vf ( 3 )% fc (:, 1 )) enddo !$omp end parallel do nFwake = size ( this % waF , 1 ) !$omp parallel do do i = rowFar + 1 , nFwake call this % waFPredicted ( i )% assignP ( 2 , this % waFPredicted ( i - 1 )% vf % fc (:, 1 )) enddo !$omp end parallel do case default error stop 'ERROR: Wrong character flag for convectwake()' end select end subroutine blade_wake_continuity subroutine blade_calc_force ( this , density , Omega , dt ) !! Compute force using blade circulation use libMath , only : unitVec , cross_product , projVec class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: density , Omega , dt integer :: is , ic real ( dp ), dimension ( this % nc , this % ns ) :: velTangentialChord real ( dp ), dimension ( this % nc , this % ns ) :: velTangentialSpan real ( dp ), dimension ( this % nc , this % ns ) :: velInduced real ( dp ), dimension ( this % nc , this % ns ) :: gamElementChord , gamElementSpan real ( dp ), dimension ( this % ns ) :: secDynamicPressure real ( dp ) :: signSecCL , invertGammaSign this % forceInertial = 0._dp this % secForceInertial = 0._dp this % secLift = 0._dp this % secDrag = 0._dp this % secLiftInPlane = 0._dp this % secLiftOutPlane = 0._dp this % secLiftUnsteady = 0._dp ! invert sign of gamma only if Omega is positive invertGammaSign = - 1._dp * sign ( 1._dp , Omega ) ! Compute tangential velocity do is = 1 , this % ns do ic = 1 , this % nc velTangentialChord ( ic , is ) = dot_product ( this % wiP ( ic , is )% velCP , this % wiP ( ic , is )% tauCapChord ) velTangentialSpan ( ic , is ) = dot_product ( this % wiP ( ic , is )% velCP , this % wiP ( ic , is )% tauCapSpan ) velInduced ( ic , is ) = dot_product ( this % wiP ( ic , is )% velCP + & this % vind_bywing_chordwiseVortices ( this % wiP ( ic , is )% CP ), & unitVec ( cross_product ( this % wiP ( ic , is )% velCPm , this % yAxis ))) enddo enddo ! Compute chordwise elemental circulation of edge panels do is = 1 , this % ns gamElementChord ( 1 , is ) = this % wiP ( 1 , is )% vr % gam enddo do ic = 2 , this % nc gamElementChord ( ic , 1 ) = this % wiP ( ic , 1 )% vr % gam & & - this % wiP ( ic - 1 , 1 )% vr % gam enddo ! Compute spanwise elemental circulation of edge panels do ic = 1 , this % nc gamElementSpan ( ic , 1 ) = this % wiP ( ic , 1 )% vr % gam enddo do is = 2 , this % ns gamElementSpan ( 1 , is ) = this % wiP ( 1 , is )% vr % gam & & - this % wiP ( 1 , is - 1 )% vr % gam enddo ! Compute chordwise and spanwise elemental circulations of inner panels do is = 2 , this % ns do ic = 2 , this % nc gamElementChord ( ic , is ) = this % wiP ( ic , is )% vr % gam - this % wiP ( ic - 1 , is )% vr % gam gamElementSpan ( ic , is ) = this % wiP ( ic , is )% vr % gam - this % wiP ( ic , is - 1 )% vr % gam enddo enddo ! Invert gamma sign for correct computation gamElementSpan = invertGammaSign * gamElementSpan gamElementChord = invertGammaSign * gamElementChord ! Compute delP do is = 1 , this % ns do ic = 1 , this % nc ! Use trapezoidal rule on two points to get current gam ! for computing unsteady lift part if ( ic > 1 ) then this % wiP ( ic , is )% gamTrapz = invertGammaSign * 0.5_dp * & & ( this % wiP ( ic , is )% vr % gam + this % wiP ( ic - 1 , is )% vr % gam ) else this % wiP ( 1 , is )% gamTrapz = invertGammaSign * 0.5_dp * & & this % wiP ( 1 , is )% vr % gam endif ! For checking against Katz's fixed wing code uncomment this ! velTangentialChord(ic,is)=10._dp*cos(5._dp*degToRad) ! velTangentialSpan(ic,is)=0._dp this % wiP ( ic , is )% delPUnsteady = density * & & ( this % wiP ( ic , is )% gamTrapz - this % wiP ( ic , is )% gamPrev ) / dt this % wiP ( ic , is )% delP = this % wiP ( ic , is )% delPUnsteady + & & density * velTangentialChord ( ic , is ) * & & gamElementChord ( ic , is ) / this % wiP ( ic , is )% meanChord if ( this % spanwiseLiftSwitch . ne . 0 ) then this % wiP ( ic , is )% delP = this % wiP ( ic , is )% delP + density * & & velTangentialSpan ( ic , is ) * & & gamElementSpan ( ic , is ) / this % wiP ( ic , is )% meanSpan endif this % wiP ( ic , is )% gamPrev = this % wiP ( ic , is )% gamTrapz ! Compute induced drag ! velInduced in either direction doesnt change drag direction ! this%wiP(ic, is)%delDiConstant = density*abs(velInduced(ic, is))* & !   & abs(gamElementChord(ic, is))*this%wiP(ic, is)%meanSpan ! this%wiP(ic, is)%delDiUnsteady = this%wiP(ic, is)%delPUnsteady* & !   & this%wiP(ic, is)%panelArea * & !   & dot_product(this%wiP(ic, is)%nCap, & !   & unitVec(this%wiP(ic, is)%velCPm)) ! This may be incorrect for cambered airfoils in the region ! where alpha is -ve but lift is +ve ! delP and delPUnsteady already have inverGammaSign this % wiP ( ic , is )% normalForce = this % wiP ( ic , is )% delP * & & this % wiP ( ic , is )% panelArea * this % wiP ( ic , is )% nCap this % wiP ( ic , is )% normalForceUnsteady = & & this % wiP ( ic , is )% delPUnsteady * & & this % wiP ( ic , is )% panelArea * this % wiP ( ic , is )% nCap this % secForceInertial (:, is ) = this % secForceInertial (:, is ) + & & this % wiP ( ic , is )% normalForce this % secLift (:, is ) = this % secLift (:, is ) + & & projVec ( this % wiP ( ic , is )% normalForce , this % secLiftDir (:, is )) this % secLiftUnsteady (:, is ) = this % secLiftUnsteady (:, is ) + & & projVec ( this % wiP ( ic , is )% normalForceUnsteady , & & this % secLiftDir (:, is )) enddo ! Induced drag is difficult to define when the reference freestream ! velocity direction is not clear. For eg. when u and v are provided. ! Instead the non-pitched axis are used tocompute inplane and ! out of plane components. ! Compute in-plane and out of flap plane components of lift ! The in-plane component is induced drag this % secLiftInPlane (:, is ) = invertGammaSign * & & projVec ( this % secLift (:, is ), this % xAxisAziFlap ) this % secLiftOutPlane (:, is ) = projVec ( this % secLift (:, is ), & & this % zAxisAziFlap ) this % secLiftInPlaneUnsteady (:, is ) = invertGammaSign * & & projVec ( this % secLiftUnsteady (:, is ), this % xAxisAziFlap ) this % secLiftOutPlaneUnsteady (:, is ) = & & projVec ( this % secLiftUnsteady (:, is ), this % zAxisAziFlap ) ! this%secDragInduced(:, is) = this%secDragDir(:, is)* & !   sum(this%wiP(:, is)%delDiConstant + this%wiP(:, is)%delDiUnsteady) ! Drag unsteady is purely for monitoring purposes if required ! and is not used for computations anywhere ! this%secDragUnsteady(:, is) = this%secDragDir(:, is)* & !   sum(this%wiP(:, is)%delDiUnsteady) ! Drag forces are put to zero for now this % secDragInduced (:, is ) = 0._dp this % secDragUnsteady (:, is ) = 0._dp enddo ! To overwrite unit vectors previously assigned in main.f90 this % secDragProfile = 0._dp this % secDrag = this % secDragInduced + this % secDragProfile ! Compute sectional coefficients ! Compute secChordwiseResVel for calculating secDynamicPressure ! including induced velocities ! This is already called when computing dirLiftDrag ! call this%calc_secChordwiseResVel() secDynamicPressure = this % getSecDynamicPressure ( density ) do is = 1 , this % ns if ( abs ( secDynamicPressure ( is )) > eps ) then ! Use sign of delP to obtain sign of CL signSecCL = sign ( 1._dp , & & dot_product ( this % secLift (:, is ), this % zAxisAziFlap )) this % secCL ( is ) = norm2 ( this % secLift (:, is )) * signSecCL / & & ( secDynamicPressure ( is ) * this % secArea ( is )) this % secCD ( is ) = norm2 ( this % secDrag (:, is )) / & & ( secDynamicPressure ( is ) * this % secArea ( is )) this % secCLu ( is ) = norm2 ( this % secLiftUnsteady (:, is )) * signSecCL / & & ( secDynamicPressure ( is ) * this % secArea ( is )) this % secMflap ( is ) = norm2 ( this % secLift (:, is )) * signSecCL * & & this % secMflapArm ( is ) else this % secCL ( is ) = 0._dp this % secCD ( is ) = 0._dp this % secCLu ( is ) = 0._dp this % secMflap ( is ) = 0._dp endif enddo call this % sumSecToNetForces () end subroutine blade_calc_force ! subroutine blade_calc_force_gamma(this, density, invertGammaSign, dt) !   ! Compute force using blade circulation !   use libMath, only: unitVec, cross_product, projVec ! class(blade_class), intent(inout) :: this !   real(dp), intent(in) :: density, invertGammaSign, dt !   integer :: is, ic !   real(dp), dimension(this%nc, this%ns) :: velTangentialChord !   real(dp), dimension(this%nc, this%ns) :: velTangentialSpan !   real(dp), dimension(this%nc, this%ns) :: velInduced !   real(dp), dimension(this%nc, this%ns) :: gamElementChord, gamElementSpan !   real(dp), dimension(this%ns) :: secDynamicPressure !   real(dp) :: signSecCL ! !   this%forceInertial = 0._dp !   this%secForceInertial = 0._dp !   this%secLift = 0._dp !   this%secDrag = 0._dp !   this%secLiftUnsteady = 0._dp ! !   ! Compute tangential velocity !   do is = 1, this%ns !     do ic = 1, this%nc !       velTangentialChord(ic, is) = dot_product(this%wiP(ic, is)%velCP, this%wiP(ic, is)%tauCapChord) !       velTangentialSpan(ic, is) = dot_product(this%wiP(ic, is)%velCP, this%wiP(ic, is)%tauCapSpan) !       velInduced(ic, is) = dot_product(this%wiP(ic, is)%velCP + & !         this%vind_bywing_chordwiseVortices(this%wiP(ic, is)%CP), & !         unitVec(cross_product(this%wiP(ic, is)%velCPm,this%yAxis))) !     enddo !   enddo ! !   ! Compute chordwise elemental circulation of edge panels !   do is = 1, this%ns !     gamElementChord(1, is) = this%wiP(1, is)%vr%gam !   enddo !   do ic = 2, this%nc !     gamElementChord(ic, 1) = this%wiP(ic, 1)%vr%gam & !       & -this%wiP(ic - 1, 1)%vr%gam !   enddo ! !   ! Compute spanwise elemental circulation of edge panels !   do ic = 1, this%nc !     gamElementSpan(ic, 1) = this%wiP(ic, 1)%vr%gam !   enddo !   do is = 2, this%ns !     gamElementSpan(1, is) = this%wiP(1, is)%vr%gam & !       & -this%wiP(1, is - 1)%vr%gam !   enddo ! !   ! Compute chordwise and spanwise elemental circulations of inner panels !   do is = 2, this%ns !     do ic = 2, this%nc !       gamElementChord(ic, is) = this%wiP(ic, is)%vr%gam - this%wiP(ic - 1, is)%vr%gam !       gamElementSpan(ic, is) = this%wiP(ic, is)%vr%gam - this%wiP(ic, is - 1)%vr%gam !     enddo !   enddo ! !   ! Invert gamma sign for correct computation !   gamElementSpan = -1._dp*gamElementSpan !   gamElementChord = -1._dp*gamElementChord ! !   ! Compute delP !   do is = 1, this%ns !     do ic = 1, this%nc !       ! Use trapezoidal rule on two points to get current gam !       ! for computing unsteady lift part !       if (ic > 1) then !         this%wiP(ic, is)%gamTrapz = -0.5_dp*(this%wiP(ic, is)%vr%gam + this%wiP(ic - 1, is)%vr%gam) !       else !         this%wiP(1, is)%gamTrapz = -0.5_dp*this%wiP(1, is)%vr%gam !       endif ! !       ! For checking against Katz's fixed wing code uncomment this !       ! velTangentialChord(ic,is)=10._dp*cos(5._dp*degToRad) !       ! velTangentialSpan(ic,is)=0._dp ! !       ! -1.0 multiplied to invert sign of gamma !       this%wiP(ic, is)%delPUnsteady = density * & !         & (this%wiP(ic, is)%gamTrapz - this%wiP(ic, is)%gamPrev)/dt ! !       this%wiP(ic, is)%delP = this%wiP(ic, is)%delPUnsteady + & !         & density*velTangentialChord(ic, is)* & !         & gamElementChord(ic, is) / this%wiP(ic, is)%meanChord ! !       if (this%spanwiseLiftSwitch .ne. 0) then !         this%wiP(ic, is)%delP = this%wiP(ic, is)%delP + density * & !           & velTangentialSpan(ic, is)* & !           & gamElementSpan(ic, is) / this%wiP(ic, is)%meanSpan !       endif ! !       ! -1.0 multiplied to invert sign of gamma !       this%wiP(ic, is)%gamPrev = this%wiP(ic, is)%gamTrapz ! !       ! Compute induced drag !       ! velInduced in either direction doesnt change drag direction !       this%wiP(ic, is)%delDiConstant = density*abs(velInduced(ic, is))* & !         & abs(gamElementChord(ic, is))*this%wiP(ic, is)%meanSpan !       this%wiP(ic, is)%delDiUnsteady = this%wiP(ic, is)%delPUnsteady* & !         & this%wiP(ic, is)%panelArea * & !         & dot_product(this%wiP(ic, is)%nCap, unitVec(this%wiP(ic, is)%velCPm)) ! !       ! Invert direction of normalForce according to sign of omega and collective pitch !       ! This will be incorrect for cambered airfoils in the region !       ! where alpha is -ve but lift is +ve !       this%wiP(ic, is)%normalForce = this%wiP(ic, is)%delP* & !         & this%wiP(ic, is)%panelArea*this%wiP(ic, is)%nCap*invertGammaSign ! !       this%wiP(ic, is)%normalForceUnsteady = this%wiP(ic, is)%delPUnsteady* & !         & this%wiP(ic, is)%panelArea*this%wiP(ic, is)%nCap*invertGammaSign ! !       this%secForceInertial(:, is) = this%secForceInertial(:, is) + this%wiP(ic, is)%normalForce ! !       this%secLift(:, is) = this%secLift(:, is) + projVec(this%wiP(ic, is)%normalForce, & !         this%secLiftDir(:, is)) !       this%secLiftUnsteady(:, is) = this%secLiftUnsteady(:, is) + & !         & projVec(this%wiP(ic, is)%normalForceUnsteady, this%secLiftDir(:, is)) !     enddo !     this%secDragInduced(:, is) = this%secDragDir(:, is)* & !       sum(this%wiP(:, is)%delDiConstant + this%wiP(:, is)%delDiUnsteady) !     ! Drag unsteady is purely for monitoring purposes if required !     ! and is not used for computations anywhere !     this%secDragUnsteady(:, is) = this%secDragDir(:, is)* & !       sum(this%wiP(:, is)%delDiUnsteady) !   enddo ! !   ! To overwrite unit vectors previously assigned in main.f90 !   this%secDragProfile = 0._dp ! !   this%secDrag = this%secDragInduced + this%secDragProfile ! !   ! Compute sectional coefficients !   ! Compute secChordwiseResVel for calculating secDynamicPressure !   ! including induced velocities !   call this%calc_secChordwiseResVel() ! !   secDynamicPressure = this%getSecDynamicPressure(density) ! !   do is = 1, this%ns !     if (abs(secDynamicPressure(is)) > eps) then !       ! Use sign of delP to obtain sign of CL !       signSecCL = sign(1._dp, sum(this%wiP(:, is)%delP)) !       this%secCL(is) = norm2(this%secLift(:, is))*signSecCL/ & !         & (secDynamicPressure(is)*this%secArea(is)) !       this%secCD(is) = norm2(this%secDrag(:, is))/ & !         & (secDynamicPressure(is)*this%secArea(is)) !       this%secCLu(is) = norm2(this%secLiftUnsteady(:, is))*signSecCL/ & !         & (secDynamicPressure(is)*this%secArea(is)) !       this%secMflap(is) = norm2(this%secLift(:, is))*signSecCL* & !         & this%secMflapArm(is) !     else !       this%secCL(is) = 0._dp !       this%secCD(is) = 0._dp !       this%secCLu(is) = 0._dp !       this%secMflap(is) = 0._dp !     endif !   enddo ! !   call this%sumSecToNetForces() ! ! end subroutine blade_calc_force_gamma function blade_getSecDynamicPressure ( this , density ) class ( blade_class ), intent ( in ) :: this real ( dp ), intent ( in ) :: density real ( dp ), dimension ( this % ns ) :: magsecVelCPTotal real ( dp ), dimension ( this % ns ) :: blade_getSecDynamicPressure integer :: is do is = 1 , this % ns magsecVelCPTotal ( is ) = norm2 ( this % secChordwiseResVel (:, is )) enddo blade_getSecDynamicPressure = 0.5_dp * density * magsecVelCPTotal ** 2._dp end function blade_getSecDynamicPressure subroutine calc_secArea ( this ) class ( blade_class ), intent ( inout ) :: this integer :: is do is = 1 , this % ns this % secArea ( is ) = sum ( this % wiP (:, is )% panelArea ) enddo end subroutine calc_secArea subroutine calc_secChord ( this ) class ( blade_class ), intent ( inout ) :: this integer :: is do is = 1 , this % ns this % secChord ( is ) = norm2 ( 0.5_dp * ( & & ( this % wiP ( 1 , is )% PC (:, 1 ) + this % wiP ( 1 , is )% PC (:, 4 )) - & & ( this % wiP ( this % nc , is )% PC (:, 2 ) + this % wiP ( this % nc , is )% PC (:, 3 )))) enddo end subroutine calc_secChord subroutine blade_calc_force_alpha ( this , density , velSound ) !! Compute force using sectional alpha class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: density , velSound call this % lookup_secCoeffs ( velSound ) call this % secCoeffsTosecForces ( density ) ! To overwrite unit vectors previously assigned in main.f90 this % secDragInduced = 0._dp this % secDrag = this % secDragProfile + this % secDragInduced call this % sumSecToNetForces () end subroutine blade_calc_force_alpha subroutine blade_calc_force_alphaGamma ( this , density , & & invertGammaSign , velSound , dt ) !! Compute force using alpha approximated from sec circulation use libMath , only : unitVec , cross_product , noProjVec class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: density , invertGammaSign , velSound , dt real ( dp ), dimension ( 3 ) :: liftDir real ( dp ), dimension ( this % ns ) :: secDynamicPressure integer :: is ! Compute unsteady sec lift from gamma distribution call this % calc_force ( density , invertGammaSign , dt ) secDynamicPressure = this % getSecDynamicPressure ( density ) do is = 1 , this % ns ! Extract sectional lift and CL liftDir = cross_product ( this % secChordwiseResVel (:, is ), this % yAxis ) ! Assuming gamma method only gives lift this % secCL ( is ) = dot_product ( this % secForceInertial (:, is ), & unitVec ( liftDir )) / ( secDynamicPressure ( is ) * this % secArea ( is )) ! Compute angle of attack from linear CL this % secArea ( is ) = this % secCL ( is ) / twoPi + & & this % alpha0 ( this % airfoilNo ( is )) enddo this % secCLu = 0._dp ! Compute non-linear CL call this % lookup_secCoeffs ( velSound ) call this % secCoeffsToSecForces ( density ) this % secDrag = this % secDragInduced + this % secDragProfile call this % sumSecToNetForces () end subroutine blade_calc_force_alphaGamma subroutine blade_secCoeffsToSecForces ( this , density ) !! Convert force coefficients to dimensional forces use libMath , only : unitVec , cross_product , lsq2 class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: density integer :: is real ( dp ), dimension ( this % ns ) :: leadingTerm leadingTerm = this % getSecDynamicPressure ( density ) * this % secArea do is = 1 , this % ns ! Lift and Drag vectors this % secLift (:, is ) = & & this % secLiftDir (:, is ) * leadingTerm ( is ) * this % secCL ( is ) ! this%secDragProfile(:, is) = & !   & this%secDragDir(:, is)*leadingTerm(is)*this%secCD(is) this % secLiftUnsteady (:, is ) = & & this % secLiftDir (:, is ) * leadingTerm ( is ) * this % secCLu ( is ) ! Lift in inertial frame this % secForceInertial (:, is ) = cross_product ( this % yAxis , & this % secChordwiseResVel (:, is )) this % secForceInertial (:, is ) = sign ( 1._dp , sum ( this % wiP (:, is )% vr % gam )) & * unitVec ( this % secForceInertial (:, is )) ! abs() used since direction is already captured in vector this % secForceInertial (:, is ) = norm2 ( this % secLift (:, is )) * & this % secForceInertial (:, is ) ! Drag in inertial frame this % secForceInertial (:, is ) = this % secForceInertial (:, is ) + & norm2 ( this % secDrag (:, is )) * unitVec ( this % secChordwiseResVel (:, is )) enddo end subroutine blade_secCoeffsToSecForces subroutine blade_lookup_secCoeffs ( this , velSound ) use libC81 , only : getCL , getCD ! Compute sec CL, CD, CM from C81 tables and sec resultant velocity ! Assumes only one airfoil section present class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: velSound real ( dp ) :: secMach , alphaDeg integer :: is do is = 1 , size ( this % secAlpha , 1 ) secMach = norm2 ( this % secChordwiseResVel (:, is )) / velSound alphaDeg = this % secAlpha ( is ) * radToDeg this % secCL ( is ) = this % C81 ( this % airfoilNo ( is ))% getCL ( alphaDeg , secMach ) this % secCD ( is ) = this % C81 ( this % airfoilNo ( is ))% getCD ( alphaDeg , secMach ) this % secCM ( is ) = this % C81 ( this % airfoilNo ( is ))% getCM ( alphaDeg , secMach ) enddo this % secCLu = 0._dp end subroutine blade_lookup_secCoeffs subroutine blade_calc_secChordwiseResVel ( this ) !! Compute sectional resultant vel by interpolating local panel vel use libMath , only : lsq2 class ( blade_class ), intent ( inout ) :: this integer :: i , is , ic real ( dp ), dimension ( this % nc ) :: xDist if ( this % nc . ge . 3 ) then ! Use least squares fit to get sec resultant velocity do is = 1 , size ( this % secChordwiseResVel , 2 ) do ic = 1 , this % nc call this % wiP ( ic , is )% calc_chordwiseResVel () xDist ( ic ) = dot_product ( this % wiP ( ic , is )% CP & & - this % wiP ( 1 , is )% PC (:, 1 ), & & this % secTauCapChord (:, is )) enddo do i = 1 , 3 this % secChordwiseResVel ( i , is ) = lsq2 ( dot_product ( this % secCP (:, is ) & & - this % wiP ( 1 , is )% PC (:, 1 ), this % secTauCapChord (:, is )), xDist , & this % wiP (:, is )% chordwiseResVel ( i )) enddo enddo else ! Use average of resultant velocities ! Check if this requires to be area weighted average do is = 1 , size ( this % secChordwiseResVel , 2 ) do ic = 1 , this % nc call this % wiP ( ic , is )% calc_chordwiseResVel () enddo do i = 1 , 3 this % secChordwiseResVel ( i , is ) = & & sum ( this % wiP (:, is )% chordwiseResVel ( i )) / this % nc enddo enddo endif end subroutine blade_calc_secChordwiseResVel subroutine blade_calc_secAlpha ( this , verticalAxis ) !! Compute sec alpha using sec resultant velocity use libMath , only : getAngleTan , noProjVec class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: verticalAxis real ( dp ), dimension ( 3 ) :: secVi integer :: is call this % calc_secChordwiseResVel () ! Use atan2() to find angle do is = 1 , size ( this % secAlpha ) this % secAlpha ( is ) = & & atan2 ( dot_product ( this % secChordwiseResVel (:, is ), & & this % secNormalVec (:, is )), & & dot_product ( this % secChordwiseResVel (:, is ), & & this % secTauCapChord (:, is ))) ! This assumes no pitching velocity this % secPhi ( is ) = & & getAngleTan ( this % secChordwiseResVel (:, is ), & & noProjVec ( this % wiP ( 1 , is )% velCPm , this % secTauCapSpan (:, is ))) secVi = this % secChordwiseResVel (:, is ) - this % wiP ( 1 , is )% velCPm this % secViz ( is ) = secVi ( 3 ) this % secVix ( is ) = norm2 ( noProjVec ( secVi , this % secTauCapSpan (:, is )) - & & [ 0._dp , 0._dp , secVi ( 3 )]) this % secTheta ( is ) = pi * 0.5 - getAngleTan ( & & - 1._dp * this % secTauCapChord (:, is ), verticalAxis ) enddo end subroutine blade_calc_secAlpha subroutine blade_calc_secLocations ( this , chordwiseFraction , flapHingeRadius ) !! Compute important locations at each section !! coordinates of collocation point located at chord fraction !! flap moment arm use libMath , only : projVec , pwl_interp1d class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: chordwiseFraction , flapHingeRadius real ( dp ), dimension ( 2 , this % nc + 1 ) :: xzCoord ! Along and normal to chord real ( dp ), dimension ( 3 ) :: vecPC , vecLE real ( dp ), dimension ( 2 ) :: xzCP integer :: is , ic do is = 1 , this % ns vecLE = 0.5_dp * ( this % wiP ( 1 , is )% PC (:, 1 ) + this % wiP ( 1 , is )% PC (:, 4 )) xzCoord (:, 1 ) = 0._dp do ic = 1 , this % nc ! Find vector from leading edge to panel edge midpoint vecPC = 0.5_dp * ( this % wiP ( ic , is )% PC (:, 2 ) + this % wiP ( ic , is )% PC (:, 3 )) & & - vecLE ! Find components along and normal to chordwise vector xzCoord ( 1 , ic + 1 ) = norm2 ( projVec ( vecPC , this % secTauCapChord (:, is ))) xzCoord ( 2 , ic + 1 ) = dot_product ( vecPC , this % secNormalVec (:, is )) enddo ! Get distance along chord for secCP xzCP ( 1 ) = norm2 ( vecPC ) * chordwiseFraction ! Use piecewise linear interpolation to obtain camber xzCP ( 2 ) = pwl_interp1d ( xzCoord ( 1 , :), xzCoord ( 2 , :), xzCP ( 1 )) ! Find actual coordinate of xzCP this % secCP (:, is ) = vecLE + xzCP ( 1 ) * this % secTauCapChord (:, is ) + & & xzCP ( 2 ) * this % secNormalVec (:, is ) ! Find flapping moment arm this % secMflapArm ( is ) = norm2 ( projVec ( this % secCP (:, is ), this % yAxis )) - & & flapHingeRadius enddo end subroutine blade_calc_secLocations subroutine blade_burst_wake ( this , rowFar , skewLimit , largeCoreRadius ) use libMath , only : getAngleCos class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: skewLimit integer , intent ( in ) :: rowFar !, rowNear real ( dp ), intent ( in ) :: largeCoreRadius integer :: irow !, icol real ( dp ) :: skewVal ! Burst near wake !do icol=1,size(this%waN,2) !  do irow=rowNear,size(this%waN,1) !    call this%waN(irow,icol)%vr%burst(skewLimit) !  enddo !enddo ! Burst far wake if ( rowFar . le . size ( this % waF , 1 )) then do irow = rowFar , size ( this % waF , 1 ) - 1 ! NEGLECT ALREADY BURST FILAMENTS IF NECCESSARY !if (abs(this%waF(irow+1)%gam) > eps .and. abs(this%waF(irow)%gam) > eps) then skewVal = abs ( getAngleCos ( this % waF ( irow )% vf % fc (:, 2 ) - this % waF ( irow )% vf % fc (:, 1 ) & , this % waF ( irow + 1 )% vf % fc (:, 1 ) - this % waF ( irow + 1 )% vf % fc (:, 2 ) & ) - pi ) / pi if ( skewVal . ge . skewLimit ) then !this%waF(irow+1)%gam = 0._dp !this%waF(irow)%gam = 0._dp this % waF ( irow + 1 )% vf % rVc = largeCoreRadius this % waF ( irow )% vf % rVc = largeCoreRadius endif !endif enddo endif end subroutine blade_burst_wake subroutine blade_calc_skew ( this , rowNear ) class ( blade_class ), intent ( inout ) :: this integer , intent ( in ) :: rowNear integer :: irow , icol !$omp parallel do collapse(2) do icol = 1 , size ( this % waN , 2 ) do irow = rowNear , size ( this % waN , 1 ) call this % waN ( irow , icol )% vr % calc_skew () enddo enddo !$omp end parallel do end subroutine blade_calc_skew subroutine blade_dirLiftDrag ( this , Omega ) !! Compute lift and drag direction vectors use libMath , only : unitVec , cross_product class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: Omega integer :: is do is = 1 , this % ns this % secDragDir (:, is ) = unitVec ( this % secChordwiseResVel (:, is )) this % secLiftDir (:, is ) = sign ( 1._dp , Omega ) * unitVec ( & & cross_product ( this % secDragDir (:, is ), this % yAxisAziFlap )) enddo end subroutine blade_dirLiftDrag subroutine blade_sumSecToNetForces ( this ) !! Sum up sectional forces to net forces class ( blade_class ), intent ( inout ) :: this this % forceInertial = sum ( this % secForceInertial , 2 ) this % lift = sum ( this % secLift , 2 ) this % drag = sum ( this % secDrag , 2 ) this % liftUnsteady = sum ( this % secLiftUnsteady , 2 ) this % dragProfile = sum ( this % secDragProfile , 2 ) this % dragInduced = sum ( this % secDragInduced , 2 ) this % dragUnsteady = sum ( this % secDragUnsteady , 2 ) this % MflapLift = sum ( this % secMflap ) end subroutine blade_sumSecToNetForces subroutine blade_calc_stlStats ( this ) class ( blade_class ), intent ( inout ) :: this real ( dp ), dimension ( 3 ) :: vertex integer :: icell , ivertex , irow logical :: isNewVertex ! Dummy arrays real ( dp ), allocatable , dimension (:, :) :: stlNodes ! Naive allocations allocate ( stlNodes ( 3 , this % nc * 3 )) allocate ( this % stlElementNodes ( 3 , this % nc )) this % stlNodesCols = 0 do icell = 1 , this % nc do ivertex = 1 , 3 vertex = this % wiP ( icell , 1 )% PC (:, ivertex ) ! Check if vertex is present in vertices array isNewVertex = . true . do irow = 1 , this % stlNodesCols if ( all ( abs ( stlNodes (:, irow ) - vertex ) < eps )) then isNewVertex = . false . exit endif enddo if ( isNewVertex ) then ! Record to vertices array this % stlNodesCols = this % stlNodesCols + 1 stlNodes (:, this % stlNodesCols ) = vertex endif enddo enddo allocate ( this % stlNodes ( 3 , this % stlNodesCols )) this % stlNodes = stlNodes (:, 1 : this % stlNodesCols ) ! Deallocate dummy arrays deallocate ( stlNodes ) ! For each element find the 3 node indices in stlNodes array do icell = 1 , this % nc do ivertex = 1 , 3 vertex = this % wiP ( icell , 1 )% PC (:, ivertex ) do irow = 1 , this % stlNodesCols if ( all ( abs ( this % stlNodes (:, irow ) - vertex ) < eps )) then ! Record row number this % stlElementNodes ( ivertex , icell ) = irow exit endif enddo enddo enddo end subroutine blade_calc_stlStats function getddflap ( this , flap , dflap , omega , MflapLift ) !! Returns ddflap from blade flap equation class ( blade_class ), intent ( in ) :: this real ( dp ), intent ( in ) :: flap , dflap , omega , MflapLift real ( dp ) :: getddflap getddflap = ( MflapLift + this % MflapConstant - this % cflap * dflap - & & ( this % Iflap * omega ** 2._dp + this % kflap ) * ( flap - this % preconeAngle )) / this % Iflap end function getddflap subroutine blade_computeBladeDynamics ( this , dt , omega ) class ( blade_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt , omega real ( dp ) :: flapPred , dflapPred , flapNew , dflapNew ! Blade flap dynamics ! AM2 predictor corrector ! Predictor step dflapPred = this % dflap + 0.5_dp * dt * & & ( 3._dp * this % getddflap ( this % flap , this % dflap , omega , this % MflapLift ) - & & this % getddflap ( this % flapPrev , this % dflapPrev , omega , this % MflapLiftPrev )) flapPred = this % flap + 0.5_dp * dt * & & ( 3._dp * this % dflap - this % dflapPrev ) ! Assumption is made that the flap moment does not vary at the ! predicted flap angle ! Corrector step dflapNew = this % dflap + 0.5_dp * dt * & & ( this % getddflap ( flapPred , dflapPred , omega , this % MflapLift ) + & & this % getddflap ( this % flap , this % dflap , omega , this % MflapLift )) flapNew = this % flap + 0.5_dp * dt * & & ( dflapPred + this % dflap ) this % dflapPrev = this % dflap this % flapPrev = this % flap this % dflap = dflapNew this % flap = flapNew end subroutine blade_computeBladeDynamics subroutine blade_write ( this , unit , iostat , iomsg ) class ( blade_class ), intent ( in ) :: this integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg write ( unit , iostat = iostat , iomsg = iomsg ) this % id , this % wiP , & & this % waN , this % waF , & & this % waNPredicted , this % waFPredicted , & & this % theta , this % psi , & & this % forceInertial , this % lift , this % liftUnsteady , & & this % drag , this % dragInduced , this % dragProfile , this % dragUnsteady , & & this % velNwake , this % velNwake1 , this % velNwake2 , this % velNwake3 , & & this % velNwakePredicted , this % velNwakeStep , & & this % velFwake , this % velFwake1 , this % velFwake2 , this % velFwake3 , & & this % velFwakePredicted , this % velFwakeStep , & & this % xAxis , this % yAxis , this % zAxis , & & this % secChord , this % secArea , & & this % secForceInertial , this % secLift , this % secDrag , & & this % secLiftDir , this % secDragDir , & & this % secDragInduced , this % secDragProfile , & & this % secLiftUnsteady , this % secDragUnsteady , & & this % secTauCapChord , this % secTauCapSpan , & & this % secNormalVec , & & this % secChordwiseResVel , this % secCP , & & this % secAlpha , this % secPhi , this % secCL , this % secCD , this % secCM , & & this % secCLu , this % alpha0 end subroutine blade_write subroutine blade_read ( this , unit , iostat , iomsg ) class ( blade_class ), intent ( inout ) :: this integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg read ( unit , iostat = iostat , iomsg = iomsg ) this % id , this % wiP , & & this % waN , this % waF , & & this % waNPredicted , this % waFPredicted , & & this % theta , this % psi , & & this % forceInertial , this % lift , this % liftUnsteady , & & this % drag , this % dragInduced , this % dragProfile , this % dragUnsteady , & & this % velNwake , this % velNwake1 , this % velNwake2 , this % velNwake3 , & & this % velNwakePredicted , this % velNwakeStep , & & this % velFwake , this % velFwake1 , this % velFwake2 , this % velFwake3 , & & this % velFwakePredicted , this % velFwakeStep , & & this % xAxis , this % yAxis , this % zAxis , & & this % secChord , this % secArea , & & this % secForceInertial , this % secLift , this % secDrag , & & this % secLiftDir , this % secDragDir , & & this % secDragInduced , this % secDragProfile , & & this % secLiftUnsteady , this % secDragUnsteady , & & this % secTauCapChord , this % secTauCapSpan , & & this % secNormalVec , & & this % secChordwiseResVel , this % secCP , & & this % secAlpha , this % secPhi , this % secCL , this % secCD , this % secCM , & & this % secCLu , this % alpha0 end subroutine blade_read !------+-- ! ++++ | rotor_class Methods !------+-- subroutine rotor_readGeom ( this , filename , outputFilename ) !! Read rotor geometry from geomXX.nml in namelist format class ( rotor_class ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), optional , intent ( in ) :: outputFilename character ( len = 10 ) :: fileFormatVersion , currentTemplateVersion ! Namelist variables integer :: surfaceType , imagePlane , imageRotorNum , nb , propConvention , & & spanSpacing , chordSpacing , nCamberFiles , nc , ns , nNwake , nAirfoils real ( dp ), allocatable , dimension (:) :: camberSectionLimit character ( len = 30 ), allocatable , dimension (:) :: camberFile , airfoilFile character ( len = 30 ) :: geometryFile real ( dp ), dimension ( 3 ) :: hubCoords , cgCoords , fromCoords , phiThetaPsi , & & shaftAxis , velBody , omegaBody real ( dp ) :: span , rootcut , chord , preconeAngle , Omega , & & theta0 , thetaC , thetaS , thetaTwist , pivotLE , flapHinge integer :: spanwiseLiftSwitch , symmetricTau , axisymmetrySwitch , & & customTrajectorySwitch , forceCalcSwitch , wakeTruncateNt , & & prescWakeAfterTruncNt , prescWakeGenNt real ( dp ) :: apparentViscCoeff , decayCoeff , spanwiseCore , & & rollupStartRadius , rollupEndRadius , initWakeVel , psiStart , skewLimit real ( dp ), allocatable , dimension (:) :: streamwiseCoreVec integer :: bladeDynamicsSwitch , pitchDynamicsSwitch real ( dp ) :: flapInitial , dflapInitial , & & Iflap , cflap , kflap , MflapConstant , dpitch integer :: bodyDynamicsSwitch , bodyDynamicsIOVars real ( dp ), dimension ( 3 ) :: dragUnitVec , sideUnitVec , liftUnitVec integer :: inflowPlotSwitch , gammaPlotSwitch , skewPlotSwitch real ( dp ), allocatable , dimension (:) :: airfoilSectionLimit , alpha0 ! Namelists namelist / VERSION / fileFormatVersion namelist / SURFACE / surfaceType , imagePlane , imageRotorNum namelist / PANELS / nb , propConvention , spanSpacing , chordSpacing , & & geometryFile , nCamberFiles , nc , ns , nNwake namelist / CAMBERSECTIONS / camberSectionLimit , camberFile namelist / ORIENT / hubCoords , cgCoords , fromCoords , phiThetaPsi namelist / GEOMPARAMS / span , rootcut , chord , preconeAngle , Omega , & & shaftAxis , theta0 , thetaC , thetaS , thetaTwist , axisymmetrySwitch , & & pivotLE , flapHinge , spanwiseLiftSwitch , symmetricTau , & & customTrajectorySwitch , velBody , omegaBody , forceCalcSwitch , & & nAirfoils namelist / WAKEPARAMS / apparentViscCoeff , decayCoeff , wakeTruncateNt , & & prescWakeAfterTruncNt , prescWakeGenNt , spanwiseCore , & & streamwiseCoreVec , rollupStartRadius , & & rollupEndRadius , initWakeVel , psiStart , skewLimit namelist / DYNAMICS / bladeDynamicsSwitch , flapInitial , dflapInitial , & & Iflap , cflap , kflap , MflapConstant , pitchDynamicsSwitch , dpitch , & & bodyDynamicsSwitch , bodyDynamicsIOVars namelist / WINDFRAME / dragUnitVec , sideUnitVec , liftUnitVec namelist / PLOTS / inflowPlotSwitch , gammaPlotSwitch , skewPlotSwitch namelist / AIRFOILS / airfoilSectionLimit , alpha0 , airfoilFile currentTemplateVersion = '0.14' open ( unit = 12 , file = filename , status = 'old' , action = 'read' ) read ( unit = 12 , nml = VERSION ) if ( adjustl ( fileFormatVersion ) /= currentTemplateVersion ) then error stop \"ERROR: geomXX.in template version does not match\" endif read ( unit = 12 , nml = SURFACE ) read ( unit = 12 , nml = PANELS ) if ( this % nCamberFiles > 0 ) then allocate ( camberSectionLimit ( nCamberFiles )) allocate ( camberFile ( nCamberFiles )) else allocate ( camberSectionLimit ( 1 )) allocate ( camberFile ( 1 )) endif read ( unit = 12 , nml = CAMBERSECTIONS ) read ( unit = 12 , nml = ORIENT ) read ( unit = 12 , nml = GEOMPARAMS ) allocate ( streamwiseCoreVec ( ns + 1 )) read ( unit = 12 , nml = WAKEPARAMS ) read ( unit = 12 , nml = DYNAMICS ) read ( unit = 12 , nml = WINDFRAME ) read ( unit = 12 , nml = PLOTS ) if ( nAirfoils . gt . 0 ) then allocate ( airfoilSectionLimit ( nAirfoils )) allocate ( airfoilFile ( nAirfoils )) allocate ( alpha0 ( nAirfoils )) read ( unit = 12 , nml = AIRFOILS ) endif close ( 12 ) ! Write a copy of geom file that was read if ( present ( outputFilename )) then open ( unit = 14 , file = outputFilename , status = 'replace' , action = 'write' ) write ( unit = 14 , nml = VERSION ) write ( unit = 14 , nml = SURFACE ) write ( unit = 14 , nml = PANELS ) write ( unit = 14 , nml = CAMBERSECTIONS ) write ( unit = 14 , nml = ORIENT ) write ( unit = 14 , nml = GEOMPARAMS ) write ( unit = 14 , nml = WAKEPARAMS ) write ( unit = 14 , nml = DYNAMICS ) write ( unit = 14 , nml = WINDFRAME ) write ( unit = 14 , nml = PLOTS ) close ( 14 ) endif ! Set all variables to required values ! [0/1]Lifting [2]Non-lifting [-1]Lifting Image [-2]Non-lifting Image this % surfaceType = surfaceType this % imagePlane = imagePlane this % imageRotorNum = imageRotorNum this % nb = nb this % propConvention = propConvention this % spanSpacing = spanSpacing this % chordSpacing = chordSpacing this % geometryFile = geometryFile this % nCamberFiles = nCamberFiles this % nc = nc this % ns = ns this % nNwake = nNwake ! Read other parameters only if non-mirrored type geometry ! If mirrored, all parameters are computed from source geometry if ( this % surfaceType . ge . 0 ) then if ( this % nCamberFiles > 0 ) then allocate ( this % camberSectionLimit ( this % nCamberFiles )) allocate ( this % camberFile ( this % nCamberFiles )) this % camberSectionLimit = camberSectionLimit this % camberFile = camberFile else allocate ( this % camberSectionLimit ( 1 )) allocate ( this % camberFile ( 1 )) ! Default uncambered section this % camberSectionLimit = 1.0 this % camberFile = '0' endif this % hubCoords = hubCoords this % cgCoords = cgCoords this % fromCoords = fromCoords this % pts = phiThetaPsi this % radius = span this % root_cut = rootcut this % chord = chord this % preconeAngle = preconeAngle this % Omega = Omega this % shaftAxis = shaftAxis this % controlPitch = [ theta0 , thetaC , thetaS ] this % thetaTwist = thetaTwist this % axisymmetrySwitch = axisymmetrySwitch this % pivotLE = pivotLE this % flapHinge = flapHinge this % spanwiseLiftSwitch = spanwiseLiftSwitch this % symmetricTau = symmetricTau this % customTrajectorySwitch = customTrajectorySwitch this % velBody = velBody this % omegaBody = omegaBody this % forceCalcSwitch = forceCalcSwitch this % nAirfoils = nAirfoils allocate ( this % streamwiseCoreVec ( this % ns + 1 )) this % apparentViscCoeff = apparentViscCoeff this % decayCoeff = decayCoeff this % wakeTruncateNt = wakeTruncateNt this % prescWakeAfterTruncNt = prescWakeAfterTruncNt this % prescWakeGenNt = prescWakeGenNt this % spanwiseCore = spanwiseCore if ( norm2 ( streamwiseCoreVec ( 2 :)) < eps ) then this % streamwiseCoreVec = streamwiseCoreVec ( 1 ) else this % streamwiseCoreVec = streamwiseCoreVec endif this % rollupStartRadius = rollupStartRadius this % rollupEndRadius = rollupEndRadius this % initWakeVel = initWakeVel this % psiStart = psiStart this % skewLimit = skewLimit this % bladeDynamicsSwitch = bladeDynamicsSwitch this % flapInitial = flapInitial this % dflapInitial = dflapInitial this % Iflap = Iflap this % cflap = cflap this % kflap = kflap this % MflapConstant = MflapConstant this % pitchDynamicsSwitch = pitchDynamicsSwitch this % dpitch = dpitch this % bodyDynamicsSwitch = bodyDynamicsSwitch this % bodyDynamicsIOVars = bodyDynamicsIOVars this % dragUnitVec = dragUnitVec this % sideUnitVec = sideUnitVec this % liftUnitVec = liftUnitVec this % inflowPlotSwitch = inflowPlotSwitch this % gammaPlotSwitch = gammaPlotSwitch this % skewPlotSwitch = skewPlotSwitch ! Ensure airfoil tables are provided when force calculation requires them if ( this % forceCalcSwitch . gt . 0 . and . this % nAirfoils . eq . 0 ) then error stop 'ERROR: No. of airfoil tables set to 0 in geomXX.in' endif if ( this % nAirfoils . gt . 0 ) then allocate ( this % airfoilSectionLimit ( this % nAirfoils )) allocate ( this % airfoilFile ( this % nAirfoils )) allocate ( this % alpha0 ( this % nAirfoils )) this % airfoilSectionLimit = airfoilSectionLimit this % alpha0 = alpha0 this % airfoilFile = airfoilFile endif endif end subroutine rotor_readGeom subroutine rotor_init ( this , rotorNumber , density , dt , nt , & & switches , sourceRotor ) !! Initialize variables of rotor geometry and wake use libMath class ( rotor_class ) :: this integer , intent ( in ) :: rotorNumber real ( dp ), intent ( in ) :: density real ( dp ) , intent ( inout ) :: dt integer , intent ( inout ) :: nt type ( switches_class ), intent ( inout ) :: switches type ( rotor_class ), optional :: sourceRotor real ( dp ), dimension ( this % nc + 1 ) :: xVec real ( dp ), dimension ( this % ns + 1 ) :: yVec real ( dp ), dimension ( this % nc + 1 , this % ns + 1 ) :: zVec real ( dp ), dimension ( this % nc , this % ns ) :: dx , dy real ( dp ), dimension ( 3 ) :: leftTipCP real ( dp ) :: dxdymin , secCPLoc , rbyR , dxMAC integer :: i , j , ib , is , ic real ( dp ) :: bladeOffset real ( dp ) :: velShed real ( dp ), dimension ( 4 ) :: xshift ! Set id write ( this % id , '(I0.2)' ) rotorNumber ! Get parameters from source rotor if mirrored if ( this % surfaceType . lt . 0 ) then this % nb = sourceRotor % nb this % propConvention = sourceRotor % propConvention this % spanSpacing = sourceRotor % spanSpacing this % chordSpacing = sourceRotor % chordSpacing this % nCamberFiles = sourceRotor % nCamberFiles ! Geometry file has to still be manually input ! this%geometryFile = sourceRotor%geometryFile if ( this % nCamberFiles > 0 ) then allocate ( this % camberSectionLimit ( this % nCamberFiles )) allocate ( this % camberFile ( this % nCamberFiles )) do i = 1 , this % nCamberFiles this % camberSectionLimit ( i ) = sourceRotor % camberSectionLimit ( i ) this % camberFile ( i ) = sourceRotor % camberFile ( i ) enddo else allocate ( this % camberSectionLimit ( 1 )) allocate ( this % camberFile ( 1 )) ! Default uncambered section this % camberSectionLimit = 1.0 this % camberFile = '0' endif this % nc = sourceRotor % nc this % ns = sourceRotor % ns this % nNwake = sourceRotor % nNwake this % hubCoords = sourceRotor % hubCoords this % cgCoords = sourceRotor % cgCoords this % fromCoords = sourceRotor % fromCoords this % hubCoords ( this % imagePlane ) = - 1._dp * this % hubCoords ( this % imagePlane ) this % cgCoords ( this % imagePlane ) = - 1._dp * this % cgCoords ( this % imagePlane ) this % pts = sourceRotor % pts this % radius = sourceRotor % radius this % root_cut = sourceRotor % root_cut this % chord = sourceRotor % chord this % preconeAngle = sourceRotor % preconeAngle this % Omega = sourceRotor % Omega this % shaftAxis = sourceRotor % shaftAxis this % xAxisBody = sourceRotor % xAxisBody this % yAxisBody = sourceRotor % yAxisBody this % zAxisBody = sourceRotor % zAxisBody this % controlPitch = sourceRotor % controlPitch this % thetaTwist = sourceRotor % thetaTwist this % customTrajectorySwitch = sourceRotor % customTrajectorySwitch this % axisymmetrySwitch = sourceRotor % axisymmetrySwitch this % velBody = sourceRotor % velBody this % omegaBody = sourceRotor % omegaBody this % pivotLE = sourceRotor % pivotLE this % flapHinge = sourceRotor % flapHinge this % spanwiseLiftSwitch = sourceRotor % spanwiseLiftSwitch this % symmetricTau = sourceRotor % symmetricTau this % apparentViscCoeff = sourceRotor % apparentViscCoeff this % decayCoeff = sourceRotor % decayCoeff this % wakeTruncateNt = sourceRotor % wakeTruncateNt this % prescWakeNt = sourceRotor % prescWakeNt this % prescWakeGenNt = sourceRotor % prescWakeGenNt this % spanwiseCore = sourceRotor % spanwiseCore allocate ( this % streamwiseCoreVec ( this % ns + 1 )) this % streamwiseCoreVec = sourceRotor % streamwiseCoreVec this % rollupStartRadius = sourceRotor % rollupStartRadius this % rollupEndRadius = sourceRotor % rollupEndRadius this % rollupStart = sourceRotor % rollupStart this % rollupEnd = sourceRotor % rollupEnd this % initWakeVel = sourceRotor % initWakeVel this % psiStart = sourceRotor % psiStart this % skewLimit = sourceRotor % skewLimit this % bladeDynamicsSwitch = sourceRotor % bladeDynamicsSwitch this % flapInitial = sourceRotor % flapInitial this % dflapInitial = sourceRotor % dflapInitial this % Iflap = sourceRotor % Iflap this % cflap = sourceRotor % cflap this % kflap = sourceRotor % kflap this % MflapConstant = sourceRotor % MflapConstant this % pitchDynamicsSwitch = sourceRotor % pitchDynamicsSwitch this % dpitch = sourceRotor % dpitch this % dragUnitVec = sourceRotor % dragUnitVec this % sideUnitVec = sourceRotor % sideUnitVec this % liftUnitVec = sourceRotor % liftUnitVec this % inflowPlotSwitch = sourceRotor % inflowPlotSwitch this % gammaPlotSwitch = sourceRotor % gammaPlotSwitch this % skewPlotSwitch = sourceRotor % skewPlotSwitch this % forceCalcSwitch = sourceRotor % forceCalcSwitch this % nAirfoils = sourceRotor % nAirfoils this % bodyDynamicsSwitch = sourceRotor % bodyDynamicsSwitch this % bodyDynamicsIOVars = sourceRotor % bodyDynamicsIOVars if ( this % nAirfoils . gt . 0 ) then allocate ( this % airfoilSectionLimit ( this % nAirfoils )) allocate ( this % airfoilFile ( this % nAirfoils )) allocate ( this % alpha0 ( this % nAirfoils )) this % airfoilSectionLimit = sourceRotor % airfoilSectionLimit this % alpha0 = sourceRotor % alpha0 this % airfoilFile = sourceRotor % airfoilFile endif select case ( this % imagePlane ) case ( 1 ) this % Omega = - 1._dp * this % Omega case ( 2 ) this % Omega = - 1._dp * this % Omega this % psiStart = this % psiStart + pi case ( 3 ) this % controlPitch = - 1._dp * this % controlPitch this % velBody ( 3 ) = - 1._dp * this % velBody ( 3 ) this % omegaBody ( 1 ) = - 1._dp * this % omegaBody ( 1 ) this % omegaBody ( 2 ) = - 1._dp * this % omegaBody ( 2 ) end select if ( this % customTrajectorySwitch == 1 ) then allocate ( this % velBodyHistory ( 3 , nt )) allocate ( this % omegaBodyHistory ( 3 , nt )) this % velBodyHistory = sourceRotor % velBodyHistory this % omegaBodyHistory = sourceRotor % omegaBodyHistory this % velBodyHistory ( this % imagePlane , :) = - 1._dp * & & this % velBodyHistory ( this % imagePlane , :) select case ( this % imagePlane ) case ( 1 ) this % omegaBodyHistory ( 3 , :) = - 1._dp * & & this % omegaBodyHistory ( 3 , :) case ( 2 ) this % omegaBodyHistory ( 3 , :) = - 1._dp * & & this % omegaBodyHistory ( 3 , :) case ( 3 ) this % omegaBodyHistory ( 1 , :) = - 1._dp * & & this % omegaBodyHistory ( 1 , :) this % omegaBodyHistory ( 2 , :) = - 1._dp * & & this % omegaBodyHistory ( 2 , :) end select endif this % xAxisBody ( this % imagePlane ) = - 1._dp * this % xAxisBody ( this % imagePlane ) this % yAxisBody ( this % imagePlane ) = - 1._dp * this % yAxisBody ( this % imagePlane ) this % zAxisBody ( this % imagePlane ) = - 1._dp * this % zAxisBody ( this % imagePlane ) endif ! Warn if all velocities zero for surfaces (with wake) if ( this % nNwake . ne . 0 ) then if ( abs ( this % Omega ) < eps ) then if ( norm2 ( this % velBody ) < eps ) then print * , \"WARNING: All velocity set to zero\" endif endif endif ! Set dt automatically if not prescribed ! if dt is negative, assume no. of chords or revs if ( dsign ( 1._dp , dt ) < 0._dp ) then if ( abs ( this % Omega ) < eps ) then ! Fixed wing dt = abs ( dt ) * this % chord / norm2 ( this % velBody ) else ! Rotor dt = twoPi * abs ( dt ) / abs ( this % Omega ) endif print * , 'dt set to ' , dt endif ! if dt is 0, assume default timesteps if ( abs ( dt ) <= eps ) then if ( abs ( this % Omega ) < eps ) then ! Fixed wing dxMAC = this % chord / this % nc dt = dxMAC / norm2 ( this % velBody ) else ! Rotor ! Time for 5 deg dt = 5._dp * degToRad / abs ( this % Omega ) endif print * , 'dt set to ' , dt endif ! Check if nt requires preprocessing if ( nt . le . 0 ) then if ( nt . eq . 0 ) nt = - 10 call this % toChordsRevs ( nt , dt ) print * , 'nt set to ' , nt endif ! Preprocessing for negative value inputs if ( switches % slowStart /= 0 ) then call this % toChordsRevs ( switches % slowStartNt , dt ) endif call this % toChordsRevs ( switches % wakeTipPlot , dt ) call this % toChordsRevs ( switches % wakePlot , dt ) call this % toChordsRevs ( switches % gridPlot , dt ) call this % toChordsRevs ( this % wakeTruncateNt , dt ) call this % toChordsRevs ( this % prescWakeAfterTruncNt , dt ) call this % toChordsRevs ( this % prescWakeGenNt , dt ) call this % toChordsRevs ( this % nNwake , dt ) call this % toChordsRevs ( this % inflowPlotSwitch , dt ) call this % toChordsRevs ( this % gammaPlotSwitch , dt ) call this % toChordsRevs ( this % skewPlotSwitch , dt ) if ( this % wakeTruncateNt > 0 . and . this % prescWakeAfterTruncNt > 0 ) then this % prescWakeNt = this % wakeTruncateNt + this % prescWakeAfterTruncNt else this % prescWakeNt = 0 endif if ( this % wakeTruncateNt > 0 ) then this % wakeTruncateNt = max ( this % wakeTruncateNt , this % nNwake + 1 ) endif if ( this % surfaceType == 0 ) this % surfaceType = 1 if ( abs ( this % surfaceType ) == 2 ) this % suppressFwakeSwitch = 0 if ( this % nNwake > 0 ) then if ( this % nNwake < 2 ) error stop 'ERROR: Atleast 2 near wake rows mandatory' endif ! Override ns to 1 if non-lifting surface if ( abs ( this % surfaceType ) . eq . 2 ) this % ns = 1 ! Define body axis this % xAxisBody = xAxis this % yAxisBody = yAxis this % zAxisBody = zAxis ! Initialize variables for use in allocating if ( abs ( this % surfaceType ) == 1 ) then this % nNwake = min ( this % nNwake , nt ) if ( this % wakeTruncateNt == 0 ) then this % nFwake = nt - this % nNwake else this % nFwake = this % wakeTruncateNt - this % nNwake endif elseif ( abs ( this % surfaceType ) . eq . 2 ) then this % nNwake = 0 this % nFwake = 0 endif ! Define limits for use in wake convection this % nbConvect = this % nb if ( this % axisymmetrySwitch . eq . 1 ) this % nbConvect = 1 this % nNwakeEnd = this % nNwake this % nFwakeEnd = this % nFwake ! Allocate rotor object variables allocate ( this % blade ( this % nb )) allocate ( this % AIC ( this % nc * this % ns * this % nb , this % nc * this % ns * this % nb )) allocate ( this % AIC_inv ( this % nc * this % ns * this % nb , this % nc * this % ns * this % nb )) allocate ( this % gamVec ( this % nc * this % ns * this % nb )) allocate ( this % gamVecPrev ( this % nc * this % ns * this % nb )) allocate ( this % RHS ( this % nc * this % ns * this % nb )) ! Read custom trajectory file if specified if ( this % surfaceType . ge . 0 ) then if ( this % customTrajectorySwitch . eq . 1 ) then allocate ( this % velBodyHistory ( 3 , nt )) allocate ( this % omegaBodyHistory ( 3 , nt )) open ( unit = 13 , file = 'trajectory' // this % id // '.in' , & & status = 'old' , action = 'read' ) do i = 1 , nt read ( 13 , * ) this % velBodyHistory ( 1 , i ), & & this % velBodyHistory ( 2 , i ), & & this % velBodyHistory ( 3 , i ), & & this % omegaBodyHistory ( 1 , i ), & & this % omegaBodyHistory ( 2 , i ), & & this % omegaBodyHistory ( 3 , i ) enddo close ( 13 ) endif endif ! Allocate blade object variables do ib = 1 , this % nb allocate ( this % blade ( ib )% wiP ( this % nc , this % ns )) if ( this % nNwake > 0 ) then allocate ( this % blade ( ib )% waN ( this % nNwake , this % ns )) allocate ( this % blade ( ib )% waF ( this % nFwake )) endif allocate ( this % blade ( ib )% secTauCapChord ( 3 , this % ns )) allocate ( this % blade ( ib )% secTauCapSpan ( 3 , this % ns )) allocate ( this % blade ( ib )% secNormalVec ( 3 , this % ns )) allocate ( this % blade ( ib )% secForceInertial ( 3 , this % ns )) allocate ( this % blade ( ib )% secChord ( this % ns )) allocate ( this % blade ( ib )% secArea ( this % ns )) allocate ( this % blade ( ib )% secLift ( 3 , this % ns )) allocate ( this % blade ( ib )% secLiftInPlane ( 3 , this % ns )) allocate ( this % blade ( ib )% secLiftOutPlane ( 3 , this % ns )) allocate ( this % blade ( ib )% secLiftInPlaneUnsteady ( 3 , this % ns )) allocate ( this % blade ( ib )% secLiftOutPlaneUnsteady ( 3 , this % ns )) allocate ( this % blade ( ib )% secLiftUnsteady ( 3 , this % ns )) allocate ( this % blade ( ib )% secDrag ( 3 , this % ns )) allocate ( this % blade ( ib )% secLiftDir ( 3 , this % ns )) allocate ( this % blade ( ib )% secDragDir ( 3 , this % ns )) allocate ( this % blade ( ib )% secDragInduced ( 3 , this % ns )) allocate ( this % blade ( ib )% secDragProfile ( 3 , this % ns )) allocate ( this % blade ( ib )% secDragUnsteady ( 3 , this % ns )) allocate ( this % blade ( ib )% secTheta ( this % ns )) allocate ( this % blade ( ib )% secAlpha ( this % ns )) allocate ( this % blade ( ib )% secPhi ( this % ns )) allocate ( this % blade ( ib )% secViz ( this % ns )) allocate ( this % blade ( ib )% secVix ( this % ns )) allocate ( this % blade ( ib )% airfoilNo ( this % ns )) allocate ( this % blade ( ib )% secCL ( this % ns )) allocate ( this % blade ( ib )% secCD ( this % ns )) allocate ( this % blade ( ib )% secCM ( this % ns )) allocate ( this % blade ( ib )% secCLu ( this % ns )) allocate ( this % blade ( ib )% secMflap ( this % ns )) allocate ( this % blade ( ib )% secMflapArm ( this % ns )) allocate ( this % blade ( ib )% secChordwiseResVel ( 3 , this % ns )) allocate ( this % blade ( ib )% secCP ( 3 , this % ns )) enddo ! Conversions only for actual geom and not for image geoms if ( this % surfaceType . ge . 0 ) then this % controlPitch = this % controlPitch * degToRad this % pts = this % pts * degToRad this % thetaTwist = this % thetaTwist * degToRad this % preconeAngle = this % preconeAngle * degToRad this % psiStart = this % psiStart * degToRad this % spanwiseCore = this % spanwiseCore * this % chord this % streamwiseCoreVec = this % streamwiseCoreVec * this % chord this % rollupStart = ceiling ( this % rollupStartRadius * this % ns ) this % rollupEnd = floor ( this % rollupEndRadius * this % ns ) endif ! Rotor initialization this % gamVec = 0._dp this % gamVecPrev = 0._dp this % lift = 0._dp this % velBodyPrev = 0._dp this % omegaBodyPrev = 0._dp ! Set blade ids do ib = 1 , this % nb write ( this % blade ( ib )% id , '(I0.2)' ) ib enddo ! Blade initialization if ( this % geometryFile ( 1 : 1 ) . eq . '0' ) then select case ( this % chordSpacing ) case ( 1 ) ! Equidistant if ( this % Omega . ge . 0 ) then xVec = linspace ( - this % chord , 0._dp , this % nc + 1 ) else xVec = linspace ( this % chord , 0._dp , this % nc + 1 ) endif case ( 2 ) ! Cosine if ( this % Omega . ge . 0 ) then xVec = cosspace ( - this % chord , 0._dp , this % nc + 1 ) else xVec = cosspace ( this % chord , 0._dp , this % nc + 1 ) endif case ( 3 ) ! Sine if ( this % Omega . ge . 0 ) then xVec = halfsinspace ( - this % chord , 0._dp , this % nc + 1 ) else xVec = halfsinspace ( this % chord , 0._dp , this % nc + 1 ) endif case ( 4 ) ! Tan if ( this % Omega . ge . 0 ) then xVec = tanspace ( - this % chord , 0._dp , this % nc + 1 ) else xVec = tanspace ( this % chord , 0._dp , this % nc + 1 ) endif end select select case ( this % spanSpacing ) case ( 1 ) yVec = linspace ( this % root_cut * this % radius , this % radius , this % ns + 1 ) case ( 2 ) yVec = cosspace ( this % root_cut * this % radius , this % radius , this % ns + 1 ) case ( 3 ) yVec = halfsinspace ( this % root_cut * this % radius , this % radius , this % ns + 1 ) case ( 4 ) yVec = tanspace ( this % root_cut * this % radius , this % radius , this % ns + 1 ) end select ! Initialize panel coordinates do ib = 1 , this % nb ! Compute camber if ( this % nCamberFiles > 0 ) then zVec = this % getCamber ( xVec , yVec ) else zVec = 0._dp endif if ( this % surfaceType < 0 . and . this % imagePlane == 3 ) then zVec = - 1._dp * zVec endif ! Assign coordinates to panels do j = 1 , this % ns do i = 1 , this % nc call this % blade ( ib )% wiP ( i , j )% assignP ( 1 , & & [ xVec ( i ), yVec ( j ), zVec ( i , j )]) call this % blade ( ib )% wiP ( i , j )% assignP ( 2 , & & [ xVec ( i + 1 ), yVec ( j ), zVec ( i + 1 , j )]) call this % blade ( ib )% wiP ( i , j )% assignP ( 3 , & & [ xVec ( i + 1 ), yVec ( j + 1 ), zVec ( i + 1 , j + 1 )]) call this % blade ( ib )% wiP ( i , j )% assignP ( 4 , & & [ xVec ( i ), yVec ( j + 1 ), zVec ( i , j + 1 )]) enddo enddo enddo else if ( abs ( this % surfaceType ) == 1 ) then call this % plot3dtoblade ( trim ( this % geometryFile )) elseif ( abs ( this % surfaceType ) == 2 ) then call this % stltoblade ( trim ( this % geometryFile )) do ib = 1 , this % nb this % blade ( ib )% nc = this % nc this % blade ( ib )% ns = this % ns call this % blade ( ib )% calc_stlStats () enddo endif endif ! Copy ns and nc to blade variables to avoid recomputing do ib = 1 , this % nb this % blade ( ib )% nc = this % nc this % blade ( ib )% ns = this % ns enddo do ib = 1 , this % nbConvect ! Initialize blade axes ! Can go wrong if importing geometry from OpenVSP ! at a non-standard orientation ! and then using these for orientation of lift vectors ! Standard orientation is X: chordwise, Y: spanwise, Z:upwards this % blade ( ib )% xAxis = xAxis this % blade ( ib )% yAxis = yAxis this % blade ( ib )% zAxis = zAxis ! These axes do not have pitch or flap rotations this % blade ( ib )% xAxisAzi = xAxis this % blade ( ib )% yAxisAzi = yAxis this % blade ( ib )% zAxisAzi = zAxis ! These axes do not have pitch rotation ! They are rotated by the flap angle this % blade ( ib )% xAxisAziFlap = xAxis this % blade ( ib )% yAxisAziFlap = yAxis this % blade ( ib )% zAxisAziFlap = zAxis this % blade ( ib )% flapOrigin = this % blade ( ib )% yAxis * & & this % radius * this % flapHinge ! Initialize sec vectors if ( abs ( this % surfaceType ) == 1 ) then do j = 1 , this % ns this % blade ( ib )% secTauCapChord (:, j ) = & ( this % blade ( ib )% wiP ( this % nc , j )% PC (:, 3 ) + this % blade ( ib )% wiP ( this % nc , j )% PC (:, 2 ) - & ( this % blade ( ib )% wiP ( 1 , j )% PC (:, 4 ) + this % blade ( ib )% wiP ( 1 , j )% PC (:, 1 ))) * 0.5_dp this % blade ( ib )% secTauCapSpan (:, j ) = yAxis this % blade ( ib )% secNormalVec (:, j ) = & cross_product ( this % blade ( ib )% wiP ( this % nc , j )% PC (:, 2 ) - this % blade ( ib )% wiP ( 1 , j )% PC (:, 4 ), & this % blade ( ib )% wiP ( this % nc , j )% PC (:, 3 ) - this % blade ( ib )% wiP ( 1 , j )% PC (:, 1 )) ! Normalize this % blade ( ib )% secTauCapChord (:, j ) = unitVec ( this % blade ( ib )% secTauCapChord (:, j )) this % blade ( ib )% secNormalVec (:, j ) = sign ( 1._dp , this % Omega ) * unitVec ( this % blade ( ib )% secNormalVec (:, j )) enddo ! Initialize vr coords of all panels except last row (to accomodate mismatch of vr coords when using unequal spacing) do j = 1 , this % ns do i = 1 , this % nc - 1 xshift ( 1 ) = ( this % blade ( ib )% wiP ( i , j )% PC ( 1 , 2 ) & - this % blade ( ib )% wiP ( i , j )% PC ( 1 , 1 )) * 0.25_dp xshift ( 2 ) = ( this % blade ( ib )% wiP ( i + 1 , j )% PC ( 1 , 2 ) & - this % blade ( ib )% wiP ( i , j )% PC ( 1 , 2 )) * 0.25_dp xshift ( 3 ) = ( this % blade ( ib )% wiP ( i + 1 , j )% PC ( 1 , 3 ) & - this % blade ( ib )% wiP ( i , j )% PC ( 1 , 3 )) * 0.25_dp xshift ( 4 ) = ( this % blade ( ib )% wiP ( i , j )% PC ( 1 , 3 ) & - this % blade ( ib )% wiP ( i , j )% PC ( 1 , 4 )) * 0.25_dp call this % blade ( ib )% wiP ( i , j )% vr % assignP ( 1 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 1 ) & + xshift ( 1 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 1 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 1 )]) call this % blade ( ib )% wiP ( i , j )% vr % assignP ( 2 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 2 ) & + xshift ( 2 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 2 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 2 )]) call this % blade ( ib )% wiP ( i , j )% vr % assignP ( 3 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 3 ) & + xshift ( 3 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 3 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 3 )]) call this % blade ( ib )% wiP ( i , j )% vr % assignP ( 4 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 4 ) & + xshift ( 4 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 4 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 4 )]) enddo enddo ! Initialize vr coords of last row do j = 1 , this % ns xshift ( 1 ) = ( this % blade ( ib )% wiP ( this % nc , j )% PC ( 1 , 2 ) & - this % blade ( ib )% wiP ( this % nc , j )% PC ( 1 , 1 )) * 0.25_dp ! Shift x coord by dx/4 xshift ( 2 ) = 0._dp xshift ( 3 ) = 0._dp xshift ( 4 ) = ( this % blade ( ib )% wiP ( this % nc , j )% PC ( 1 , 3 ) & - this % blade ( ib )% wiP ( this % nc , j )% PC ( 1 , 4 )) * 0.25_dp ! Shift x coord by dx/4 call this % blade ( ib )% wiP ( this % nc , j )% vr % assignP ( 1 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 1 ) & + xshift ( 1 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 1 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 1 )]) call this % blade ( ib )% wiP ( this % nc , j )% vr % assignP ( 2 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 2 ) & + xshift ( 2 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 2 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 2 )]) call this % blade ( ib )% wiP ( this % nc , j )% vr % assignP ( 3 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 3 ) & + xshift ( 3 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 3 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 3 )]) call this % blade ( ib )% wiP ( this % nc , j )% vr % assignP ( 4 , & [ this % blade ( ib )% wiP ( i , j )% PC ( 1 , 4 ) & + xshift ( 4 ), this % blade ( ib )% wiP ( i , j )% PC ( 2 , 4 ), & this % blade ( ib )% wiP ( i , j )% PC ( 3 , 4 )]) enddo endif ! Initialize max wake vel for any point to tip velocity if ( abs ( this % Omega ) > eps ) then this % blade ( ib )% velWakeMax = this % Radius * abs ( this % Omega ) else this % blade ( ib )% velWakeMax = norm2 ( this % velBody ) endif ! Find dx and dy vectors do is = 1 , this % ns do ic = 1 , this % nc dx ( ic , is ) = norm2 ( this % blade ( ib )% wiP ( ic , is )% PC (:, 2 ) - this % blade ( ib )% wiP ( ic , is )% PC (:, 1 )) dy ( ic , is ) = norm2 ( this % blade ( ib )% wiP ( ic , is )% PC (:, 3 ) - this % blade ( ib )% wiP ( ic , is )% PC (:, 2 )) enddo enddo dx = abs ( dx ) dy = abs ( dy ) dxdymin = min ( minval ( dx ), minval ( dy )) ! Shed last row of vortices if ( abs ( this % surfaceType ) == 1 ) then if ( abs ( this % Omega ) > eps ) then velShed = min ( 0.05 * abs ( this % Omega ) * norm2 ( this % blade ( ib )% & wiP ( this % nc , this % ns )% vr % vf ( 2 )% fc (:, 1 ) - this % hubCoords ), 0.125_dp * this % chord / dt ) else velShed = 0.3_dp * norm2 ( - 1._dp * this % velBody ) endif do j = 1 , this % ns call this % blade ( ib )% wiP ( this % nc , j )% vr % shiftdP ( 2 , [ sign ( 1._dp , this % Omega ) * velShed * dt , 0._dp , 0._dp ]) call this % blade ( ib )% wiP ( this % nc , j )% vr % shiftdP ( 3 , [ sign ( 1._dp , this % Omega ) * velShed * dt , 0._dp , 0._dp ]) enddo endif ! Initialize CP coords, nCap, panelArea and pivotLE if ( abs ( this % surfaceType ) == 1 ) then do j = 1 , this % ns do i = 1 , this % nc call this % blade ( ib )% wiP ( i , j )% calcCP () call this % blade ( ib )% wiP ( i , j )% calcN () if ( sign ( 1._dp , this % Omega ) < 0._dp ) then call this % blade ( ib )% wiP ( i , j )% invertNcap () endif call this % blade ( ib )% wiP ( i , j )% calcTau () this % blade ( ib )% wiP ( i , j )% rHinge = length3d (( this % blade ( ib )% wiP ( 1 , j )% pc (:, 1 ) & + this % blade ( ib )% wiP ( 1 , j )% pc (:, 4 )) * 0.5_dp , this % blade ( ib )% wiP ( i , j )% CP ) call this % blade ( ib )% wiP ( i , j )% calc_area () call this % blade ( ib )% wiP ( i , j )% calc_mean_dimensions () enddo enddo elseif ( abs ( this % surfaceType ) == 2 ) then do j = 1 , this % ns do i = 1 , this % nc call this % blade ( ib )% wiP ( i , j )% calcCP ( isTriangle = . true .) call this % blade ( ib )% wiP ( i , j )% calcN ( isTriangle = . true .) call this % blade ( ib )% wiP ( i , j )% calcTau ( isTriangle = . true .) ! this%blade(ib)%wiP(i, j)%rHinge = & ! & length3d((this%blade(ib)%wiP(1, j)%pc(:, 1) & ! & + this%blade(ib)%wiP(1, j)%pc(:, 4))*0.5_dp, & ! & this%blade(ib)%wiP(i, j)%CP) call this % blade ( ib )% wiP ( i , j )% calc_area () call this % blade ( ib )% wiP ( i , j )% calc_mean_dimensions () enddo enddo endif if ( this % surfaceType . lt . 0 ) then do j = 1 , this % ns do i = 1 , this % nc this % blade ( ib )% wiP ( i , j )% nCap = & & sourceRotor % blade ( ib )% wiP ( i , j )% nCap this % blade ( ib )% wiP ( i , j )% nCap ( this % imagePlane ) = & & - 1._dp * this % blade ( ib )% wiP ( i , j )% nCap ( this % imagePlane ) enddo enddo endif ! Compute sectional areas and chords call this % blade ( ib )% calc_secArea () call this % blade ( ib )% calc_secChord () ! Assign spanwise lift term switch to blades this % blade ( ib )% spanwiseLiftSwitch = this % spanwiseLiftSwitch ! Internal setting to override panel tauSpan using ! global spanwise axis. This setting is only relevant in tapered wings ! or swept wings when the panel tauSpan and yAxis do not coincide this % overrideTauSpan = 1 if ( this % overrideTauSpan . eq . 1 ) then do j = 1 , this % ns this % blade ( ib )% secTauCapSpan (:, j ) = this % blade ( ib )% yAxis do i = 1 , this % nc this % blade ( ib )% wiP ( i , j )% tauCapSpan = this % blade ( ib )% yAxis ! this%blade(ib)%wiP(i, j)%tauCapChord = this%blade(ib)%xAxis enddo enddo endif ! Invert half of tau vectors for symmetric or swept wings if ( this % symmetricTau . eq . 1 ) then do j = 1 , ( this % ns / 2 ) this % blade ( ib )% secTauCapSpan (:, j ) = - 1._dp * & & this % blade ( ib )% secTauCapSpan (:, j ) do i = 1 , this % nc this % blade ( ib )% wiP ( i , j )% tauCapSpan = - 1._dp * & & this % blade ( ib )% wiP ( i , j )% tauCapSpan enddo enddo endif ! Inflow calculated at mid-chord secCPLoc = 0.5_dp call this % blade ( ib )% calc_secLocations ( secCPLoc , this % flapHinge * this % radius ) ! Initialize gamma this % blade ( ib )% wiP % vr % gam = 0._dp this % blade ( ib )% wiP % vr % skew = 0._dp this % blade ( ib )% pivotLE = this % pivotLE ! Initialize wake age do i = 1 , 4 this % blade ( ib )% wiP % vr % vf ( i )% age = 0._dp this % blade ( ib )% wiP % vr % vf ( i )% ageAzimuthal = 0._dp this % blade ( ib )% waN % vr % vf ( i )% age = 0._dp this % blade ( ib )% waN % vr % vf ( i )% ageAzimuthal = 0._dp enddo this % blade ( ib )% waF % vf % age = 0._dp this % blade ( ib )% waF % vf % ageAzimuthal = 0._dp ! Initialize all core radius of wing vortices to zero do i = 1 , 4 this % blade ( ib )% wiP % vr % vf ( i )% rVc0 = & & min ( this % spanwiseCore , dxdymin * 0.1_dp ) enddo if ( min ( this % spanwiseCore , dxdymin * 0.1_dp ) < eps ) then print * , 'Warning: Wing vortex core radius set to zero' endif ! print*,'Wing vortex core radius set to ', & ! & min(this%spanwiseCore,dxdymin*0.1_dp)/this%chord,'times chord' ! Initialize spanwise vortex core radius for last row of wing ! to that of wake this % blade ( ib )% wiP ( this % nc , :)% vr % vf ( 2 )% rVc0 = this % spanwiseCore ! Initialize all current core radius of wing vortices ! to initial core radius do i = 1 , 4 this % blade ( ib )% wiP % vr % vf ( i )% rVc = this % blade ( ib )% wiP % vr % vf ( i )% rVc0 enddo ! Disabling this check as it does not make a difference ! Verify CP is outside vortex core for boundary panels ! if (this%blade(ib)%wiP(1, 1)%isCPinsidecore()) then !   print *, 'Warning: CP inside vortex core at panel LU' ! endif ! if (this%blade(ib)%wiP(this%nc, 1)%isCPinsidecore()) then !   print *, 'Warning: CP inside vortex core at panel LB' ! endif ! if (this%blade(ib)%wiP(1, this%ns)%isCPinsidecore()) then !   print *, 'Warning: CP inside vortex core at panel RU' ! endif ! if (this%blade(ib)%wiP(this%nc, this%ns)%isCPinsidecore()) then !   print *, 'Warning: CP inside vortex core at panel RB' ! endif enddo ! Copy Blade1 variables to other blades if symmetric axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb this % blade ( ib )% xAxis = this % blade ( 1 )% xAxis this % blade ( ib )% yAxis = this % blade ( 1 )% yAxis this % blade ( ib )% zAxis = this % blade ( 1 )% zAxis this % blade ( ib )% xAxisAzi = this % blade ( 1 )% xAxisAzi this % blade ( ib )% yAxisAzi = this % blade ( 1 )% yAxisAzi this % blade ( ib )% zAxisAzi = this % blade ( 1 )% zAxisAzi this % blade ( ib )% xAxisAziFlap = this % blade ( 1 )% xAxisAziFlap this % blade ( ib )% yAxisAziFlap = this % blade ( 1 )% yAxisAziFlap this % blade ( ib )% zAxisAziFlap = this % blade ( 1 )% zAxisAziFlap this % blade ( ib )% flapOrigin = this % blade ( 1 )% flapOrigin ! Initialize sec vectors do j = 1 , this % ns this % blade ( ib )% secTauCapChord (:, j ) = & & this % blade ( 1 )% secTauCapChord (:, j ) this % blade ( ib )% secTauCapSpan (:, j ) = & & this % blade ( 1 )% secTauCapSpan (:, j ) this % blade ( ib )% secNormalVec (:, j ) = & & this % blade ( 1 )% secNormalVec (:, j ) enddo do j = 1 , this % ns do i = 1 , this % nc this % blade ( ib )% wiP ( i , j )% vr = this % blade ( 1 )% wiP ( i , j )% vr this % blade ( ib )% wiP ( i , j )% CP = this % blade ( 1 )% wiP ( i , j )% CP this % blade ( ib )% wiP ( i , j )% nCap = this % blade ( 1 )% wiP ( i , j )% nCap this % blade ( ib )% wiP ( i , j )% tauCapChord = & & this % blade ( 1 )% wiP ( i , j )% tauCapChord this % blade ( ib )% wiP ( i , j )% rHinge = & & this % blade ( 1 )% wiP ( i , j )% rHinge this % blade ( ib )% wiP ( i , j )% panelArea = & & this % blade ( 1 )% wiP ( i , j )% panelArea this % blade ( ib )% wiP ( i , j )% meanChord = & & this % blade ( 1 )% wiP ( i , j )% meanChord this % blade ( ib )% wiP ( i , j )% meanSpan = & & this % blade ( 1 )% wiP ( i , j )% meanSpan enddo enddo this % blade ( ib )% secArea = this % blade ( 1 )% secArea this % blade ( ib )% secChord = this % blade ( 1 )% secChord this % blade ( ib )% spanwiseLiftSwitch = this % blade ( 1 )% spanwiseLiftSwitch this % blade ( ib )% secTauCapSpan = this % blade ( 1 )% secTauCapSpan do j = 1 , this % ns do i = 1 , this % nc this % blade ( ib )% wiP ( i , j )% tauCapSpan = & & this % blade ( 1 )% wiP ( i , j )% tauCapSpan this % blade ( ib )% wiP ( i , j )% tauCapSpan = & & this % blade ( 1 )% wiP ( i , j )% tauCapSpan enddo enddo this % blade ( ib )% secCP = this % blade ( 1 )% secCP this % blade ( ib )% secMflapArm = this % blade ( 1 )% secMflapArm this % blade ( ib )% wiP % vr % gam = this % blade ( 1 )% wiP % vr % gam this % blade ( ib )% wiP % vr % skew = this % blade ( 1 )% wiP % vr % skew this % blade ( ib )% pivotLE = this % blade ( 1 )% pivotLE do i = 1 , 4 this % blade ( ib )% wiP % vr % vf ( i )% age = & & this % blade ( 1 )% wiP % vr % vf ( i )% age this % blade ( ib )% wiP % vr % vf ( i )% ageAzimuthal = & & this % blade ( 1 )% wiP % vr % vf ( i )% ageAzimuthal this % blade ( ib )% waN % vr % vf ( i )% age = & & this % blade ( 1 )% waN % vr % vf ( i )% age this % blade ( ib )% waN % vr % vf ( i )% ageAzimuthal = & & this % blade ( 1 )% waN % vr % vf ( i )% ageAzimuthal this % blade ( ib )% wiP % vr % vf ( i )% rVc0 = & & this % blade ( 1 )% wiP % vr % vf ( i )% rVc0 this % blade ( ib )% wiP % vr % vf ( i )% rVc = & & this % blade ( 1 )% wiP % vr % vf ( i )% rVc enddo this % blade ( ib )% waF % vf % age = this % blade ( 1 )% waF % vf % age this % blade ( ib )% waF % vf % ageAzimuthal = this % blade ( 1 )% waF % vf % ageAzimuthal enddo endif axisym ! Move rotor to hub coordinates do ib = 1 , this % nb call this % blade ( ib )% move ( this % hubCoords - this % fromCoords ) enddo ! Set Dihedral/precone angle (initial flap angle) do ib = 1 , this % nb this % blade ( ib )% preconeAngle = this % preconeAngle this % blade ( ib )% Iflap = this % Iflap this % blade ( ib )% cflap = this % cflap this % blade ( ib )% kflap = this % kflap this % blade ( ib )% MflapConstant = this % MflapConstant this % blade ( ib )% dflapInitial = this % dflapInitial this % blade ( ib )% flapInitial = this % flapInitial this % blade ( ib )% dflap = this % blade ( ib )% dflapInitial this % blade ( ib )% flap = this % blade ( ib )% flapInitial this % blade ( ib )% dflapPrev = this % blade ( ib )% dflap this % blade ( ib )% flapPrev = this % blade ( ib )% flap call this % blade ( ib )% rot_flap ( this % preconeAngle ) call this % blade ( ib )% rot_flap ( this % flapInitial ) enddo ! Rotate remaining blades to their positions ! Rotate blades for multi-bladed rotors do ib = 2 , this % nb bladeOffset = sign ( 1._dp , this % Omega ) * twoPi / this % nb * ( ib - 1 ) call this % blade ( ib )% rotate ( bladeOffset , & & this % shaftAxis ( 1 ), this % shaftAxis ( 2 ), this % shaftAxis ( 3 ), & & this % hubCoords ( 1 ), this % hubCoords ( 2 ), this % hubCoords ( 3 ), & & 'azimuth' ) enddo ! Rotate rotor by phi,theta,psi about CG call this % rot_pts ( this % pts , this % cgCoords , 1 ) ! Rotate rotor by psiStart call this % rot_advance ( sign ( 1._dp , this % Omega ) * this % psiStart , nopitch = . true .) ! Compute denominators for non-dimensionalisation if ( abs ( this % Omega ) . gt . eps ) then if ( this % propConvention . eq . 0 ) then ! Rotary-wing this % nonDimforceDenominator = density * ( pi * this % radius ** 2._dp ) * & ( this % radius * this % Omega ) ** 2._dp else ! Propeller this % nonDimforceDenominator = density * ( this % Omega / twoPi ) ** 2._dp * & ( 2._dp * this % radius ) ** 4._dp endif else ! Fixed-wing this % nonDimforceDenominator = 0.5_dp * density & & * ( this % radius * ( 1._dp - this % root_cut ) * & this % chord ) * ( dot_product ( this % velBody , this % velBody )) endif ! Allocate and assign section airfoils if ( this % nAirfoils . gt . 0 ) then do ib = 1 , this % nb allocate ( this % blade ( ib )% C81 ( this % nAirfoils )) do i = 1 , this % nAirfoils if ( this % airfoilFile ( i ) ( 1 : 1 ) . ne . '0' ) & call this % blade ( ib )% C81 ( i )% readfile ( trim ( this % airfoilFile ( i ))) enddo allocate ( this % blade ( ib )% airfoilSectionLimit ( this % nAirfoils )) allocate ( this % blade ( ib )% alpha0 ( this % nAirfoils )) this % blade ( ib )% airfoilSectionLimit = this % airfoilSectionLimit do i = 1 , this % nAirfoils this % blade ( ib )% alpha0 ( i ) = this % alpha0 ( i ) enddo ! Assign airfoil numbers for each section if ( this % nAirfoils . eq . 1 ) then this % blade ( ib )% airfoilNo (:) = 1 else leftTipCP = this % blade ( ib )% wiP ( 1 , 1 )% PC (:, 4 ) * ( 1._dp - secCPLoc ) & + this % blade ( ib )% wiP ( this % nc , 1 )% PC (:, 3 ) * secCPLoc do is = 1 , this % ns ! Warning: This will break if wing is centered about X-Z plane and ! full span length is used for reference length rbyR = abs ( dot_product ( this % blade ( ib )% secCP (:, is ) - leftTipCP , this % blade ( ib )% xAxis )) & + this % root_cut if ( rbyR . gt . 1._dp ) error stop 'ERROR: r/R value is greater than 1 in airfoil selection' do i = 1 , this % nAirfoils if ( this % airfoilSectionLimit ( i ) . ge . rbyR ) then this % blade ( ib )% airfoilNo ( is ) = i exit endif enddo enddo endif enddo endif ! Allocate vars required for wake convection ! on the basis of finite diff scheme do ib = 1 , this % nb if ( this % nNwake > 0 ) then allocate ( this % blade ( ib )% velNwake ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velFwake ( 3 , this % nFwake )) this % blade ( ib )% velNwake = 0._dp this % blade ( ib )% velFwake = 0._dp select case ( switches % fdScheme ) case ( 0 ) ! Do nothing case ( 1 ) allocate ( this % blade ( ib )% waNPredicted ( this % nNwake , this % ns )) allocate ( this % blade ( ib )% velNwakePredicted ( 3 , this % nNwake , this % ns + 1 )) this % blade ( ib )% velNwakePredicted = 0._dp allocate ( this % blade ( ib )% waFPredicted ( this % nFwake )) allocate ( this % blade ( ib )% velFwakePredicted ( 3 , this % nFwake )) this % blade ( ib )% velFwakePredicted = 0._dp case ( 2 ) allocate ( this % blade ( ib )% velNwake1 ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwakeStep ( 3 , this % nNwake , this % ns + 1 )) this % blade ( ib )% velNwake1 = 0._dp this % blade ( ib )% velNwakeStep = 0._dp allocate ( this % blade ( ib )% velFwake1 ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwakeStep ( 3 , this % nFwake )) this % blade ( ib )% velFwake1 = 0._dp this % blade ( ib )% velFwakeStep = 0._dp case ( 3 ) allocate ( this % blade ( ib )% waNPredicted ( this % nNwake , this % ns )) allocate ( this % blade ( ib )% velNwake1 ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwakePredicted ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwakeStep ( 3 , this % nNwake , this % ns + 1 )) this % blade ( ib )% velNwake1 = 0._dp this % blade ( ib )% velNwakePredicted = 0._dp this % blade ( ib )% velNwakeStep = 0._dp allocate ( this % blade ( ib )% waFPredicted ( this % nFwake )) allocate ( this % blade ( ib )% velFwake1 ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwakePredicted ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwakeStep ( 3 , this % nFwake )) this % blade ( ib )% velFwake1 = 0._dp this % blade ( ib )% velFwakePredicted = 0._dp this % blade ( ib )% velFwakeStep = 0._dp case ( 4 ) allocate ( this % blade ( ib )% waNPredicted ( this % nNwake , this % ns )) allocate ( this % blade ( ib )% velNwake1 ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwake2 ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwakePredicted ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwakeStep ( 3 , this % nNwake , this % ns + 1 )) this % blade ( ib )% velNwake1 = 0._dp this % blade ( ib )% velNwake2 = 0._dp this % blade ( ib )% velNwakePredicted = 0._dp this % blade ( ib )% velNwakeStep = 0._dp allocate ( this % blade ( ib )% waFPredicted ( this % nFwake )) allocate ( this % blade ( ib )% velFwake1 ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwake2 ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwakePredicted ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwakeStep ( 3 , this % nFwake )) this % blade ( ib )% velFwake1 = 0._dp this % blade ( ib )% velFwake2 = 0._dp this % blade ( ib )% velFwakePredicted = 0._dp this % blade ( ib )% velFwakeStep = 0._dp case ( 5 ) allocate ( this % blade ( ib )% waNPredicted ( this % nNwake , this % ns )) allocate ( this % blade ( ib )% velNwake1 ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwake2 ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwake3 ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwakePredicted ( 3 , this % nNwake , this % ns + 1 )) allocate ( this % blade ( ib )% velNwakeStep ( 3 , this % nNwake , this % ns + 1 )) this % blade ( ib )% velNwake1 = 0._dp this % blade ( ib )% velNwake2 = 0._dp this % blade ( ib )% velNwake3 = 0._dp this % blade ( ib )% velNwakePredicted = 0._dp this % blade ( ib )% velNwakeStep = 0._dp allocate ( this % blade ( ib )% waFPredicted ( this % nFwake )) allocate ( this % blade ( ib )% velFwake1 ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwake2 ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwake3 ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwakePredicted ( 3 , this % nFwake )) allocate ( this % blade ( ib )% velFwakeStep ( 3 , this % nFwake )) this % blade ( ib )% velFwake1 = 0._dp this % blade ( ib )% velFwake2 = 0._dp this % blade ( ib )% velFwake3 = 0._dp this % blade ( ib )% velFwakePredicted = 0._dp this % blade ( ib )% velFwakeStep = 0._dp end select endif enddo ! Wake initialization ! Assign core_radius to mid vortices do ib = 1 , this % nb if ( this % nNwake > 0 ) then do i = 2 , 4 , 2 this % blade ( ib )% waN % vr % vf ( i )% rVc0 = this % spanwiseCore this % blade ( ib )% waN % vr % vf ( i )% rVc = this % spanwiseCore enddo this % blade ( ib )% waN % vr % gam = 0._dp this % blade ( ib )% waF % gam = 0._dp ! Assign core_radius to tip vortices do j = 1 , this % ns do i = 1 , this % nNwake this % blade ( ib )% waN ( i , j )% vr % vf ( 1 )% rVc0 = this % streamwiseCoreVec ( j ) this % blade ( ib )% waN ( i , j )% vr % vf ( 1 )% rVc = this % streamwiseCoreVec ( j ) enddo enddo do j = 1 , this % ns do i = 1 , this % nNwake this % blade ( ib )% waN ( i , j )% vr % vf ( 3 )% rVc0 = this % streamwiseCoreVec ( j + 1 ) this % blade ( ib )% waN ( i , j )% vr % vf ( 3 )% rVc = this % streamwiseCoreVec ( j + 1 ) enddo enddo !do i=1,this%nFwake this % blade ( ib )% waF % vf % rVc0 = this % streamwiseCoreVec ( this % ns + 1 ) this % blade ( ib )% waF % vf % rVc = this % streamwiseCoreVec ( this % ns + 1 ) !enddo endif enddo ! Compute direction of wind frame forces (-body) ! Assuming sideslip is not present if (( norm2 ( this % dragUnitVec ) . le . eps ) & . and . ( norm2 ( this % sideUnitVec ) . le . eps ) & . and . ( norm2 ( this % liftUnitVec ) . le . eps )) then if ( abs ( this % Omega ) . le . eps ) then if ( abs ( this % velBody ( 1 )) . gt . eps ) then ! v is assumed zero this % dragUnitVec = - 1._dp * unitVec ([ this % velBody ( 1 ), 0._dp , this % velBody ( 3 )]) this % sideUnitVec = yAxis else ! u is assumed zero this % dragUnitVec = - 1._dp * unitVec ([ 0._dp , this % velBody ( 2 ), this % velBody ( 3 )]) this % sideUnitVec = xAxis endif this % liftUnitVec = cross_product ( this % dragUnitVec , this % sideUnitVec ) else ! Drag along forward velocity direction if ( abs ( this % velBody ( 1 )) . gt . eps ) then this % dragUnitVec = - 1._dp * unitVec ([ this % velBody ( 1 ), 0._dp , this % velBody ( 3 )]) this % sideUnitVec = yAxis elseif ( abs ( this % velBody ( 2 )) . gt . eps ) then this % dragUnitVec = - 1._dp * unitVec ([ this % velBody ( 1 ), 0._dp , this % velBody ( 3 )]) this % sideUnitVec = xAxis else this % sideUnitVec = yAxis this % dragUnitVec = cross_product ( this % sideUnitVec , this % shaftAxis ) endif this % liftUnitVec = this % shaftAxis endif endif end subroutine rotor_init subroutine rotor_deinit ( this , switches ) !! Deinitialise rotor variables class ( rotor_class ) :: this type ( switches_class ), intent ( in ) :: switches integer :: ib ! Deallocate variables do ib = 1 , this % nb if ( this % nNwake > 0 ) then deallocate ( this % blade ( ib )% velNwake ) deallocate ( this % blade ( ib )% velFwake ) select case ( switches % fdScheme ) case ( 0 ) ! Nothing to deallocate case ( 1 ) deallocate ( this % blade ( ib )% waNPredicted ) deallocate ( this % blade ( ib )% velNwakePredicted ) deallocate ( this % blade ( ib )% waFPredicted ) deallocate ( this % blade ( ib )% velFwakePredicted ) case ( 2 ) deallocate ( this % blade ( ib )% velNwake1 ) deallocate ( this % blade ( ib )% velNwakeStep ) deallocate ( this % blade ( ib )% velFwake1 ) deallocate ( this % blade ( ib )% velFwakeStep ) case ( 3 ) deallocate ( this % blade ( ib )% waNPredicted ) deallocate ( this % blade ( ib )% velNwake1 ) deallocate ( this % blade ( ib )% velNwakeStep ) deallocate ( this % blade ( ib )% waFPredicted ) deallocate ( this % blade ( ib )% velFwake1 ) deallocate ( this % blade ( ib )% velFwakeStep ) case ( 4 ) deallocate ( this % blade ( ib )% waNPredicted ) deallocate ( this % blade ( ib )% velNwake1 ) deallocate ( this % blade ( ib )% velNwake2 ) deallocate ( this % blade ( ib )% velNwakeStep ) deallocate ( this % blade ( ib )% waFPredicted ) deallocate ( this % blade ( ib )% velFwake1 ) deallocate ( this % blade ( ib )% velFwake2 ) deallocate ( this % blade ( ib )% velFwakeStep ) case ( 5 ) deallocate ( this % blade ( ib )% waNPredicted ) deallocate ( this % blade ( ib )% velNwake1 ) deallocate ( this % blade ( ib )% velNwake2 ) deallocate ( this % blade ( ib )% velNwake3 ) deallocate ( this % blade ( ib )% velNwakePredicted ) deallocate ( this % blade ( ib )% velNwakeStep ) deallocate ( this % blade ( ib )% waFPredicted ) deallocate ( this % blade ( ib )% velFwake1 ) deallocate ( this % blade ( ib )% velFwake2 ) deallocate ( this % blade ( ib )% velFwake3 ) deallocate ( this % blade ( ib )% velFwakePredicted ) deallocate ( this % blade ( ib )% velFwakeStep ) end select endif enddo end subroutine rotor_deinit subroutine rotor_plot3dtoblade ( this , PLOT3Dfilename ) !! Read blade geometry from PLOT3D formatted file class ( rotor_class ) :: this character ( len =* ), intent ( in ) :: PLOT3Dfilename integer :: nx , ny , nz real ( dp ), allocatable , dimension (:, :, :) :: grid integer :: i , j , ic , is , ib logical :: dataMismatch open ( unit = 10 , file = PLOT3Dfilename , action = 'read' , status = 'old' ) read ( 10 , * ) nx , ny , nz ! Verify with rotor parameters dataMismatch = . FALSE . if ( nz . gt . 1 ) dataMismatch = . TRUE . if ( nx . ne . ( this % nc + 1 )) dataMismatch = . TRUE . if ( ny . ne . ( this % ns + 1 )) dataMismatch = . TRUE . if ( dataMismatch ) then close ( 10 ) print * , 'PLOT3D file   (nx,ny)    =' , nx , ny print * , 'ROTOR file    (nc+1,ns+1)=' , this % nc + 1 , this % ns + 1 error stop 'ERROR: Wrong or conflicting data in PLOT3D file ' else allocate ( grid ( 3 , nx , ny )) read ( 10 , * ) & (( grid ( 1 , i , j ), i = 1 , nx ), j = 1 , ny ), & (( grid ( 2 , i , j ), i = 1 , nx ), j = 1 , ny ), & (( grid ( 3 , i , j ), i = 1 , nx ), j = 1 , ny ) close ( 10 ) endif ! Mirror geometry if imagePlane is z-axis if ( this % surfaceType < 0 . and . this % imagePlane == 3 ) then do j = 1 , ny do i = 1 , nx grid ( 3 , i , j ) = - 1._dp * grid ( 3 , i , j ) enddo enddo endif ! Assign to blades do ib = 1 , this % nbConvect do is = 1 , this % ns do ic = 1 , this % nc call this % blade ( ib )% wiP ( ic , is )% assignP ( 1 , grid (:, ic , is )) call this % blade ( ib )% wiP ( ic , is )% assignP ( 2 , grid (:, ic + 1 , is )) call this % blade ( ib )% wiP ( ic , is )% assignP ( 3 , grid (:, ic + 1 , is + 1 )) call this % blade ( ib )% wiP ( ic , is )% assignP ( 4 , grid (:, ic , is + 1 )) enddo enddo enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb do is = 1 , this % ns do ic = 1 , this % nc this % blade ( ib )% wiP ( ic , is )% PC = this % blade ( 1 )% wiP ( ic , is )% PC enddo enddo enddo endif axisym end subroutine rotor_plot3dtoblade subroutine rotor_stltoblade ( this , stlfilename ) !! Read ASCII stl file for non-lifting surface geometry class ( rotor_class ) :: this character ( len =* ), intent ( in ) :: stlfilename character ( len = 5 ) :: facet character ( len = 6 ) :: normal , vertex integer :: i open ( unit = 10 , file = stlfilename , action = 'read' , status = 'old' ) read ( 10 , * ) ! solid do i = 1 , this % nc read ( 10 , * ) facet , normal , this % blade ( 1 )% wiP ( i , 1 )% nCap read ( 10 , * ) ! outer loop read ( 10 , * ) vertex , this % blade ( 1 )% wiP ( i , 1 )% PC (:, 1 ) read ( 10 , * ) vertex , this % blade ( 1 )% wiP ( i , 1 )% PC (:, 2 ) read ( 10 , * ) vertex , this % blade ( 1 )% wiP ( i , 1 )% PC (:, 3 ) read ( 10 , * ) ! endloop read ( 10 , * ) ! endfacet enddo read ( 10 , * ) ! endsolid close ( 10 ) ! Compute vortex ring coordinates !$omp parallel do do i = 1 , this % nc this % blade ( 1 )% wiP ( i , 1 )% PC (:, 4 ) = this % blade ( 1 )% wiP ( i , 1 )% PC (:, 3 ) call this % blade ( 1 )% wiP ( i , 1 )% vr % assignP ( 1 , & & this % blade ( 1 )% wiP ( i , 1 )% PC (:, 1 )) call this % blade ( 1 )% wiP ( i , 1 )% vr % assignP ( 2 , & & this % blade ( 1 )% wiP ( i , 1 )% PC (:, 2 )) call this % blade ( 1 )% wiP ( i , 1 )% vr % assignP ( 3 , & & this % blade ( 1 )% wiP ( i , 1 )% PC (:, 3 )) call this % blade ( 1 )% wiP ( i , 1 )% vr % assignP ( 4 , & & this % blade ( 1 )% wiP ( i , 1 )% PC (:, 4 )) enddo !$omp end parallel do end subroutine rotor_stltoblade function rotor_getCamber ( this , x , y ) !! Get z coordinate on wing from x, y values ! File format: ! <num of lines> ! <x1>  <z1> ! <x2>  <z2> ! ... use libMath , only : interp1d class ( rotor_class ) :: this real ( dp ), intent ( in ), dimension (:) :: x , y real ( dp ), dimension ( size ( x ), size ( y )) :: rotor_getCamber real ( dp ), dimension ( 5000 , this % nCamberFiles ) :: xCamber , zCamber real ( dp ) :: chord , span integer , dimension ( this % nCamberFiles ) :: nPts integer :: iSect , fNum , i , j chord = x ( size ( x )) - x ( 1 ) span = y ( size ( y )) - y ( 1 ) ! Read camber data do j = 1 , this % nCamberFiles if ( this % camberFile ( j )( 1 : 1 ) == '0' ) then nPts ( j ) = 2 xCamber ( 1 : 2 , j ) = [ 0._dp , 1._dp ] zCamber ( 1 : 2 , j ) = 0._dp else open ( unit = 15 , file = this % camberFile ( j )) read ( 15 , * ) nPts ( j ) do i = 1 , nPts ( j ) read ( 15 , * ) xCamber ( i , j ), zCamber ( i , j ) enddo close ( 15 ) zCamber (:, j ) = zCamber (:, j ) / xCamber ( nPts ( j ), j ) xCamber (:, j ) = xCamber (:, j ) / xCamber ( nPts ( j ), j ) endif enddo do j = 1 , size ( y ) ! Check which sectionLimit y value comes under ! to determine airfoil file to use do iSect = 1 , this % nCamberFiles if ( y ( j ) / span <= this % camberSectionLimit ( iSect )) then fNum = iSect exit endif enddo do i = 1 , size ( x ) rotor_getCamber ( i , j ) = chord * interp1d (( x ( i ) - x ( 1 )) / chord , & & xCamber ( 1 : nPts ( fNum ), fNum ), zCamber ( 1 : nPts ( fNum ), fNum ), 2 ) enddo enddo end function rotor_getCamber function rotor_gettheta ( this , psi , ib ) !! Get pitch angle corresponding to blade azimuthal location class ( rotor_class ) :: this real ( dp ), intent ( in ) :: psi integer , intent ( in ) :: ib real ( dp ) :: rotor_gettheta real ( dp ) :: bladeOffset bladeOffset = twoPi / this % nb * ( ib - 1 ) select case ( this % pitchDynamicsSwitch ) case ( 0 ) ! Constant collective pitch rotor_gettheta = this % controlPitch ( 1 ) & + this % controlPitch ( 2 ) * cos ( psi + bladeOffset ) & + this % controlPitch ( 3 ) * sin ( psi + bladeOffset ) case ( 1 ) ! Ramp collective pitch input rotor_gettheta = min ( abs ( psi / this % Omega * this % dpitch ), & & abs ( this % controlPitch ( 1 ))) if ( this % controlPitch ( 1 ) < 0 ) rotor_gettheta = - 1._dp * rotor_gettheta end select end function rotor_gettheta function rotor_getthetadot ( this , psi , ib ) class ( rotor_class ) :: this real ( dp ), intent ( in ) :: psi integer , intent ( in ) :: ib real ( dp ) :: rotor_getthetadot real ( dp ) :: bladeOffset bladeOffset = twoPi / this % nb * ( ib - 1 ) rotor_getthetadot = - this % controlPitch ( 2 ) * sin ( psi + bladeOffset ) & + this % controlPitch ( 3 ) * cos ( psi + bladeOffset ) end function rotor_getthetadot subroutine rotor_calcAIC ( this ) !! Compute AIC matrix for rotor use libMath , only : inv2 class ( rotor_class ), intent ( inout ) :: this integer :: ib , jblade , is , ic , i , j , row , col real ( dp ), dimension ( 3 ) :: vec_dummy ! Influence Coefficient Matrix !$omp parallel do private(row, col) collapse(3) do ib = 1 , this % nb do is = 1 , this % ns ! Collocation point loop do ic = 1 , this % nc row = ic + this % nc * ( is - 1 ) + this % ns * this % nc * ( ib - 1 ) do jblade = 1 , this % nb do j = 1 , this % ns ! Vortex ring loop do i = 1 , this % nc col = i + this % nc * ( j - 1 ) + this % ns * this % nc * ( jblade - 1 ) vec_dummy = this % blade ( jblade )% wiP ( i , j )% vr % vind ( this % blade ( ib )% wiP ( ic , is )% CP ) this % AIC ( row , col ) = dot_product ( vec_dummy , this % blade ( ib )% wiP ( ic , is )% nCap ) enddo enddo enddo enddo enddo enddo !$omp end parallel do this % AIC_inv = inv2 ( this % AIC ) end subroutine rotor_calcAIC subroutine rotor_map_gam ( this ) !! Map gam from vector to matrix format class ( rotor_class ), intent ( inout ) :: this integer :: ib do ib = 1 , this % nbConvect this % blade ( ib )% wiP % vr % gam & = reshape ( this % gamVec ( 1 + this % nc * this % ns * ( ib - 1 ): this % nc * this % ns * ib ), & & [ this % nc , this % ns ]) enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb this % blade ( ib )% wiP % vr % gam = this % blade ( 1 )% wiP % vr % gam enddo endif axisym end subroutine rotor_map_gam !-----+------------------+-----| ! -+- | Motion Functions | -+- | !-----+------------------+-----| subroutine rotor_move ( this , dshift ) class ( rotor_class ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: dshift integer :: ib do ib = 1 , this % nb call this % blade ( ib )% move ( dshift ) enddo this % hubCoords = this % hubCoords + dshift this % cgCoords = this % cgCoords + dshift end subroutine rotor_move subroutine rotor_rot_pts ( this , pts , origin , order ) !! Rotate using pts => phi theta psi !! Warning: This rotation is about the global reference frame use libMath , only : Tbg , Tgb class ( rotor_class ), intent ( inout ) :: this real ( dp ), dimension ( 3 ), intent ( in ) :: pts ! pts => phi,theta,psi real ( dp ), dimension ( 3 ), intent ( in ) :: origin ! rotation about integer , intent ( in ) :: order ! [1]gb & +ve theta , [2]bg & -ve theta integer :: ib real ( dp ), dimension ( 3 , 3 ) :: TMat select case ( order ) case ( 2 ) TMat = Tbg ([ cos ( pts ( 1 )), sin ( pts ( 1 ))], & [ cos ( pts ( 2 )), sin ( pts ( 2 ))], & [ cos ( pts ( 3 )), sin ( pts ( 3 ))]) case ( 1 ) TMat = Tgb ([ cos ( pts ( 1 )), sin ( pts ( 1 ))], & [ cos ( pts ( 2 )), sin ( pts ( 2 ))], & [ cos ( pts ( 3 )), sin ( pts ( 3 ))]) case default error stop 'ERROR: wrong option for order' end select do ib = 1 , this % nb call this % blade ( ib )% rot_pts ( pts , origin , order ) enddo this % shaftAxis = matmul ( TMat , this % shaftAxis ) this % xAxisBody = matmul ( TMat , this % xAxisBody ) this % yAxisBody = matmul ( TMat , this % yAxisBody ) this % zAxisBody = matmul ( TMat , this % zAxisBody ) this % hubCoords = matmul ( TMat , this % hubCoords - origin ) + origin this % cgCoords = matmul ( TMat , this % cgCoords - origin ) + origin end subroutine rotor_rot_pts subroutine rotor_rot_flap ( this ) !! Rotate blades by flap angle class ( rotor_class ), intent ( inout ) :: this integer :: ib do ib = 1 , this % nb call this % blade ( ib )% rot_flap ( & & this % blade ( ib )% flap - this % blade ( ib )% flapPrev ) enddo end subroutine rotor_rot_flap subroutine rotor_rot_advance ( this , dpsi , nopitch ) !! Rotate rotor by dpsi angle about axis class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dpsi logical , optional :: nopitch integer :: ib real ( dp ) :: thetaNext this % psi = this % psi + dpsi do ib = 1 , this % nb call this % blade ( ib )% rotate ( dpsi , & & this % shaftAxis ( 1 ), this % shaftAxis ( 2 ), this % shaftAxis ( 3 ), & & this % hubCoords ( 1 ), this % hubCoords ( 2 ), this % hubCoords ( 3 ), & & 'azimuth' ) this % blade ( ib )% psi = this % blade ( ib )% psi + dpsi if (. not . present ( nopitch )) then thetaNext = this % gettheta ( this % psi , ib ) call this % blade ( ib )% rot_pitch ( thetaNext - this % blade ( ib )% theta ) this % blade ( ib )% theta = thetaNext elseif ( nopitch . eqv . . false .) then thetaNext = this % gettheta ( this % psi , ib ) call this % blade ( ib )% rot_pitch ( thetaNext - this % blade ( ib )% theta ) this % blade ( ib )% theta = thetaNext endif enddo end subroutine rotor_rot_advance !-----+---------------------------+-----| ! -+- | Wake Convection Functions | -+- | !-----+---------------------------+-----| subroutine rotor_assignshed ( this , edge ) !! Assign coordinates to first rowNear of wake from last row of blade class ( rotor_class ), intent ( inout ) :: this character ( len = 2 ), intent ( in ) :: edge integer :: i , ib select case ( edge ) case ( 'LE' ) ! assign to LE do ib = 1 , this % nb do i = 1 , this % ns call this % blade ( ib )% waN ( this % rowNear , i )% vr % assignP ( 1 , this % blade ( ib )% wiP ( this % nc , i )% vr % vf ( 2 )% fc (:, 1 )) call this % blade ( ib )% waN ( this % rowNear , i )% vr % assignP ( 4 , this % blade ( ib )% wiP ( this % nc , i )% vr % vf ( 3 )% fc (:, 1 )) call this % blade ( ib )% waN ( this % rowNear , i )% vr % calclength (. TRUE .) ! TRUE => record original length enddo this % blade ( ib )% waN ( this % rowNear , :)% vr % gam = this % blade ( ib )% wiP ( this % nc , :)% vr % gam enddo case ( 'TE' ) ! assign to next row's TE do ib = 1 , this % nb do i = 1 , this % ns call this % blade ( ib )% waN ( max ( this % rowNear - 1 , 1 ), i )% vr % assignP ( 2 , this % blade ( ib )% wiP ( this % nc , i )% vr % vf ( 2 )% fc (:, 1 )) call this % blade ( ib )% waN ( max ( this % rowNear - 1 , 1 ), i )% vr % assignP ( 3 , this % blade ( ib )% wiP ( this % nc , i )% vr % vf ( 3 )% fc (:, 1 )) enddo enddo case default error stop 'ERROR: Wrong option for edge' end select end subroutine rotor_assignshed !-----+----------------------------+-----| ! -+- | Wake Dissipation Functions | -+- | !-----+----------------------------+-----| subroutine rotor_age_wake ( this , dt ) !! Update age of wake filaments class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt integer :: ib , ifil do ib = 1 , this % nb do ifil = 1 , 4 this % blade ( ib )% waN ( this % rowNear : this % nNwake , :)% & & vr % vf ( ifil )% age = & & this % blade ( ib )% waN ( this % rowNear : this % nNwake , :)% & & vr % vf ( ifil )% age + dt this % blade ( ib )% waN ( this % rowNear : this % nNwake , :)% & & vr % vf ( ifil )% ageAzimuthal = & & this % blade ( ib )% waN ( this % rowNear : this % nNwake , :)% & & vr % vf ( ifil )% ageAzimuthal + dt * this % omegaSlow enddo this % blade ( ib )% waF ( this % rowFar : this % nFwake )% vf % age = & this % blade ( ib )% waF ( this % rowFar : this % nFwake )% vf % age + dt this % blade ( ib )% waF ( this % rowFar : this % nFwake )% vf % ageAzimuthal = & this % blade ( ib )% waF ( this % rowFar : this % nFwake )% vf % ageAzimuthal + & & dt * this % omegaSlow enddo end subroutine rotor_age_wake subroutine rotor_dissipate_wake ( this , dt , kinematicViscosity ) class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt , kinematicViscosity real ( dp ) :: oseenParameter integer :: ib , ic , is oseenParameter = 1.2564_dp ! Dissipate near wake do ib = 1 , this % nb do is = 1 , this % ns !$omp parallel do do ic = this % rowNear , this % nNwake this % blade ( ib )% waN ( ic , is )% vr % vf ( 1 )% rVc = & & sqrt ( this % blade ( ib )% waN ( ic , is )% vr % vf ( 1 )% rVc ** 2._dp & & + 4._dp * oseenParameter * this % apparentViscCoeff * kinematicViscosity * dt ) this % blade ( ib )% waN ( ic , is )% vr % vf ( 3 )% rVc = & & this % blade ( ib )% waN ( ic , is )% vr % vf ( 1 )% rVc ! Decay wake call this % blade ( ib )% waN ( ic , is )% vr % decay ( dt , this % decayCoeff ) enddo !$omp end parallel do ! To maintain consistency of rVc in overlapping filaments !$omp parallel do do ic = this % rowNear , this % nNwake this % blade ( ib )% waN ( ic , is )% vr % vf ( 2 )% rVc = sqrt ( this % blade ( ib )% waN ( ic , is )% vr % vf ( 2 )% rVc ** 2._dp & + 4._dp * oseenParameter * this % apparentViscCoeff * kinematicViscosity * dt ) enddo !$omp end parallel do if ( this % rowNear . ne . this % nNwake ) then !$omp parallel do do ic = this % rowNear + 1 , this % nNwake this % blade ( ib )% waN ( ic , is )% vr % vf ( 4 )% rVc = this % blade ( ib )% waN ( ic - 1 , is )% vr % vf ( 2 )% rVc enddo !$omp end parallel do endif enddo ! Dissipate far wake if present !$omp parallel do do ic = this % rowFar , this % nFwake this % blade ( ib )% waF ( ic )% vf % rVc = & & sqrt ( this % blade ( ib )% waF ( ic )% vf % rVc ** 2._dp & & + 4._dp * oseenParameter * this % apparentViscCoeff * & & kinematicViscosity * dt ) ! Decay wake call this % blade ( ib )% waF ( ic )% decay ( dt , this % decayCoeff ) enddo !$omp end parallel do enddo end subroutine rotor_dissipate_wake subroutine rotor_strain_wake ( this ) class ( rotor_class ), intent ( inout ) :: this integer :: i , ib do ib = 1 , this % nb !$omp parallel do do i = this % rowFar , this % nFwake call this % blade ( ib )% waF ( i )% vf % calclength (. FALSE .) ! Update current length call this % blade ( ib )% waF ( i )% vf % strain () enddo !$omp end parallel do enddo end subroutine rotor_strain_wake function rotor_vind_bywing ( this , P ) !! Compute induced velocity by all wing vortices at P class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: rotor_vind_bywing integer :: ib rotor_vind_bywing = 0._dp if ( abs ( this % surfaceType ) == 1 ) then do ib = 1 , this % nb rotor_vind_bywing = rotor_vind_bywing & & + this % blade ( ib )% vind_bywing ( P ) enddo elseif ( abs ( this % surfaceType ) == 2 ) then do ib = 1 , this % nb rotor_vind_bywing = rotor_vind_bywing & & + this % blade ( ib )% vindSource_bywing ( P ) enddo endif end function rotor_vind_bywing function rotor_vind_bywing_boundVortices ( this , P ) !! Compute induced velocity by bound vortices at P class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P real ( dp ), dimension ( 3 ) :: rotor_vind_bywing_boundVortices integer :: ib rotor_vind_bywing_boundVortices = 0._dp do ib = 1 , this % nb rotor_vind_bywing_boundVortices = rotor_vind_bywing_boundVortices & & + this % blade ( ib )% vind_bywing_boundVortices ( P ) enddo end function rotor_vind_bywing_boundVortices function rotor_vind_bywake ( this , P , optionalChar ) ! Compute induced velocity by wake vortices at P class ( rotor_class ), intent ( in ) :: this real ( dp ), intent ( in ), dimension ( 3 ) :: P character ( len = 1 ), optional :: optionalChar real ( dp ), dimension ( 3 ) :: rotor_vind_bywake integer :: ib rotor_vind_bywake = 0._dp if (. not . present ( optionalChar )) then do ib = 1 , this % nb rotor_vind_bywake = rotor_vind_bywake + this % blade ( ib )% vind_bywake ( this % rowNear , this % rowFar , P ) enddo elseif (( optionalChar . eq . 'P' ) . or . ( optionalChar . eq . 'p' )) then do ib = 1 , this % nb rotor_vind_bywake = rotor_vind_bywake + this % blade ( ib )% vind_bywake ( this % rowNear , this % rowFar , P , 'P' ) enddo else error stop 'ERROR: Wrong character flag for rotor_vind_bywake()' endif end function rotor_vind_bywake subroutine rotor_shiftwake ( this ) !! Shift wake locations on rollup class ( rotor_class ), intent ( inout ) :: this integer :: ib , i do ib = 1 , this % nb do i = this % nNwake , 2 , - 1 this % blade ( ib )% waN ( i , :) = this % blade ( ib )% waN ( i - 1 , :) enddo ! Wake age of first row has to be set to zero do i = 1 , 4 this % blade ( ib )% waN ( 1 , :)% vr % vf ( i )% age = 0._dp enddo enddo end subroutine rotor_shiftwake subroutine rotor_shiftFwake ( this ) !! Shift wake locations of Fwake for truncation class ( rotor_class ), intent ( inout ) :: this integer :: ib , i do ib = 1 , this % nb do i = this % nFwake , 2 , - 1 this % blade ( ib )% waF ( i ) = this % blade ( ib )% waF ( i - 1 ) enddo ! Wake age of first row has to be set to zero this % blade ( ib )% waF ( 1 )% vf % age = 0._dp enddo end subroutine rotor_shiftFwake subroutine rotor_rollup ( this ) !    2 !    |    &#94; Upstream !    |    | !    | !    1 class ( rotor_class ), intent ( inout ) :: this integer :: ib , ispan , rowFarNext real ( dp ), dimension ( 3 ) :: centroidLE , centroidTE real ( dp ) :: gamRollup , ageRollup , radiusRollup , gamSum rowFarNext = this % rowFar - 1 ! Rollup the vortex filament of 'next' row do ib = 1 , this % nb gamRollup = this % blade ( ib )% waN ( this % nNwake , this % ns )% vr % gam centroidLE = 0._dp centroidTE = 0._dp radiusRollup = 0._dp gamSum = 0._dp do ispan = this % rollupStart , this % rollupEnd ! Find centroid LE and TE centroidLE = centroidLE + this % blade ( ib )% waN ( this % nNwake , ispan )% vr % vf ( 4 )% fc (:, 1 ) * & this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam centroidTE = centroidTE + this % blade ( ib )% waN ( this % nNwake , ispan )% vr % vf ( 3 )% fc (:, 1 ) * & this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam gamSum = gamSum + this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam ! Assign gamRollup and radiusRollup from last row to wake filament gamma ! Compute gamRollup if ( sign ( 1._dp , this % Omega * this % controlPitch ( 1 )) > eps ) then ! +ve Omega or zero Omega with +ve pitch if ( this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam < gamRollup ) then ! '<' because of negative gamma gamRollup = this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam endif else ! one of Omega or pitch is negative if ( this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam > gamRollup ) then ! '>' because of positive gamma gamRollup = this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam endif endif ! Compute radiusRollup radiusRollup = radiusRollup + this % blade ( ib )% waN ( this % nNwake , ispan )% vr % vf ( 3 )% rVc * & this % blade ( ib )% waN ( this % nNwake , ispan )% vr % gam enddo ageRollup = this % blade ( ib )% waN ( this % nNwake , this % ns )% vr % vf ( 3 )% age if ( abs ( gamSum ) > eps ) then centroidLE = centroidLE / gamSum centroidTE = centroidTE / gamSum radiusRollup = radiusRollup / gamSum else centroidLE = this % blade ( ib )% waN ( this % nNwake , this % rollupEnd )% vr % vf ( 2 )% fc (:, 1 ) centroidTE = this % blade ( ib )% waN ( this % nNwake , this % rollupEnd )% vr % vf ( 3 )% fc (:, 1 ) radiusRollup = this % blade ( ib )% waN ( this % nNwake , this % rollupEnd )% vr % vf ( 3 )% rVc endif ! Suppress Fwake gam if required if ( this % suppressFwakeSwitch . eq . 1 ) gamRollup = 0._dp if ( this % nFwake > 0 ) then if ( rowFarNext == 0 ) then ! If no more far wakes exist to assign rolledup wake to, ! then shift far wakes by one step for truncation call this % shiftFwake () rowFarNext = 1 endif ! Initialize far wake tip this % blade ( ib )% waF ( rowFarNext )% vf % fc (:, 2 ) = centroidLE this % blade ( ib )% waF ( rowFarNext )% vf % fc (:, 1 ) = centroidTE this % blade ( ib )% waF ( rowFarNext )% gam = gamRollup this % blade ( ib )% waF ( rowFarNext )% vf % age = ageRollup this % blade ( ib )% waF ( rowFarNext )% vf % rVc0 = radiusRollup this % blade ( ib )% waF ( rowFarNext )% vf % rVc = radiusRollup ! TRUE => record original length call this % blade ( ib )% waF ( rowFarNext )% vf % calclength (. TRUE .) ! Ensure continuity in far wake by assigning ! current centroidTE to LE of previous far wake filament ! The discontinuity would occur due to convection of ! last row of waN in convectwake() if ( rowFarNext < this % nFwake ) then this % blade ( ib )% waF ( rowFarNext + 1 )% vf % fc (:, 2 ) = centroidTE endif endif enddo ! Shift near wake panels after rollup call this % shiftwake () end subroutine rotor_rollup subroutine rotor_calc_force ( this , density , dt ) !! Compute force from circulation class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: density , dt integer :: ib , ic , is this % forceInertial = 0._dp call this % dirLiftDrag () do ib = 1 , this % nbConvect call this % blade ( ib )% calc_force ( density , this % Omega , dt ) enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb this % blade ( ib )% wiP % delP = this % blade ( 1 )% wiP % delP this % blade ( ib )% wiP % delPUnsteady = this % blade ( 1 )% wiP % delPUnsteady this % blade ( ib )% wiP % gamPrev = this % blade ( 1 )% wiP % gamPrev this % blade ( ib )% wiP % delDiConstant = this % blade ( 1 )% wiP % delDiConstant this % blade ( ib )% wiP % delDiUnsteady = this % blade ( 1 )% wiP % delDiUnsteady do is = 1 , this % ns do ic = 1 , this % nc this % blade ( ib )% wiP ( ic , is )% normalForce = & & this % blade ( 1 )% wiP ( ic , is )% normalForce this % blade ( ib )% wiP ( ic , is )% normalForceUnsteady = & & this % blade ( 1 )% wiP ( ic , is )% normalForceUnsteady enddo enddo this % blade ( ib )% secForceInertial = this % blade ( 1 )% secForceInertial this % blade ( ib )% secLift = this % blade ( 1 )% secLift this % blade ( ib )% secLiftDir = this % blade ( 1 )% secLiftDir this % blade ( ib )% secLiftUnsteady = this % blade ( 1 )% secLiftUnsteady this % blade ( ib )% secLiftInPlane = this % blade ( 1 )% secLiftInPlane this % blade ( ib )% secLiftOutPlane = this % blade ( 1 )% secLiftOutPlane this % blade ( ib )% secLiftInPlaneUnsteady = & & this % blade ( 1 )% secLiftInPlaneUnsteady this % blade ( ib )% secLiftOutPlaneUnsteady = & & this % blade ( 1 )% secLiftOutPlaneUnsteady this % blade ( ib )% secDragUnsteady = this % blade ( 1 )% secDragUnsteady this % blade ( ib )% secDragProfile = this % blade ( 1 )% secDragProfile this % blade ( ib )% secDrag = this % blade ( 1 )% secDrag this % blade ( ib )% secCL = this % blade ( 1 )% secCL this % blade ( ib )% secCD = this % blade ( 1 )% secCD this % blade ( ib )% secCLu = this % blade ( 1 )% secCLu this % blade ( ib )% secMflap = this % blade ( 1 )% secMflap this % blade ( ib )% forceInertial = this % blade ( 1 )% forceInertial this % blade ( ib )% lift = this % blade ( 1 )% lift this % blade ( ib )% drag = this % blade ( 1 )% drag this % blade ( ib )% liftUnsteady = this % blade ( 1 )% liftUnsteady this % blade ( ib )% dragProfile = this % blade ( 1 )% dragProfile this % blade ( ib )% dragInduced = this % blade ( 1 )% dragInduced this % blade ( ib )% dragUnsteady = this % blade ( 1 )% dragUnsteady this % blade ( ib )% MflapLift = this % blade ( 1 )% MflapLift enddo endif axisym call this % sumBladeToNetForces () end subroutine rotor_calc_force ! subroutine rotor_calc_force_gamma(this, density, dt) !   ! Compute force from circulation ! class(rotor_class), intent(inout) :: this !   real(dp), intent(in) :: density, dt !   integer :: ib, ic, is ! !   this%forceInertial = 0._dp !   do ib = 1, this%nbConvect !     call this%blade(ib)%calc_force_gamma(density, & !       & sign(1._dp, this%Omega) * sign(1._dp, this%controlPitch(1)) * & !       & sign(1._dp, this%shaftAxis(1)) * & !       & sign(1._dp, this%shaftAxis(2)) * & !       & sign(1._dp, this%shaftAxis(3)), dt) !   enddo ! !   axisym: if (this%axisymmetrySwitch .eq. 1) then !     do ib = 2, this%nb !       this%blade(ib)%wiP%delP = this%blade(1)%wiP%delP !       this%blade(ib)%wiP%delPUnsteady = this%blade(1)%wiP%delPUnsteady !       this%blade(ib)%wiP%gamPrev = this%blade(1)%wiP%gamPrev ! !       this%blade(ib)%wiP%delDiConstant = this%blade(1)%wiP%delDiConstant !       this%blade(ib)%wiP%delDiUnsteady = this%blade(1)%wiP%delDiUnsteady ! !       do is = 1, this%ns !         do ic = 1, this%nc !           this%blade(ib)%wiP(ic, is)%normalForce = & !             & this%blade(1)%wiP(ic, is)%normalForce !           this%blade(ib)%wiP(ic, is)%normalForceUnsteady = & !             & this%blade(1)%wiP(ic, is)%normalForceUnsteady !         enddo !       enddo ! !       this%blade(ib)%secForceInertial = this%blade(1)%secForceInertial !       this%blade(ib)%secLift = this%blade(1)%secLift !       this%blade(ib)%secLiftDir = this%blade(1)%secLiftDir !       this%blade(ib)%secLiftUnsteady = this%blade(1)%secLiftUnsteady ! !       this%blade(ib)%secDragUnsteady = this%blade(1)%secDragUnsteady !       this%blade(ib)%secDragProfile = this%blade(1)%secDragProfile !       this%blade(ib)%secDrag = this%blade(1)%secDrag ! !       this%blade(ib)%secCL = this%blade(1)%secCL !       this%blade(ib)%secCD = this%blade(1)%secCD !       this%blade(ib)%secCLu = this%blade(1)%secCLu !       this%blade(ib)%secMflap = this%blade(1)%secMflap ! !       this%blade(ib)%forceInertial = this%blade(1)%forceInertial !       this%blade(ib)%lift = this%blade(1)%lift !       this%blade(ib)%drag = this%blade(1)%drag !       this%blade(ib)%liftUnsteady = this%blade(1)%liftUnsteady !       this%blade(ib)%dragProfile = this%blade(1)%dragProfile !       this%blade(ib)%dragInduced = this%blade(1)%dragInduced !       this%blade(ib)%dragUnsteady = this%blade(1)%dragUnsteady !       this%blade(ib)%MflapLift = this%blade(1)%MflapLift !     enddo !   endif axisym ! !   call this%sumBladeToNetForces() ! end subroutine rotor_calc_force_gamma subroutine rotor_calc_force_alpha ( this , density , velSound ) !! Compute force from sec alpha class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: density , velSound integer :: ib this % forceInertial = 0._dp call this % dirLiftDrag () do ib = 1 , this % nb call this % blade ( ib )% calc_force_alpha ( density , velSound ) enddo call this % sumBladeToNetForces () end subroutine rotor_calc_force_alpha subroutine rotor_calc_force_alphaGamma ( this , density , velSound , dt ) !! Compute force from sec alpha class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: density , velSound , dt integer :: ib this % forceInertial = 0._dp call this % dirLiftDrag () do ib = 1 , this % nb call this % blade ( ib )% calc_force_alphaGamma ( density , & & sign ( 1._dp , this % Omega * this % controlPitch ( 1 )), & & velSound , dt ) enddo call this % sumBladeToNetForces () end subroutine rotor_calc_force_alphaGamma subroutine rotor_calc_secAlpha ( this ) use libMath class ( rotor_class ), intent ( inout ) :: this real ( dp ), dimension ( 3 ) :: verticalAxis integer :: ib do ib = 1 , this % nbConvect verticalAxis = this % blade ( ib )% zAxisAziFlap call this % blade ( ib )% calc_secAlpha ( verticalAxis ) enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb this % blade ( ib )% secAlpha = this % blade ( 1 )% secAlpha this % blade ( ib )% secPhi = this % blade ( 1 )% secPhi this % blade ( ib )% secTheta = this % blade ( 1 )% secTheta enddo endif axisym end subroutine rotor_calc_secAlpha subroutine rotor_convectwake ( this , iter , dt , wakeType ) class ( rotor_class ), intent ( inout ) :: this integer , intent ( in ) :: iter real ( dp ), intent ( in ) :: dt character ( len = 1 ), intent ( in ) :: wakeType ! For predicted wake integer :: ib real ( dp ) :: bladeOffset do ib = 1 , this % nbConvect ! Wake velocity limiter turned off since it's not tested thoroghly ! call this%blade(ib)%limitWakeVel(this%rowNear, this%rowFar) call this % blade ( ib )% convectwake ( this % rowNear , this % rowFar , dt , wakeType ) enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb bladeOffset = twoPi / this % nb * ( ib - 1 ) ! Copy wakes from blade1 select case ( wakeType ) case ( 'C' ) this % blade ( ib )% waN ( this % rowNear :, :) = & & this % blade ( 1 )% waN ( this % rowNear :, :) this % blade ( ib )% waF ( this % rowFar :) = & & this % blade ( 1 )% waF ( this % rowFar :) case ( 'P' ) this % blade ( ib )% waNPredicted ( this % rowNear :, :) = & & this % blade ( 1 )% waNPredicted ( this % rowNear :, :) this % blade ( ib )% waFPredicted ( this % rowFar :) = & & this % blade ( 1 )% waFPredicted ( this % rowFar :) case default error stop 'ERROR: Wrong character flag for convectwake()' end select ! Rotate wakes to correct positions call this % blade ( ib )% rot_wake_axis ( bladeOffset , & & this % shaftAxis , this % hubCoords , this % rowNear , this % rowFar , wakeType ) enddo endif axisym ! Add prescribed wake if ( this % prescWakeNt > 0 . and . iter > this % prescWakeNt ) then call this % updatePrescribedWake ( dt , wakeType ) endif end subroutine rotor_convectwake subroutine rotor_computeBladeDynamics ( this , dt ) class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt integer :: ib do ib = 1 , this % nbConvect call this % blade ( ib )% computeBladeDynamics ( dt , this % omegaSlow ) enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb this % blade ( ib )% flap = this % blade ( 1 )% flap this % blade ( ib )% dflap = this % blade ( 1 )% dflap this % blade ( ib )% flapPrev = this % blade ( 1 )% flapPrev this % blade ( ib )% dflapPrev = this % blade ( 1 )% dflapPrev enddo endif axisym end subroutine rotor_computeBladeDynamics function getdw ( this , w , thrust ) class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: w , thrust real ( dp ) :: mass , planformArea , gravity , dragCoeff , dragFactor real ( dp ) :: getdw mass = 0.88_dp / 4._dp planformArea = 0.0587_dp / 4._dp gravity = 9.81 dragCoeff = 1.28 dragFactor = 0.5_dp * dragCoeff * 1.0 * planformArea getdw = ( thrust - dragFactor * abs ( w ) * w ) / mass - gravity ! max function to avoid ground penetration with negative dw ! Only axial climb from ground getdw = max ( 0._dp , getdw ) end function getdw subroutine rotor_computeBodyDynamics ( this , dt ) class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt real ( dp ) :: wPred , wNew integer :: exitcode if ( this % bodyDynamicsIOVars . eq . 0 ) then ! AM2 predictor corrector ! Predictor step wPred = this % velBody ( 3 ) + 0.5_dp * dt * & & ( 3._dp * this % getdw ( this % velBody ( 3 ), norm2 ( this % lift )) - & & this % getdw ( this % velBodyPrev ( 3 ), norm2 ( this % liftPrev ))) ! Corrector step wNew = this % velBody ( 3 ) + 0.5_dp * dt * & & ( this % getdw ( wPred , norm2 ( this % lift )) + & & this % getdw ( this % velBody ( 3 ), norm2 ( this % lift ))) this % velBodyPrev = this % velBody this % velBody ( 3 ) = wNew elseif ( this % bodyDynamicsIOVars . eq . 1 ) then ! Autorotation / Controlled descent open ( unit = 10 , file = 'dynamics.dat' , action = 'write' , status = 'replace' ) write ( 10 , '(2F15.7)' ) this % velBody ( 3 ), this % omegaSlow close ( 10 ) call execute_command_line ( 'python3 dynamics.py' , wait = . True ., & & exitstat = exitcode ) if ( exitcode . ne . 0 ) then error stop 'ERROR: dynamics.py returned non-zero exit code' endif open ( unit = 10 , file = 'dynamics.dat' , action = 'read' , status = 'old' ) read ( 10 , * ) this % velBody ( 3 ), this % omegaSlow , this % controlPitch ( 1 ) close ( 10 ) endif end subroutine rotor_computeBodyDynamics subroutine rotor_burst_wake ( this ) class ( rotor_class ), intent ( inout ) :: this integer :: ib do ib = 1 , this % nb call this % blade ( ib )% burst_wake ( this % rowFar , this % skewLimit , this % chord ) enddo end subroutine rotor_burst_wake subroutine rotor_calc_skew ( this ) class ( rotor_class ), intent ( inout ) :: this integer :: ib , icol , irow do ib = 1 , this % nbConvect call this % blade ( ib )% calc_skew ( this % rowNear ) enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb do icol = 1 , size ( this % blade ( ib )% waN , 2 ) do irow = this % rowNear , size ( this % blade ( ib )% waN , 1 ) this % blade ( ib )% waN ( irow , icol )% vr % skew = & & this % blade ( 1 )% waN ( irow , icol )% vr % skew enddo enddo enddo endif axisym end subroutine rotor_calc_skew subroutine rotor_dirLiftDrag ( this ) class ( rotor_class ), intent ( inout ) :: this integer :: ib do ib = 1 , this % nbConvect call this % blade ( ib )% calc_secChordwiseResVel () call this % blade ( ib )% dirLiftDrag ( this % Omega ) enddo axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb this % blade ( ib )% secDragDir = this % blade ( 1 )% secDragDir this % blade ( ib )% secLiftDir = this % blade ( 1 )% secLiftDir enddo endif axisym end subroutine rotor_dirLiftDrag subroutine rotor_sumBladeToNetForces ( this ) class ( rotor_class ), intent ( inout ) :: this integer :: ib axisym : if ( this % axisymmetrySwitch . eq . 1 ) then this % forceInertial = this % nb * this % blade ( 1 )% forceInertial this % liftPrev = this % lift this % lift = this % nb * this % blade ( 1 )% lift this % drag = this % nb * this % blade ( 1 )% drag this % liftUnsteady = this % nb * this % blade ( 1 )% liftUnsteady this % dragInduced = this % nb * this % blade ( 1 )% dragInduced this % dragProfile = this % nb * this % blade ( 1 )% dragProfile this % dragUnsteady = this % nb * this % blade ( 1 )% dragUnsteady else this % forceInertial = 0._dp this % liftPrev = this % lift this % lift = 0._dp this % drag = 0._dp this % liftUnsteady = 0._dp this % dragInduced = 0._dp this % dragProfile = 0._dp this % dragUnsteady = 0._dp do ib = 1 , this % nbConvect this % forceInertial = this % forceInertial + this % blade ( ib )% forceInertial this % lift = this % lift + this % blade ( ib )% lift this % drag = this % drag + this % blade ( ib )% drag this % liftUnsteady = this % liftUnsteady + this % blade ( ib )% liftUnsteady this % dragInduced = this % dragInduced + this % blade ( ib )% dragInduced this % dragProfile = this % dragProfile + this % blade ( ib )% dragProfile this % dragUnsteady = this % dragUnsteady + this % blade ( ib )% dragUnsteady enddo endif axisym end subroutine rotor_sumBladeToNetForces subroutine rotor_mirrorGamma ( this , fromRotor ) !! Mirrors gamma from another rotor class ( rotor_class ), intent ( inout ) :: this class ( rotor_class ), intent ( in ) :: fromRotor this % gamVec = - 1.0_dp * fromRotor % gamVec end subroutine rotor_mirrorGamma subroutine rotor_mirrorVelCP ( this , fromRotor ) !! Mirrors velCP, velCPm from another rotor class ( rotor_class ), intent ( inout ) :: this class ( rotor_class ), intent ( in ) :: fromRotor integer :: ic , is , ib do ib = 1 , this % nb !$omp parallel do collapse (2) do is = 1 , this % ns do ic = 1 , this % nc this % blade ( ib )% wiP ( ic , is )% velCP = & & fromRotor % blade ( ib )% wip ( ic , is )% velCP this % blade ( ib )% wiP ( ic , is )% velCPm = & & fromRotor % blade ( ib )% wip ( ic , is )% velCPm enddo enddo !$omp end parallel do enddo do ib = 1 , this % nb this % blade ( ib )% wiP % velCP ( this % imagePlane ) = & & - 1._dp * this % blade ( ib )% wiP % velCP ( this % imagePlane ) this % blade ( ib )% wiP % velCPm ( this % imagePlane ) = & & - 1._dp * this % blade ( ib )% wiP % velCPm ( this % imagePlane ) enddo end subroutine rotor_mirrorVelCP subroutine rotor_mirrorWake ( this , fromRotor , wakeType ) !! Mirrors wake positions from another rotor class ( rotor_class ), intent ( inout ) :: this class ( rotor_class ), intent ( in ) :: fromRotor character ( len = 1 ), intent ( in ) :: wakeType ! For predicted wake integer :: ic , is , ib select case ( wakeType ) case ( 'A' ) ! [A]ll current wake do ib = 1 , this % nb !$omp parallel do collapse (2) do is = 1 , this % ns do ic = 1 , this % nNwake this % blade ( ib )% waN ( ic , is ) = fromRotor % blade ( ib )% waN ( ic , is ) enddo enddo !$omp end parallel do !$omp parallel do do ic = 1 , this % nFwake this % blade ( ib )% waF ( ic ) = fromRotor % blade ( ib )% waF ( ic ) enddo !$omp end parallel do enddo do ib = 1 , this % nb !$omp parallel do collapse (2) do is = 1 , this % ns do ic = 1 , this % nNwake call this % blade ( ib )% waN ( ic , is )% vr % mirror ( & & this % imagePlane ) enddo enddo !$omp end parallel do !$omp parallel do do ic = 1 , this % nFwake call this % blade ( ib )% waF ( ic )% mirror ( this % imagePlane ) enddo !$omp end parallel do enddo case ( 'C' ) ! [C]urrent wake do ib = 1 , this % nb !$omp parallel do collapse (2) do is = 1 , this % ns do ic = this % rowNear , this % nNwake this % blade ( ib )% waN ( ic , is ) = fromRotor % blade ( ib )% waN ( ic , is ) enddo enddo !$omp end parallel do !$omp parallel do do ic = this % rowFar , this % nFwake this % blade ( ib )% waF ( ic ) = fromRotor % blade ( ib )% waF ( ic ) enddo !$omp end parallel do enddo do ib = 1 , this % nb !$omp parallel do collapse (2) do is = 1 , this % ns do ic = this % rowNear , this % nNwake call this % blade ( ib )% waN ( ic , is )% vr % mirror ( & & this % imagePlane ) enddo enddo !$omp end parallel do !$omp parallel do do ic = this % rowFar , this % nFwake call this % blade ( ib )% waF ( ic )% mirror ( this % imagePlane ) enddo !$omp end parallel do enddo case ( 'P' ) ! [P]redicted wake do ib = 1 , this % nb !$omp parallel do collapse (2) do is = 1 , this % ns do ic = this % rowNear , this % nNwake this % blade ( ib )% waNPredicted ( ic , is ) = & & fromRotor % blade ( ib )% waNPredicted ( ic , is ) enddo enddo !$omp end parallel do !$omp parallel do do ic = this % rowFar , this % nFwake this % blade ( ib )% waFPredicted ( ic ) = & & fromRotor % blade ( ib )% waFPredicted ( ic ) enddo !$omp end parallel do enddo do ib = 1 , this % nb !$omp parallel do collapse (2) do is = 1 , this % ns do ic = this % rowNear , this % nNwake call this % blade ( ib )% waNPredicted ( ic , is )% vr % mirror ( & & this % imagePlane ) enddo enddo !$omp end parallel do !$omp parallel do do ic = this % rowFar , this % nFwake call this % blade ( ib )% waFPredicted ( ic )% mirror ( & & this % imagePlane ) enddo !$omp end parallel do enddo end select end subroutine rotor_mirrorWake subroutine rotor_toChordsRevs ( this , nsteps , dt ) !! Converts -ve nsteps to nsteps for corresponding no. of chords or revs class ( rotor_class ), intent ( inout ) :: this integer , intent ( inout ) :: nsteps real ( dp ), intent ( in ) :: dt if ( nsteps < 0 ) then if ( abs ( this % Omega ) < eps ) then ! Fixed wing ! nt chord distance nsteps = ceiling ( abs ( nsteps ) * this % chord / ( dt * norm2 ( this % velBody ))) else ! Rotor ! nt revs nsteps = ceiling ( twoPi * abs ( nsteps ) / ( abs ( this % Omega ) * dt )) endif endif end subroutine rotor_toChordsRevs subroutine rotor_eraseNwake ( this , rowErase ) !! Erase a near wake row by setting gamma to zero class ( rotor_class ), intent ( inout ) :: this integer , intent ( in ) :: rowErase integer :: ib do ib = 1 , this % nb this % blade ( ib )% waN ( rowErase , :)% vr % gam = 0._dp enddo end subroutine rotor_eraseNwake subroutine rotor_eraseFwake ( this , rowErase ) !! Erase a far wake row by setting gamma to zero class ( rotor_class ), intent ( inout ) :: this integer , intent ( in ) :: rowErase integer :: ib do ib = 1 , this % nb this % blade ( ib )% waF ( rowErase )% gam = 0._dp enddo end subroutine rotor_eraseFwake subroutine rotor_updatePrescribedWake ( this , dt , wakeType ) !! Attaches prescribed far wake class ( rotor_class ), intent ( inout ) :: this real ( dp ), intent ( in ) :: dt character ( len = 1 ), intent ( in ) :: wakeType real ( dp ) :: bladeOffset integer :: ib , rowStart if ( this % prescWakeGenNt == 0 ) then rowStart = this % rowFar else rowStart = this % nFwakeEnd - this % prescWakeGenNt endif ! This should ideally be handled by the blade_class select case ( wakeType ) case ( 'C' ) do ib = 1 , this % nbConvect call this % blade ( ib )% wapF % update ( & & this % blade ( ib )% waF ( rowStart : this % nFwakeEnd ), & & this % hubCoords , this % shaftAxis , this % omegaSlow * dt ) enddo case ( 'P' ) do ib = 1 , this % nbConvect call this % blade ( ib )% wapFPredicted % update ( & & this % blade ( ib )% waFPredicted ( rowStart : this % nFwakeEnd ), & & this % hubCoords , this % shaftAxis , this % omegaSlow * dt ) enddo end select axisym : if ( this % axisymmetrySwitch . eq . 1 ) then do ib = 2 , this % nb bladeOffset = twoPi / this % nb * ( ib - 1 ) select case ( wakeType ) case ( 'C' ) this % blade ( ib )% wapF = this % blade ( 1 )% wapF call this % blade ( ib )% wapF % rot_wake_axis ( bladeOffset , & & this % shaftAxis , this % hubCoords ) case ( 'P' ) this % blade ( ib )% wapFPredicted = this % blade ( 1 )% wapFPredicted call this % blade ( ib )% wapFPredicted % rot_wake_axis ( bladeOffset , & & this % shaftAxis , this % hubCoords ) end select enddo endif axisym end subroutine rotor_updatePrescribedWake subroutine rotor_read ( this , unit , iostat , iomsg ) class ( rotor_class ), intent ( inout ) :: this integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg read ( unit , iostat = iostat , iomsg = iomsg ) this % blade , & & this % nNwake , this % nFwake , this % omegaSlow , this % shaftAxis , & & this % hubCoords , this % cgCoords , & & this % forceInertial , this % lift , this % drag , & & this % liftUnsteady , & & this % dragInduced , this % dragProfile , this % dragUnsteady , & & this % liftUnitVec , this % dragUnitVec , this % sideUnitVec , & & this % psi , this % AIC , this % AIC_inv , & & this % gamVec , this % gamVecPrev , this % RHS , & & this % rowNear , this % rowFar end subroutine rotor_read subroutine rotor_write ( this , unit , iostat , iomsg ) class ( rotor_class ), intent ( in ) :: this integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg write ( unit , iostat = iostat , iomsg = iomsg ) this % blade , & & this % nNwake , this % nFwake , this % omegaSlow , this % shaftAxis , & & this % hubCoords , this % cgCoords , & & this % forceInertial , this % lift , this % drag , & & this % liftUnsteady , & & this % dragInduced , this % dragProfile , this % dragUnsteady , & & this % liftUnitVec , this % dragUnitVec , this % sideUnitVec , & & this % psi , this % AIC , this % AIC_inv , & & this % gamVec , this % gamVecPrev , this % RHS , & & this % rowNear , this % rowFar end subroutine rotor_write end module classdef","tags":"","loc":"sourcefile/classdef.f90.html"},{"title":"main.f90 – VOLCANOR","text":"Contents Programs main Source Code main.f90 Source Code program main use libMath , only : isInverse , cross_product , matmulAX , zAxis use libCommon use libPostprocess implicit none ! Ensure all necessary files exist inquire ( file = 'config.nml' , exist = fileExists ) if (. not . fileExists ) error stop 'ERROR: config.nml does not exist' ! Read config.in file print * call print_status ( 'Reading file ' // 'config.nml' ) call readConfig ( 'config.nml' , ResultsDir // 'config.nml' ) call print_status () ! SUCCESS ! Allocate rotor objects allocate ( rotor ( nr )) ! Read rotor??.in files do ir = 1 , nr write ( rotorChar , '(I0.2)' ) ir rotorFile = 'geom' // rotorChar // '.nml' inquire ( file = rotorFile , exist = fileExists ) call print_status ( 'Reading file ' // rotorFile ) if (. not . fileExists ) error stop 'ERROR: A geomXX.nml file does not exist' call rotor ( ir )% readGeom ( rotorFile , ResultsDir // rotorFile ) call print_status () ! SUCCESS enddo ! Rotor and wake initialization do ir = 1 , nr if ( rotor ( ir )% surfaceType . ge . 0 ) then call rotor ( ir )% init ( ir , density , dt , nt , switches ) else call rotor ( ir )% init ( ir , density , dt , nt , switches , & & rotor ( rotor ( ir )% imageRotorNum )) endif call params2file ( rotor ( ir ), nt , dt , nr , density , velSound , switches ) enddo ! Rotate wing pc, vr, cp and nCap by initial pitch angle do ir = 1 , nr do ib = 1 , rotor ( ir )% nb if ( rotor ( ir )% surfaceType == - 1 ) then rotor ( ir )% blade ( ib )% theta = & & rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% theta if ( rotor ( ir )% imagePlane == 3 ) then rotor ( ir )% blade ( ib )% theta = - 1._dp * rotor ( ir )% blade ( ib )% theta endif else rotor ( ir )% blade ( ib )% theta = rotor ( ir )% gettheta ( rotor ( ir )% psiStart , ib ) endif call rotor ( ir )% blade ( ib )% rot_pitch ( & sign ( 1._dp , rotor ( ir )% Omega ) * rotor ( ir )% blade ( ib )% theta ) enddo enddo ! Plot wing surface geometry do ir = 1 , nr call geomSurface2file ( rotor ( ir )) enddo ! Compute AIC and AIC_inv matrices for rotors do ir = 1 , nr if ( rotor ( ir )% surfaceType > 0 ) then call print_status ( 'Computing AIC matrix' ) call rotor ( ir )% calcAIC () if ( isInverse ( rotor ( ir )% AIC , rotor ( ir )% AIC_inv )) then call print_status () ! SUCCESS else ! if (abs(rotor(ir)%surfaceType) == 1) then stop 'Warning: Computed AIC_inv does not seem & & to be correct within given tolerance' ! endif endif endif enddo ! Initialize vel probes if ( switches % probe . eq . 1 ) then open ( unit = 10 , file = 'probes.in' , status = 'old' , action = 'read' ) read ( 10 , * ) switches % nProbes allocate ( probe ( 3 , switches % nProbes )) allocate ( probeVel ( 3 , switches % nProbes )) do i = 1 , switches % nProbes read ( 10 , * ) probe (:, i ), probeVel (:, i ) enddo close ( 10 ) endif ! Obtain initial solution without wake call print_status ( 'Computing initial solution' ) if ( switches % slowStart . gt . 0 ) then do ir = 1 , nr rotor ( ir )% omegaSlow = 0._dp enddo else do ir = 1 , nr rotor ( ir )% omegaSlow = rotor ( ir )% Omega enddo endif t = 0._dp iter = 0 write ( timestamp , '(I0.5)' ) iter ! Custom trajectory do ir = 1 , nr if ( rotor ( ir )% customTrajectorySwitch . eq . 1 ) then rotor ( ir )% velBody = rotor ( ir )% velBodyHistory (:, 1 ) rotor ( ir )% omegaBody = rotor ( ir )% omegaBodyHistory (:, 1 ) endif enddo ! Compute RHS for initial solution without wake ntSubInitLoop : do i = 0 , switches % ntSubInit do ir = 1 , nr if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Compute velCP and RHS for lifting and non-lifting surfaces do ib = 1 , rotor ( ir )% nbConvect do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc row = ic + rotor ( ir )% nc * ( is - 1 ) & + rotor ( ir )% ns * rotor ( ir )% nc * ( ib - 1 ) ! Translational, rotational, omega, flap vel rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP = & & - 1._dp * rotor ( ir )% velBody & & - cross_product ( rotor ( ir )% omegaBody , & & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP - rotor ( ir )% cgCoords ) & & - cross_product ( rotor ( ir )% omegaSlow * rotor ( ir )% shaftAxis , & & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP - rotor ( ir )% hubCoords ) & & - rotor ( ir )% blade ( ib )% secMFlapArm ( is ) * & & rotor ( ir )% blade ( ib )% dflap ! Record velocities due to motion for ! computing lift and drag directions rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPm = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP ! Velocity due to wing vortices of other rotors do jr = 1 , nr if ( ir . ne . jr ) then rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP + & rotor ( jr )% vind_bywing ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) endif enddo rotor ( ir )% RHS ( row ) = & dot_product ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP , & rotor ( ir )% blade ( ib )% wiP ( ic , is )% nCap ) ! Pitch vel !rotor(ir)%blade%(ib)%wing(ic,is)%velPitch= & !  rotor(ir)%thetadot_pitch(0._dp,ib)* & !  rotor(ir)%blade(ib)%wiP(ic,is)%rHinge !rotor(ir)%RHS(row)= RHS(row)+wing(ib,ic,is)%velPitch enddo enddo enddo axisymRHS0 : if ( rotor ( ir )% axisymmetrySwitch . eq . 1 ) then do ib = 2 , rotor ( ir )% nb rotor ( ir )% RHS ( & & rotor ( ir )% nc * rotor ( ir )% ns * ( ib - 1 ) + 1 : & & rotor ( ir )% nc * rotor ( ir )% ns * ib ) = & & rotor ( ir )% RHS ( 1 : rotor ( ir )% nc * rotor ( ir )% ns ) enddo endif axisymRHS0 else ! For image lifting and non-lifting surfaces, ! copy velCP and velCPm call rotor ( ir )% mirrorVelCP ( rotor ( rotor ( ir )% imageRotorNum )) endif rotor ( ir )% RHS = - 1._dp * rotor ( ir )% RHS enddo do ir = 1 , nr rotor ( ir )% gamVecPrev = rotor ( ir )% gamVec if ( rotor ( ir )% surfaceType . gt . 0 ) then rotor ( ir )% gamVec = matmulAX ( rotor ( ir )% AIC_inv , rotor ( ir )% RHS ) else ! Image lifting or non-lifting surface call rotor ( ir )% mirrorGamma ( rotor ( rotor ( ir )% imageRotorNum )) endif ! Map gamVec to wing gam for each blade in rotor call rotor ( ir )% map_gam () enddo ! Check if initialization using converged soultion is requested if ( switches % ntSubInit . ne . 0 ) then subIterResidual = 0._dp do ir = 1 , nr subIterResidual = max ( subIterResidual , & & norm2 ( rotor ( ir )% gamVec - rotor ( ir )% gamVecPrev )) enddo do ir = 1 , nr if ( subIterResidual . le . eps ) & exit ntSubInitLoop enddo endif enddo ntSubInitLoop if ( switches % ntSubInit . ne . 0 ) then if ( i . gt . switches % ntSubInit ) then print * print * , \"Initial solution did not converge. & & Try increasing sub-iterations.\" print * , 'Sub-iterations ' , i , subIterResidual else call print_status () ! SUCCESS print * , 'Sub-iterations ' , i , subIterResidual endif else call print_status () ! SUCCESS endif do ir = 1 , nr rotor ( ir )% rowFar = rotor ( ir )% nFwake + 1 ! Since assignshed TE assigns to rowNear-1 panel rotor ( ir )% rowNear = rotor ( ir )% nNwake + 1 if ( rotor ( ir )% nNwake > 0 ) then call rotor ( ir )% assignshed ( 'TE' ) ! Store shed vortex as TE endif enddo ! Compute forces if ( switches % rotorForcePlot . ne . 0 ) then call init_plots ( nr ) ! Create headers for plot files do ir = 1 , nr select case ( rotor ( ir )% forceCalcSwitch ) case ( 0 ) ! Compute using wing circulation ! Compute and plot alpha if requested ! Compute alpha do ib = 1 , rotor ( ir )% nbConvect do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc ! Compute local velocity vector ! (excluding induced velocities from wing bound vortices) rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP ! Neglect velocity due to spanwise vortices for all wings do jr = 1 , nr rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal - & rotor ( jr )% vind_bywing_boundVortices ( & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo ! Add self induced velocity due to wing vortices rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal + & rotor ( ir )% vind_bywing ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo enddo enddo axisym00 : if ( rotor ( ir )% axisymmetrySwitch . eq . 1 ) then do ib = 2 , rotor ( ir )% nb do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & & rotor ( ir )% blade ( 1 )% wiP ( ic , is )% velCPTotal enddo enddo enddo endif axisym00 call rotor ( ir )% calc_secAlpha () call rotor ( ir )% calc_force ( density , dt ) ! For the first iteration, assign the first flap moment to ! prev flap moment for use in flap dynamics equation do ib = 1 , rotor ( ir )% nb rotor ( ir )% blade ( ib )% MflapLiftPrev = rotor ( ir )% blade ( ib )% MflapLift enddo case ( 1 ) ! Compute using alpha ! Compute alpha do ib = 1 , rotor ( ir )% nbConvect do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc ! Compute local velocity vector ! (excluding induced velocities from wing bound vortices) rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP ! Neglect velocity due to spanwise vortices for all wings do jr = 1 , nr rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal - & rotor ( jr )% vind_bywing_boundVortices ( & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo ! Add self induced velocity due to wing vortices rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal + & rotor ( ir )% vind_bywing ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo enddo enddo axisym01 : if ( rotor ( ir )% axisymmetrySwitch . eq . 1 ) then do ib = 2 , rotor ( ir )% nb do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & & rotor ( ir )% blade ( 1 )% wiP ( ic , is )% velCPTotal enddo enddo enddo endif axisym01 call rotor ( ir )% calc_secAlpha () call rotor ( ir )% calc_force_alpha ( density , velSound ) case ( 2 ) ! Compute lift using alpha approximated from sec circulation call rotor ( ir )% calc_force_alphaGamma ( density , velSound , dt ) end select ! Initial force value call force2file ( timestamp , rotor ( ir )) ! Flap dynamics if ( rotor ( ir )% bladeDynamicsSwitch . ne . 0 ) then call dynamics2file ( timestamp , rotor ( ir )) if ( rotor ( ir )% surfaceType == - 1 ) then do ib = 1 , rotor ( ir )% nb if ( rotor ( ir )% imagePlane == 3 ) then rotor ( ir )% blade ( ib )% dflap = & & - 1._dp * rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% dflap rotor ( ir )% blade ( ib )% flap = & & - 1._dp * rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flap rotor ( ir )% blade ( ib )% flapPrev = & & - 1._dp * rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flapPrev else rotor ( ir )% blade ( ib )% dflap = & & rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% dflap rotor ( ir )% blade ( ib )% flap = & & rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flap rotor ( ir )% blade ( ib )% flapPrev = & & rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flapPrev endif enddo else call rotor ( ir )% computeBladeDynamics ( dt ) endif endif ! Body dynamics if ( rotor ( ir )% bodyDynamicsSwitch . ne . 0 ) then call dynamics2file ( timestamp , rotor ( ir )) if ( rotor ( ir )% surfaceType == - 1 ) then rotor ( ir )% velBody = rotor ( rotor ( ir )% imageRotorNum )% velBody rotor ( ir )% velBody ( rotor ( ir )% imagePlane ) = & & - 1._dp * rotor ( ir )% velBody ( rotor ( ir )% imagePlane ) else call rotor ( ir )% computeBodyDynamics ( dt ) endif endif enddo endif currentTime = '' ! ------- MAIN LOOP START ------- iterStart = 1 if ( switches % restartFromNt . gt . 0 ) then write ( timestamp , '(I0.5)' ) switches % restartFromNt open ( unit = 23 , file = 'Restart/restart' // timestamp // '.dat' , & & status = 'old' , action = 'read' , form = 'unformatted' ) read ( 23 ) t read ( 23 ) rotor close ( 23 ) iterStart = switches % restartFromNt + 1 endif do iter = iterStart , nt t = t + dt ! In case current time is required uncomment below line ! call date_and_time(time=currentTime) print * , currentTime , iter , nt write ( timestamp , '(I0.5)' ) iter ! rowNear and rowFar keep track of what row ! the current iteration is in for near wake and far wake do ir = 1 , nr rotor ( ir )% rowNear = max ( rotor ( ir )% rowNear - 1 , 1 ) if ( iter > rotor ( ir )% nNwake ) then rotor ( ir )% rowFar = max ( rotor ( ir )% rowFar - 1 , 1 ) endif enddo ! Use custom trajectory if specified do ir = 1 , nr if ( rotor ( ir )% customTrajectorySwitch . eq . 1 ) then rotor ( ir )% velBody = rotor ( ir )% velBodyHistory (:, iter ) rotor ( ir )% omegaBody = rotor ( ir )% omegaBodyHistory (:, iter ) endif enddo ! In case of slow start, determine RPM select case ( switches % slowStart ) case ( - 1 ) ! Body dynamics governed continue case ( 0 ) ! No slow start do ir = 1 , nr rotor ( ir )% omegaSlow = rotor ( ir )% Omega enddo case ( 1 ) ! Linear slope do ir = 1 , nr rotor ( ir )% omegaSlow = & min ( real ( switches % slowStartNt ), real ( iter + 1 )) * rotor ( ir )% Omega / switches % slowStartNt enddo case ( 2 ) ! tanh slope do ir = 1 , nr rotor ( ir )% omegaSlow = tanh ( 5._dp * iter / switches % slowStartNt ) * rotor ( ir )% Omega enddo case ( 3 ) ! tanh slope do ir = 1 , nr rotor ( ir )% omegaSlow = & ( tanh ( 6._dp * real ( iter ) / real ( switches % slowStartNt ) - 3._dp ) + 1._dp ) * & 0.5_dp * rotor ( ir )% Omega enddo case default error stop \"Assign correct slowStart\" end select ! Move wing to next position do ir = 1 , nr call rotor ( ir )% move ( rotor ( ir )% velBody * dt ) call rotor ( ir )% rot_pts ( rotor ( ir )% omegaBody * dt , rotor ( ir )% cgCoords , 1 ) call rotor ( ir )% rot_advance ( rotor ( ir )% omegaSlow * dt ) if ( rotor ( ir )% bladeDynamicsSwitch == 1 ) then call rotor ( ir )% rot_flap () endif enddo ! Assign LE of near wake if ( switches % wakeSuppress == 0 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then call rotor ( ir )% assignshed ( 'LE' ) ! Store shed vortex as LE endif enddo ! Update wake age do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then call rotor ( ir )% age_wake ( dt ) endif enddo ! Dissipate wake if ( switches % wakeDissipation . eq . 1 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then ! Wake tip dissipation call rotor ( ir )% dissipate_wake ( dt , kinematicVisc ) endif enddo endif ! Burst wake do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( switches % wakeBurst . ne . 0 ) then if ( mod ( iter , switches % wakeBurst ) . eq . 0 ) & call rotor ( ir )% burst_wake () endif ! Plot wake skew parameter if ( rotor ( ir )% skewPlotSwitch . ne . 0 ) then if ( mod ( iter , rotor ( ir )% skewPlotSwitch ) . eq . 0 ) then call rotor ( ir )% calc_skew () call skew2file ( timestamp , rotor ( ir )) endif endif endif enddo endif ! Write out wing n' wake do ir = 1 , nr if ( switches % wakePlot . ne . 0 ) then if ( mod ( iter , switches % wakePlot ) . eq . 0 ) & call geom2file ( timestamp , rotor ( ir ), switches % wakeSuppress ) endif if ( switches % wakeTipPlot . ne . 0 ) then if ( mod ( iter , switches % wakeTipPlot ) . eq . 0 ) & call tip2file ( timestamp , rotor ( ir )) endif enddo ! Compute RHS ntSubLoop : do i = 0 , switches % ntSub do ir = 1 , nr rotor ( ir )% RHS = 0._dp if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Compute velCP and RHS for lifting and non-lifting surfaces do ib = 1 , rotor ( ir )% nbConvect do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc row = ic + rotor ( ir )% nc * ( is - 1 ) & + rotor ( ir )% ns * rotor ( ir )% nc * ( ib - 1 ) ! Translational, rotationa, omega, flap vel rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP = & & - 1._dp * rotor ( ir )% velBody & & - cross_product ( rotor ( ir )% omegaBody , & & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP - rotor ( ir )% cgCoords ) & & - cross_product ( rotor ( ir )% omegaSlow * rotor ( ir )% shaftAxis , & & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP - rotor ( ir )% hubCoords ) & & - rotor ( ir )% blade ( ib )% secMFlapArm ( is ) * & & rotor ( ir )% blade ( ib )% dflap ! Record velocities due to motion for induced drag computation rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPm = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP do jr = 1 , nr ! Wake induced vel due to all rotors rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP + & rotor ( jr )% vind_bywake ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) ! Wing induced vel due to all rotors except self if ( ir . ne . jr ) then rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP + & rotor ( jr )% vind_bywing ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) endif enddo rotor ( ir )% RHS ( row ) = & dot_product ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP , & rotor ( ir )% blade ( ib )% wiP ( ic , is )% nCap ) ! Pitch vel !wing(ib,ic,is)%velPitch=thetadot*wing(ib,ic,is)%rHinge !RHS(row)=RHS(row)+wing(ib,ic,is)%velPitch enddo enddo enddo axisymRHS : if ( rotor ( ir )% axisymmetrySwitch . eq . 1 ) then do ib = 2 , rotor ( ir )% nb rotor ( ir )% RHS ( & & rotor ( ir )% nc * rotor ( ir )% ns * ( ib - 1 ) + 1 : & & rotor ( ir )% nc * rotor ( ir )% ns * ib ) = & & rotor ( ir )% RHS ( 1 : rotor ( ir )% nc * rotor ( ir )% ns ) enddo endif axisymRHS else ! For image lifting and non-lifting surfaces, ! copy velCP and velCPm call rotor ( ir )% mirrorVelCP ( rotor ( rotor ( ir )% imageRotorNum )) endif rotor ( ir )% RHS = - 1._dp * rotor ( ir )% RHS enddo do ir = 1 , nr rotor ( ir )% gamvecPrev = rotor ( ir )% gamVec if ( rotor ( ir )% surfaceType . gt . 0 ) then rotor ( ir )% gamVec = matmulAX ( rotor ( ir )% AIC_inv , rotor ( ir )% RHS ) else call rotor ( ir )% mirrorGamma ( rotor ( rotor ( ir )% imageRotorNum )) endif ! Map gamVec to wing gam for each blade in rotor call rotor ( ir )% map_gam () enddo ! Check if sub-iterations are requested if ( switches % ntSub . ne . 0 ) then subIterResidual = 0._dp do ir = 1 , nr subIterResidual = max ( subIterResidual , & & norm2 ( rotor ( ir )% gamVec - rotor ( ir )% gamVecPrev )) if ( subIterResidual . le . eps ) & & exit ntSubLoop enddo endif enddo ntSubLoop if ( switches % ntSub . ne . 0 ) then print * , 'Sub-iterations ' , i , subIterResidual if ( i . gt . switches % ntSub ) & & print * , 'Solution did not converge. Try increasing sub-iterations.' endif ! Compute forces if ( switches % rotorForcePlot . ne . 0 ) then if ( mod ( iter , switches % rotorForcePlot ) . eq . 0 ) then do ir = 1 , nr select case ( rotor ( ir )% forceCalcSwitch ) case ( 0 ) ! Compute using wing circulation ! Compute alpha do ib = 1 , rotor ( ir )% nbConvect do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc ! Compute local velocity vector ! (excluding induced velocities from wing bound vortices) rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP ! Neglect velocity due to spanwise vortices for all wings do jr = 1 , nr rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal = & & rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal - & & rotor ( jr )% vind_bywing_boundVortices ( & & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo ! Add self induced velocity due to wing vortices rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal + & & rotor ( ir )% vind_bywing ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo enddo enddo axisymx0 : if ( rotor ( ir )% axisymmetrySwitch . eq . 1 ) then do ib = 2 , rotor ( ir )% nb do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & & rotor ( ir )% blade ( 1 )% wiP ( ic , is )% velCPTotal enddo enddo enddo endif axisymx0 call rotor ( ir )% calc_secAlpha () call rotor ( ir )% calc_force ( density , dt ) case ( 1 ) ! Compute using alpha ! Compute alpha do ib = 1 , rotor ( ir )% nbConvect do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc ! Compute local velocity vector ! (excluding induced velocities from wing bound vortices) rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCP ! Neglect velocity due to spanwise vortices for all wings do jr = 1 , nr rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wip ( ic , is )% velCPTotal - & rotor ( jr )% vind_bywing_boundVortices ( & rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo ! Add self induced velocity due to wing vortices rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal + & rotor ( ir )% vind_bywing ( rotor ( ir )% blade ( ib )% wiP ( ic , is )% CP ) enddo enddo enddo axisymx1 : if ( rotor ( ir )% axisymmetrySwitch . eq . 1 ) then do ib = 2 , rotor ( ir )% nb do is = 1 , rotor ( ir )% ns do ic = 1 , rotor ( ir )% nc rotor ( ir )% blade ( ib )% wiP ( ic , is )% velCPTotal = & & rotor ( ir )% blade ( 1 )% wiP ( ic , is )% velCPTotal enddo enddo enddo endif axisymx1 call rotor ( ir )% calc_secAlpha () call rotor ( ir )% calc_force_alpha ( density , velSound ) case ( 2 ) ! Compute lift using alpha approximated from sec circulation call rotor ( ir )% calc_force_alphaGamma ( density , velSound , dt ) end select call force2file ( timestamp , rotor ( ir )) enddo endif ! Flap dynamics do ir = 1 , nr if ( rotor ( ir )% bladeDynamicsSwitch . ne . 0 ) then call dynamics2file ( timestamp , rotor ( ir )) if ( rotor ( ir )% surfaceType == - 1 ) then do ib = 1 , rotor ( ir )% nb if ( rotor ( ir )% imagePlane == 3 ) then rotor ( ir )% blade ( ib )% dflap = & & - 1._dp * rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% dflap rotor ( ir )% blade ( ib )% flap = & & - 1._dp * rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flap rotor ( ir )% blade ( ib )% flapPrev = & & - 1._dp * rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flapPrev else rotor ( ir )% blade ( ib )% dflap = & & rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% dflap rotor ( ir )% blade ( ib )% flap = & & rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flap rotor ( ir )% blade ( ib )% flapPrev = & & rotor ( rotor ( ir )% imageRotorNum )% blade ( ib )% flapPrev endif enddo else call rotor ( ir )% computeBladeDynamics ( dt ) endif endif ! Body dynamics if ( rotor ( ir )% bodyDynamicsSwitch . ne . 0 ) then call dynamics2file ( timestamp , rotor ( ir )) if ( rotor ( ir )% surfaceType == - 1 ) then rotor ( ir )% velBody = rotor ( rotor ( ir )% imageRotorNum )% velBody rotor ( ir )% velBody ( rotor ( ir )% imagePlane ) = & & - 1._dp * rotor ( ir )% velBody ( rotor ( ir )% imagePlane ) else call rotor ( ir )% computeBodyDynamics ( dt ) endif endif enddo endif ! Plot inflow do ir = 1 , nr if ( rotor ( ir )% inflowPlotSwitch . ne . 0 ) then if ( mod ( iter , rotor ( ir )% inflowPlotSwitch ) . eq . 0 ) then call inflow2file ( timestamp , rotor , ir , - zAxis ) endif endif enddo ! Plot sec wing bound circulation do ir = 1 , nr if ( rotor ( ir )% gammaPlotSwitch . ne . 0 ) then if ( mod ( iter , rotor ( ir )% gammaPlotSwitch ) . eq . 0 ) then call gamma2file ( timestamp , rotor ( 1 )) endif endif enddo ! Record filaments for grid plot computation if ( switches % gridPlot . ne . 0 ) then if ( mod ( iter , switches % gridPlot ) . eq . 0 ) then call filaments2file ( timestamp , rotor ) endif endif ! Compute probe velocities if ( switches % probe . ne . 0 ) then if ( mod ( iter , switches % probe ) . eq . 0 ) then call probes2file ( timestamp , probe , probeVel , rotor , t ) endif endif ! Wake convection if ( switches % wakeSuppress == 0 ) then ! Initialise wake velocity matrices do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake (:, rotor ( ir )% rowNear : rotor ( ir )% nNwake , :) = 0._dp rotor ( ir )% blade ( ib )% velFwake (:, rotor ( ir )% rowFar : rotor ( ir )% nFwake ) = 0._dp enddo endif enddo ! Compute induced velocity due to rotors in domain do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then do ib = 1 , rotor ( ir )% nbConvect do jr = 1 , nr rotor ( ir )% blade ( ib )% velNwake (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwake (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) + & vind_onNwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waN ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :)) rotor ( ir )% blade ( ib )% velFwake (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwake (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) + & vind_onFwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waF ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd )) enddo ! Add initial wake velocity if provided if ( iter < switches % initWakeVelNt ) then do i = 1 , 3 rotor ( ir )% blade ( ib )% velNwake ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwake ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) + & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo do i = 1 , 3 rotor ( ir )% blade ( ib )% velFwake ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwake ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) & - rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo endif enddo endif enddo ! Update wake vortex locations if lifting surface select case ( switches % fdScheme ) case ( 0 ) ! Explicit Forward Diff (1st order) do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface call rotor ( ir )% convectwake ( iter , dt , 'C' ) else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo case ( 1 ) ! Predictor-Corrector (2nd order) ! Compute predicted wake do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% waN ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% waF ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) enddo call rotor ( ir )% convectwake ( iter , dt , 'P' ) else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'P' ) endif endif endif enddo ! Compute velocity on predicted wake do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = 0._dp rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = 0._dp do jr = 1 , nr rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) + & vind_onNwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :), 'P' ) rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) + & vind_onFwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ), 'P' ) enddo if ( iter < switches % initWakeVelNt ) then do i = 1 , 3 rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo do i = 1 , 3 rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo endif enddo endif endif endif enddo ! Compute averaged velocity and convect wake do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & vel_order2_Nwake ( rotor ( ir )% blade ( ib )% velNwake (:, & rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :), & rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :)) !rotor(ir)%blade(ib)%velNwake(:,rotor(ir)%rowNear:rotor(ir)%nNwakeEnd,:)= & !0.5_dp*(rotor(ir)%blade(ib)%velNwake(:,rotor(ir)%rowNear:rotor(ir)%nNwakeEnd,:)+ & !rotor(ir)%blade(ib)%velNwakePredicted(:,rotor(ir)%rowNear:rotor(ir)%nNwakeEnd,:)) rotor ( ir )% blade ( ib )% velFwake (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & vel_order2_Fwake ( rotor ( ir )% blade ( ib )% velFwake (:, & rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ), & rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd )) !rotor(ir)%blade(ib)%velFwake(:,rotor(ir)%rowFar:rotor(ir)%nFwakeEnd)= & !0.5_dp*(rotor(ir)%blade(ib)%velFwake(:,rotor(ir)%rowFar:rotor(ir)%nFwakeEnd)+ & !rotor(ir)%blade(ib)%velFwakePredicted(:,rotor(ir)%rowFar:rotor(ir)%nFwakeEnd)) enddo call rotor ( ir )% convectwake ( iter , dt , 'C' ) else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo case ( 2 ) ! Explicit Adams-Bashforth (2nd order) if ( iter == 1 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwake enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo else do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwakeStep = & 0.5_dp * ( 3._dp * rotor ( ir )% blade ( ib )% velNwake - & rotor ( ir )% blade ( ib )% velNwake1 ) rotor ( ir )% blade ( ib )% velFwakeStep = & 0.5_dp * ( 3._dp * rotor ( ir )% blade ( ib )% velFwake - & rotor ( ir )% blade ( ib )% velFwake1 ) ! For next step rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwakeStep rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwakeStep ! For convection rotor ( ir )% blade ( ib )% velNwake = rotor ( ir )% blade ( ib )% velNwakeStep rotor ( ir )% blade ( ib )% velFwake = rotor ( ir )% blade ( ib )% velFwakeStep enddo call rotor ( ir )% convectwake ( iter , dt , 'C' ) else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo endif case ( 3 ) ! Predictor-Corrector Adams-Moulton (2nd order) if ( iter == 1 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwake enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo else do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% waN ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) ! Store Nwake to Nwake_step for later use rotor ( ir )% blade ( ib )% velNwakeStep = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velNwake = & 0.5_dp * ( 3._dp * rotor ( ir )% blade ( ib )% velNwake - & rotor ( ir )% blade ( ib )% velNwake1 ) rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% waF ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) ! Store Fwake to Fwake_step for later use rotor ( ir )% blade ( ib )% velFwakeStep = rotor ( ir )% blade ( ib )% velFwake rotor ( ir )% blade ( ib )% velFwake = & 0.5_dp * ( 3._dp * rotor ( ir )% blade ( ib )% velFwake - & rotor ( ir )% blade ( ib )% velFwake1 ) enddo call rotor ( ir )% convectwake ( iter , dt , 'P' ) else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'P' ) endif endif endif enddo do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = 0._dp rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = 0._dp do jr = 1 , nr rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) + & vind_onNwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :), 'P' ) rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) + & vind_onFwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ), 'P' ) enddo if ( iter < switches % initWakeVelNt ) then do i = 1 , 3 rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo do i = 1 , 3 rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo endif enddo endif endif endif enddo do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then ! Lifting surface do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake = & ( rotor ( ir )% blade ( ib )% velNwakePredicted & + rotor ( ir )% blade ( ib )% velNwakeStep ) * 0.5_dp rotor ( ir )% blade ( ib )% velFwake = & ( rotor ( ir )% blade ( ib )% velFwakePredicted & + rotor ( ir )% blade ( ib )% velFwakeStep ) * 0.5_dp enddo call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect ! For next step rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwakeStep rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwakeStep enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo endif case ( 4 ) ! Predictor-Corrector Adams-Moulton (3rd order) if ( iter == 0 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwake enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo elseif ( iter == 2 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake2 = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velFwake2 = rotor ( ir )% blade ( ib )% velFwake enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo else do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% waN ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) ! Store Nwake to Nwake_step for later use rotor ( ir )% blade ( ib )% velNwakeStep = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velNwake = & ( 2 3._dp * rotor ( ir )% blade ( ib )% velNwake & - 1 6._dp * rotor ( ir )% blade ( ib )% velNwake2 & + 0 5._dp * rotor ( ir )% blade ( ib )% velNwake1 ) / 1 2._dp rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% waF ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) ! Store Fwake to Fwake_step for later use rotor ( ir )% blade ( ib )% velFwakeStep = rotor ( ir )% blade ( ib )% velFwake rotor ( ir )% blade ( ib )% velFwake = & ( 2 3._dp * rotor ( ir )% blade ( ib )% velFwake & - 1 6._dp * rotor ( ir )% blade ( ib )% velFwake2 & + 0 5._dp * rotor ( ir )% blade ( ib )% velFwake1 ) / 1 2._dp enddo call rotor ( ir )% convectwake ( iter , dt , 'P' ) else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'P' ) endif endif endif enddo do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = 0._dp rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = 0._dp do jr = 1 , nr rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) + & vind_onNwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :), 'P' ) rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) + & vind_onFwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ), 'P' ) enddo if ( iter < switches % initWakeVelNt ) then do i = 1 , 3 rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo do i = 1 , 3 rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo endif enddo endif endif endif enddo do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake = & ( 0 5._dp * rotor ( ir )% blade ( ib )% velNwakePredicted & + 0 8._dp * rotor ( ir )% blade ( ib )% velNwakeStep & - 0 1._dp * rotor ( ir )% blade ( ib )% velNwake2 ) / 1 2._dp rotor ( ir )% blade ( ib )% velFwake = & ( 0 5._dp * rotor ( ir )% blade ( ib )% velFwakePredicted & + 0 8._dp * rotor ( ir )% blade ( ib )% velFwakeStep & - 0 1._dp * rotor ( ir )% blade ( ib )% velFwake2 ) / 1 2._dp enddo call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwake2 rotor ( ir )% blade ( ib )% velNwake2 = rotor ( ir )% blade ( ib )% velNwakeStep rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwake2 rotor ( ir )% blade ( ib )% velFwake2 = rotor ( ir )% blade ( ib )% velFwakeStep enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo endif case ( 5 ) ! Predictor-Corrector Adams-Moulton (4th order) if ( iter == 1 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwake enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo elseif ( iter == 2 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake2 = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velFwake2 = rotor ( ir )% blade ( ib )% velFwake enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo elseif ( iter == 3 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake3 = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velFwake3 = rotor ( ir )% blade ( ib )% velFwake enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo else do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% waN ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) ! Store Nwake to Nwake_step for later use rotor ( ir )% blade ( ib )% velNwakeStep = rotor ( ir )% blade ( ib )% velNwake rotor ( ir )% blade ( ib )% velNwake = & & ( 5 5._dp * rotor ( ir )% blade ( ib )% velNwake & ! Overwrite Nwake & - 5 9._dp * rotor ( ir )% blade ( ib )% velNwake3 & & + 3 7._dp * rotor ( ir )% blade ( ib )% velNwake2 & & - 0 9._dp * rotor ( ir )% blade ( ib )% velNwake1 ) / 2 4._dp rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% waF ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) ! Store Fwake to Fwake_step for later use rotor ( ir )% blade ( ib )% velFwakeStep = rotor ( ir )% blade ( ib )% velFwake rotor ( ir )% blade ( ib )% velFwake = & & ( 5 5._dp * rotor ( ir )% blade ( ib )% velFwake & ! Overwrite Fwake & - 5 9._dp * rotor ( ir )% blade ( ib )% velFwake3 & & + 3 7._dp * rotor ( ir )% blade ( ib )% velFwake2 & & - 0 9._dp * rotor ( ir )% blade ( ib )% velFwake1 ) / 2 4._dp enddo call rotor ( ir )% convectwake ( iter , dt , 'P' ) else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'P' ) endif endif endif enddo do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = 0._dp rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = 0._dp do jr = 1 , nr rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted (:, rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) + & vind_onNwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waNPredicted ( rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :), 'P' ) rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted (:, rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) + & vind_onFwake_byRotor ( rotor ( jr ), & rotor ( ir )% blade ( ib )% waFPredicted ( rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ), 'P' ) enddo if ( iter < switches % initWakeVelNt ) then do i = 1 , 3 rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) = & rotor ( ir )% blade ( ib )% velNwakePredicted ( i , rotor ( ir )% rowNear : rotor ( ir )% nNwakeEnd , :) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo do i = 1 , 3 rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) = & rotor ( ir )% blade ( ib )% velFwakePredicted ( i , rotor ( ir )% rowFar : rotor ( ir )% nFwakeEnd ) - & rotor ( ir )% initWakeVel * rotor ( ir )% shaftAxis ( i ) enddo endif enddo endif endif endif enddo do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake = & & ( 0 9._dp * rotor ( ir )% blade ( ib )% velNwakePredicted & & + 1 9._dp * rotor ( ir )% blade ( ib )% velNwakeStep & & - 0 5._dp * rotor ( ir )% blade ( ib )% velNwake3 & & + 0 1._dp * rotor ( ir )% blade ( ib )% velNwake2 ) / 2 4._dp rotor ( ir )% blade ( ib )% velFwake = & & ( 0 9._dp * rotor ( ir )% blade ( ib )% velFwakePredicted & & + 1 9._dp * rotor ( ir )% blade ( ib )% velFwakeStep & & - 0 5._dp * rotor ( ir )% blade ( ib )% velFwake3 & & + 0 1._dp * rotor ( ir )% blade ( ib )% velFwake2 ) / 2 4._dp enddo call rotor ( ir )% convectwake ( iter , dt , 'C' ) do ib = 1 , rotor ( ir )% nbConvect rotor ( ir )% blade ( ib )% velNwake1 = rotor ( ir )% blade ( ib )% velNwake2 rotor ( ir )% blade ( ib )% velNwake2 = rotor ( ir )% blade ( ib )% velNwake3 rotor ( ir )% blade ( ib )% velNwake3 = rotor ( ir )% blade ( ib )% velNwakeStep rotor ( ir )% blade ( ib )% velFwake1 = rotor ( ir )% blade ( ib )% velFwake2 rotor ( ir )% blade ( ib )% velFwake2 = rotor ( ir )% blade ( ib )% velFwake3 rotor ( ir )% blade ( ib )% velFwake3 = rotor ( ir )% blade ( ib )% velFwakeStep enddo else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'C' ) endif endif endif enddo endif end select ! Strain wake if ( switches % wakeStrain . eq . 1 ) then do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) & & call rotor ( ir )% strain_wake () endif enddo endif ! Assign TE of wake and compute rollup do ir = 1 , nr if ( rotor ( ir )% nNwake > 0 ) then if ( abs ( rotor ( ir )% surfaceType ) == 1 ) then if ( rotor ( ir )% surfaceType . gt . 0 ) then if ( rotor ( ir )% rowNear . eq . 1 ) then ! Last step of near wake or later steps call rotor ( ir )% rollup () ! Rollup wake for next far wake panel ! Store shed vortex as TE for next near wake panel call rotor ( ir )% assignshed ( 'TE' ) else if ( rotor ( ir )% surfaceType . gt . 0 ) then call rotor ( ir )% assignshed ( 'TE' ) endif endif else ! Image lifting surface call rotor ( ir )% mirrorWake ( rotor ( rotor ( ir )% imageRotorNum ), 'A' ) endif endif endif enddo endif ! Write out restart file in binary format if ( switches % restartWriteNt . ne . 0 ) then if ( mod ( iter , switches % restartWriteNt ) . eq . 0 ) then open ( unit = 24 , file = 'Restart/restart' // timestamp // '.dat' , & & status = 'replace' , action = 'write' , form = 'unformatted' ) write ( 24 ) t write ( 24 ) rotor close ( 24 ) endif endif enddo ! Deinitialize all variables do ir = 1 , nr call rotor ( ir )% deinit ( switches ) enddo end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"gridgen.f90 – VOLCANOR","text":"Contents Programs gridgen Source Code gridgen.f90 Source Code program gridgen use libCommon use classdef use libMath , only : linspace ! integer, parameter :: dp = kind(1.d0) integer :: nx , ny , nz real ( dp ), dimension ( 3 ) :: xyzMin , xyzMax ! Coordinates of corners real ( dp ), dimension ( 3 ) :: vel ! x,y,z velocities integer :: fileRange , fileRangeStart , fileRangeStep , fileRangeEnd integer :: ix , iy , iz , ifil real ( dp ), allocatable , dimension (:) :: xVec , yVec , zVec real ( dp ), allocatable , dimension (:, :, :, :) :: grid , gridCentre , velCentre character ( len = 5 ) :: nx_char , ny_char , nz_char character ( len = 5 ) :: filetimestamp integer :: nVrWing , nVrNwake , nVfNwakeTE , nVfFwake type ( vr_class ), allocatable , dimension (:) :: vrWing , vrNwake type ( vf_class ), allocatable , dimension (:) :: vfFwake , vfNwakeTE real ( dp ), allocatable , dimension (:) :: gamFwake , gamNwakeTE character ( len = 10 ) :: fileFormatVersion , currentTemplateVersion currentTemplateVersion = '0.2' ! Read gridconfig.in file call print_status ( 'Reading file ' // 'gridconfig.nml' ) open ( unit = 11 , file = 'gridconfig.nml' , status = 'old' , action = 'read' ) namelist / VERSION / fileFormatVersion read ( unit = 11 , nml = VERSION ) if ( adjustl ( fileFormatVersion ) /= currentTemplateVersion ) then error stop 'ERROR: gridconfig.nml template version does not match' endif namelist / INPUTS / nx , ny , nz , xyzMin , xyzMax , vel , & & fileRangeStart , fileRangeStep , fileRangeEnd read ( unit = 11 , nml = INPUTS ) close ( 11 ) ! Sanity check for xyzMin and xyzMax values if ( xyzMin ( 1 ) > xyzMax ( 1 ) . or . xyzMin ( 2 ) > xyzMax ( 2 ) . or . xyzMin ( 3 ) > xyzMax ( 3 )) then error stop 'ERROR: All XYZmin values should be greater than XYZmax values' endif call print_status () ! SUCCESS ! Allocate grid coordinates allocate ( grid ( 3 , nx , ny , nz )) allocate ( gridCentre ( 3 , nx - 1 , ny - 1 , nz - 1 )) allocate ( velCentre ( 3 , nx - 1 , ny - 1 , nz - 1 )) allocate ( xVec ( nx )) allocate ( yVec ( ny )) allocate ( zVec ( nz )) write ( nx_char , '(I5)' ) nx write ( ny_char , '(I5)' ) ny write ( nz_char , '(I5)' ) nz xVec = linspace ( xyzMin ( 1 ), xyzMax ( 1 ), nx ) yVec = linspace ( xyzMin ( 2 ), xyzMax ( 2 ), ny ) zVec = linspace ( xyzMin ( 3 ), xyzMax ( 3 ), nz ) ! Create grid call print_status ( 'Creating cartesian grid' ) do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx grid (:, ix , iy , iz ) = [ xVec ( ix ), yVec ( iy ), zVec ( iz )] enddo enddo enddo ! Compute grid centres do iz = 1 , nz - 1 do iy = 1 , ny - 1 do ix = 1 , nx - 1 gridCentre (:, ix , iy , iz ) = grid (:, ix , iy , iz ) + grid (:, ix + 1 , iy , iz ) & + grid (:, ix + 1 , iy + 1 , iz ) + grid (:, ix + 1 , iy + 1 , iz + 1 ) & + grid (:, ix , iy + 1 , iz ) + grid (:, ix , iy + 1 , iz + 1 ) & + grid (:, ix , iy , iz + 1 ) + grid (:, ix + 1 , iy , iz + 1 ) enddo enddo enddo gridCentre = gridCentre * 0.125_dp call print_status () ! SUCCESS ! Iterate through filaments files do fileRange = fileRangeStart , fileRangeEnd , fileRangeStep ! Read from filaments file write ( filetimestamp , '(I0.5)' ) fileRange call print_status ( 'Reading file ' // 'filaments' // filetimestamp // '.dat' ) open ( unit = 12 , file = 'Results/filaments' // filetimestamp // '.dat' , & & status = 'old' , action = 'read' , form = 'unformatted' ) read ( 12 ) nVrWing read ( 12 ) nVrNwake read ( 12 ) nVfNwakeTE read ( 12 ) nVfFwake allocate ( vrWing ( nVrWing )) allocate ( vrNwake ( nVrNwake )) allocate ( vfNwakeTE ( nVfNwakeTE )) allocate ( vfFwake ( nVfFwake )) allocate ( gamFwake ( nVfFwake )) allocate ( gamNwakeTE ( nVfNwakeTE )) read ( 12 ) vrWing , vrNwake read ( 12 ) vfNwakeTE , gamNwakeTE read ( 12 ) vfFwake , gamFwake close ( 12 ) call print_status () ! SUCCESS ! Find induced velocities at cell centre call print_status ( 'Computing velocities' ) !$omp parallel do collapse(3) do iz = 1 , nz - 1 do iy = 1 , ny - 1 do ix = 1 , nx - 1 ! from wing do ifil = 1 , nVrWing velCentre (:, ix , iy , iz ) = vrWing ( ifil )% vind ( gridCentre (:, ix , iy , iz )) * vrWing ( ifil )% gam enddo ! from Nwake do ifil = 1 , nVrNwake velCentre (:, ix , iy , iz ) = velCentre (:, ix , iy , iz ) + vrNwake ( ifil )% vind ( gridCentre (:, ix , iy , iz )) * vrNwake ( ifil )% gam enddo ! from NwakeTE do ifil = 1 , nVfNwakeTE velCentre (:, ix , iy , iz ) = velCentre (:, ix , iy , iz ) + vfNwakeTE ( ifil )% vind ( gridCentre (:, ix , iy , iz )) * gamNwakeTE ( ifil ) enddo ! from Fwake do ifil = 1 , nVfFwake velCentre (:, ix , iy , iz ) = velCentre (:, ix , iy , iz ) + vfFwake ( ifil )% vind ( gridCentre (:, ix , iy , iz )) * gamFwake ( ifil ) enddo enddo enddo enddo !$omp end parallel do call print_status () ! Add freestream velocities velCentre ( 1 , :, :, :) = velCentre ( 1 , :, :, :) + vel ( 1 ) velCentre ( 2 , :, :, :) = velCentre ( 2 , :, :, :) + vel ( 2 ) velCentre ( 3 , :, :, :) = velCentre ( 3 , :, :, :) + vel ( 3 ) ! Write to file call print_status ( 'Writing file ' // 'grid' // filetimestamp // '.tec' ) write ( filetimestamp , '(I0.5)' ) fileRange open ( unit = 13 , file = 'Results/grid' // filetimestamp // '.tec' , & & status = 'new' , action = 'write' ) write ( 13 , * ) 'TITLE = \"Grid\"' write ( 13 , * ) 'VARIABLES = \"X\" \"Y\" \"Z\" \"U\" \"V\" \"W\"' write ( 13 , * ) 'ZONE I=' // trim ( nx_char ) // ' J=' // trim ( ny_char ) // ' K=' // trim ( nz_char ) // ' T=\"Data\"' write ( 13 , * ) 'DATAPACKING=BLOCK' write ( 13 , * ) 'VARLOCATION=([4]=CELLCENTERED,[5]=CELLCENTERED,[6]=CELLCENTERED)' write ( 13 , * ) ((( grid ( 1 , ix , iy , iz ), ix = 1 , nx ), iy = 1 , ny ), iz = 1 , nz ) write ( 13 , * ) ((( grid ( 2 , ix , iy , iz ), ix = 1 , nx ), iy = 1 , ny ), iz = 1 , nz ) write ( 13 , * ) ((( grid ( 3 , ix , iy , iz ), ix = 1 , nx ), iy = 1 , ny ), iz = 1 , nz ) write ( 13 , * ) ((( velCentre ( 1 , ix , iy , iz ), ix = 1 , nx - 1 ), iy = 1 , ny - 1 ), iz = 1 , nz - 1 ) write ( 13 , * ) ((( velCentre ( 2 , ix , iy , iz ), ix = 1 , nx - 1 ), iy = 1 , ny - 1 ), iz = 1 , nz - 1 ) write ( 13 , * ) ((( velCentre ( 3 , ix , iy , iz ), ix = 1 , nx - 1 ), iy = 1 , ny - 1 ), iz = 1 , nz - 1 ) close ( 13 ) call print_status () deallocate ( vrWing ) deallocate ( vrNwake ) deallocate ( vfNwakeTE ) deallocate ( vfFwake ) deallocate ( gamFwake ) deallocate ( gamNwakeTE ) enddo deallocate ( grid ) deallocate ( gridCentre ) deallocate ( velCentre ) deallocate ( xVec ) deallocate ( yVec ) deallocate ( zVec ) end program gridgen","tags":"","loc":"sourcefile/gridgen.f90.html"},{"title":"libCommon.f90 – VOLCANOR","text":"Module definition for libCommon Contents Modules libCommon Source Code libCommon.f90 Source Code !! Module definition for libCommon module libCommon !! Utility procedures and those to compute induced velocity of rotors use classdef , only : switches_class , rotor_class implicit none integer , parameter , private :: dp = kind ( 1.d0 ) !! Double precision setting ! Contains variable declarations type ( rotor_class ), allocatable , dimension (:) :: rotor ! Kinematics integer :: nt !! No. of timesteps integer :: nr !! No. of rotors real ( dp ) :: dt !! Timestep size ! Other Variables integer :: iterStart real ( dp ) :: t !! Time real ( dp ) :: density !! Density real ( dp ) :: velSound !! Velocity of sound to compute Mach real ( dp ) :: kinematicVisc !! Kinematic viscosity character ( len = 5 ) :: timestamp character ( len = 2 ) :: rotorChar character ( len = 10 ) :: rotorFile character ( len = 10 ) :: currentTime logical :: fileExists real ( dp ) :: subIterResidual ! Iterators integer :: i , is , ic , row , iter , ir , jr , ib , rowErase ! Switches type ( switches_class ) :: switches ! Probes for velocity real ( dp ), allocatable , dimension (:, :) :: probe , probeVel contains subroutine readConfig ( filename , outputFilename ) !! Read config.nml input file (in namelist format) use classdef , only : switches_class character ( len =* ), intent ( in ) :: filename character ( len =* ), optional , intent ( in ) :: outputFilename character ( len = 10 ) :: fileFormatVersion , currentVersion integer :: restartWriteNt , restartFromNt , ntSub , ntSubInit , & & wakePlot , wakeTipPlot , rotorForcePlot , & & gridPlot , wakeDissipation , wakeStrain , wakeBurst , wakeSuppress , & & slowStart , slowStartNt , fdScheme , initWakeVelNt , probe ! Namelists namelist / VERSION / fileFormatVersion namelist / PARAMS / nt , dt , nr , density , velSound , kinematicVisc namelist / OPTIONS / restartWriteNt , restartFromNt , ntSub , ntSubInit , & & wakePlot , wakeTipPlot , rotorForcePlot , & & gridPlot , wakeDissipation , wakeStrain , wakeBurst , wakeSuppress , & & slowStart , slowStartNt , fdScheme , initWakeVelNt , probe currentVersion = '0.5' open ( unit = 11 , file = filename , status = 'old' , action = 'read' ) read ( unit = 11 , nml = VERSION ) if ( adjustl ( fileFormatVersion ) /= currentVersion ) then error stop \"ERROR: config.nml template version does not match\" endif read ( unit = 11 , nml = PARAMS ) read ( unit = 11 , nml = OPTIONS ) close ( 11 ) ! Write a copy to results if requested if ( present ( outputFilename )) then open ( unit = 12 , file = outputFilename , status = 'replace' , action = 'write' ) write ( unit = 12 , nml = VERSION ) write ( unit = 12 , nml = PARAMS ) write ( unit = 12 , nml = OPTIONS ) close ( 12 ) endif switches % restartWriteNt = restartWriteNt switches % restartFromNt = restartFromNt switches % ntSub = ntSub switches % ntSubInit = ntSubInit switches % wakePlot = wakePlot switches % wakeTipPlot = wakeTipPlot switches % rotorForcePlot = rotorForcePlot switches % gridPlot = gridPlot switches % wakeDissipation = wakeDissipation switches % wakeStrain = wakeStrain switches % wakeBurst = wakeBurst switches % wakeSuppress = wakeSuppress switches % slowStart = slowStart switches % slowStartNt = slowStartNt switches % fdScheme = fdScheme switches % initWakeVelNt = initWakeVelNt switches % probe = probe end subroutine readConfig !--------------------------------------------------------! !                Induced Velocity Functions              ! !--------------------------------------------------------! function vind_onNwake_byRotor ( rotor , Nwake , optionalChar ) result ( vindArray ) !! Compute induced velocity by rotor (wing + wake) on Nwake corner points use classdef , only : rotor_class , Nwake_class type ( rotor_class ), intent ( inout ) :: rotor !! Rotor type ( Nwake_class ), intent ( in ), dimension (:, :) :: Nwake !! Near wake character ( len = 1 ), optional :: optionalChar !! If 'P' is specified, predicted wake of rotor is used real ( dp ), dimension ( 3 , size ( Nwake , 1 ), size ( Nwake , 2 ) + 1 ) :: vindArray integer :: i , j , rows , cols rows = size ( Nwake , 1 ) cols = size ( Nwake , 2 ) if (. not . present ( optionalChar )) then ! Induced velocity due to all blades and wake !$omp parallel do collapse(2) do j = 1 , cols do i = 1 , rows vindArray (:, i , j ) = rotor % vind_bywing ( Nwake ( i , j )% vr % vf ( 2 )% fc (:, 1 )) & + rotor % vind_bywake ( Nwake ( i , j )% vr % vf ( 2 )% fc (:, 1 )) enddo enddo !$omp end parallel do !$omp parallel do do i = 1 , rows vindArray (:, i , cols + 1 ) = rotor % vind_bywing ( Nwake ( i , cols )% vr % vf ( 3 )% fc (:, 1 )) & + rotor % vind_bywake ( Nwake ( i , cols )% vr % vf ( 3 )% fc (:, 1 )) enddo !$omp end parallel do elseif (( optionalChar . eq . 'P' ) . or . ( optionalChar . eq . 'p' )) then ! Induced velocity due to all blades and Pwake !$omp parallel do collapse(2) do j = 1 , cols do i = 1 , rows vindArray (:, i , j ) = rotor % vind_bywing ( Nwake ( i , j )% vr % vf ( 2 )% fc (:, 1 )) & + rotor % vind_bywake ( Nwake ( i , j )% vr % vf ( 2 )% fc (:, 1 ), 'P' ) enddo enddo !$omp end parallel do !$omp parallel do do i = 1 , rows vindArray (:, i , cols + 1 ) = rotor % vind_bywing ( Nwake ( i , cols )% vr % vf ( 3 )% fc (:, 1 )) & + rotor % vind_bywake ( Nwake ( i , cols )% vr % vf ( 3 )% fc (:, 1 ), 'P' ) enddo !$omp end parallel do else error stop 'ERROR: Wrong character flag for vind_onNwake_byRotor()' endif end function vind_onNwake_byRotor function vind_onFwake_byRotor ( rotor , Fwake , optionalChar ) result ( vindArray ) !! Compute induced velocity by rotor (wing + wake) on Fwake corner points use classdef , only : rotor_class , Fwake_class type ( rotor_class ), intent ( inout ) :: rotor !! Rotor type ( Fwake_class ), intent ( in ), dimension (:) :: Fwake !! Far wake character ( len = 1 ), optional :: optionalChar !! If 'P' is specified, predicted wake of rotor is used real ( dp ), dimension ( 3 , size ( Fwake , 1 )) :: vindArray integer :: i , rows rows = size ( Fwake , 1 ) if (. not . present ( optionalChar )) then ! Induced velocity due to all blades and wake !$omp parallel do do i = 1 , rows vindArray (:, i ) = rotor % vind_bywing ( Fwake ( i )% vf % fc (:, 1 )) & + rotor % vind_bywake ( Fwake ( i )% vf % fc (:, 1 )) enddo !$omp end parallel do elseif (( optionalChar . eq . 'P' ) . or . ( optionalChar . eq . 'p' )) then ! Induced velocity due to all blades and Pwake !$omp parallel do do i = 1 , rows vindArray (:, i ) = rotor % vind_bywing ( Fwake ( i )% vf % fc (:, 1 )) & + rotor % vind_bywake ( Fwake ( i )% vf % fc (:, 1 ), 'P' ) enddo !$omp end parallel do else error stop 'ERROR: Wrong character flag for vind_onFwake_byRotor()' endif end function vind_onFwake_byRotor function vel_order2_Nwake ( v_wake_n , v_wake_np1 ) !! Calculate 2nd order accurate induced velocity on near wake real ( dp ), intent ( in ), dimension (:, :, :) :: v_wake_n !! Induced velocity on wake at timestep n real ( dp ), intent ( in ), dimension (:, :, :) :: v_wake_np1 !! Induced velocity on wake at timestep n+1 real ( dp ), dimension ( 3 , size ( v_wake_n , 2 ), size ( v_wake_n , 3 )) :: vel_order2_Nwake integer :: i , j do j = 1 , size ( v_wake_n , 3 ) vel_order2_Nwake (:, 1 , j ) = ( v_wake_np1 (:, 1 , j ) & + v_wake_n (:, 1 , j )) * 0.5_dp do i = 2 , size ( v_wake_n , 2 ) - 1 vel_order2_Nwake (:, i , j ) = ( v_wake_np1 (:, i , j ) & + v_wake_np1 (:, i - 1 , j ) & + v_wake_n (:, i + 1 , j ) & + v_wake_n (:, i , j )) * 0.25_dp enddo vel_order2_Nwake (:, size ( v_wake_n , 2 ), j ) = & ( v_wake_np1 (:, size ( v_wake_n , 2 ), j ) & + v_wake_n (:, size ( v_wake_n , 2 ), j )) * 0.5_dp enddo end function vel_order2_Nwake function vel_order2_Fwake ( v_wake_n , v_wake_np1 ) !! Calculate 2nd order accurate induced velocity on far wake real ( dp ), intent ( in ), dimension (:, :) :: v_wake_n !! Induced velocity on wake at timestep n real ( dp ), intent ( in ), dimension (:, :) :: v_wake_np1 !! Induced velocity on wake at timestep n+1 real ( dp ), dimension ( 3 , size ( v_wake_n , 2 )) :: vel_order2_Fwake integer :: i vel_order2_Fwake (:, 1 ) = ( v_wake_np1 (:, 1 ) + v_wake_n (:, 1 )) * 0.5_dp !$omp parallel do do i = 2 , size ( v_wake_n , 2 ) - 1 vel_order2_Fwake (:, i ) = ( v_wake_np1 (:, i ) & + v_wake_np1 (:, i - 1 ) & + v_wake_n (:, i + 1 ) & + v_wake_n (:, i )) * 0.25_dp enddo !$omp end parallel do vel_order2_Fwake (:, size ( v_wake_n , 2 )) = & ( v_wake_np1 (:, size ( v_wake_n , 2 )) & + v_wake_n (:, size ( v_wake_n , 2 ))) * 0.5_dp end function vel_order2_Fwake subroutine print_status ( statusMessage ) !! Prints status message (or SUCCESS if left blank) character ( len =* ), optional :: statusMessage character ( len = 34 ) :: statusPrint ! Adjust for spacing if (. not . present ( statusMessage )) then write ( * , '(A)' ) '...   SUCCESS' else statusPrint = statusMessage write ( * , '(A)' , advance = 'no' ) statusPrint endif end subroutine print_status end module libCommon","tags":"","loc":"sourcefile/libcommon.f90.html"},{"title":"libPostprocess.f90 – VOLCANOR","text":"Module definition for libPostProcess Contents Modules libPostprocess Source Code libPostprocess.f90 Source Code !! Module definition for libPostProcess module libPostprocess !! Procedures to write out results of simulations use libMath , only : dp , pi , eps , radToDeg character ( len = 8 ) :: ResultsDir = 'Results/' contains subroutine init_plots ( numOfRotors ) !! Initialise headers for plot files integer , intent ( in ) :: numOfRotors character ( len = 30 ) :: forceDimFilename character ( len = 30 ) :: forceNonDimFilename character ( len = 30 ) :: dynamicsFilename integer :: rotorNumber character ( len = 2 ) :: rotorNumberChar do rotorNumber = 1 , numOfRotors write ( rotorNumberChar , '(I0.2)' ) rotorNumber forceDimFilename = ResultsDir // 'r' // rotorNumberChar // 'ForceDim.csv' forceNonDimFilename = ResultsDir // 'r' // rotorNumberChar // 'ForceNonDim.csv' dynamicsFilename = ResultsDir // 'r' // rotorNumberChar // 'bladedynamics.csv' ! Add data headers open ( unit = 10 , file = forceDimFilename , & & status = 'replace' , action = 'write' ) write ( 10 , 100 ) 'iter' , 'LiftMag' , 'DragMag' , & & 'Lx' , 'Ly' , 'Lz' , & & 'Dx' , 'Dy' , 'Dz' , & & 'FInertx' , 'FInerty' , 'FInertz' close ( 10 ) open ( unit = 11 , file = forceNonDimFilename , & & status = 'replace' , action = 'write' ) write ( 11 , 101 ) 'iter' , 'CL/CT' , 'CD/CQ' , 'CLu' , 'CDi' , 'CD0' , 'CDu' , & & 'CFx' , 'CFy' , 'CFz' close ( 11 ) open ( unit = 12 , file = dynamicsFilename , & & status = 'replace' , action = 'write' ) write ( 12 , 102 ) 'iter' , 'pitch' , 'flap' , 'dflap' , 'w' , 'omega' close ( 12 ) enddo 100 format ( A5 , 11 ( A15 )) 101 format ( A5 , 9 ( A15 )) 102 format ( A5 , 5 ( A15 )) end subroutine init_plots subroutine params2file ( rotor , nt , dt , nr , & & density , velSound , switches ) !! Write rotor parameters to json file use classdef , only : rotor_class , switches_class type ( rotor_class ), intent ( in ) :: rotor type ( switches_class ), intent ( in ) :: switches integer , intent ( in ) :: nt , nr real ( dp ), intent ( in ) :: dt , density , velSound character ( len = 22 ) :: paramsFilename paramsFilename = ResultsDir // 'r' // rotor % id // 'Params.json' open ( unit = 10 , file = paramsFilename , status = 'replace' , action = 'write' ) write ( 10 , * ) '{' ! Config file write ( 10 , * ) '\"nt\": ' , nt , ',' write ( 10 , * ) '\"dt\": ' , dt , ',' write ( 10 , * ) '\"nr\": ' , nr , ',' write ( 10 , * ) '\"restartWriteNt\": ' , switches % restartWriteNt , ',' write ( 10 , * ) '\"restartFromNt\": ' , switches % restartFromNt , ',' write ( 10 , * ) '\"ntSub\": ' , switches % ntSub , ',' write ( 10 , * ) '\"ntSubInit\": ' , switches % ntSubInit , ',' write ( 10 , * ) '\"density\": ' , density , ',' write ( 10 , * ) '\"velSound\": ' , velSound , ',' write ( 10 , * ) '\"wakePlot\": ' , switches % wakePlot , ',' write ( 10 , * ) '\"wakeTipPlot\": ' , switches % wakeTipPlot , ',' write ( 10 , * ) '\"rotorForcePlot\": ' , switches % rotorForcePlot , ',' write ( 10 , * ) '\"gridPlot\": ' , switches % gridPlot , ',' write ( 10 , * ) '\"wakeDissipation\": ' , switches % wakeDissipation , ',' write ( 10 , * ) '\"wakeStrain\": ' , switches % wakeStrain , ',' write ( 10 , * ) '\"wakeBurst\": ' , switches % wakeBurst , ',' write ( 10 , * ) '\"slowStart\": ' , switches % slowStart , ',' write ( 10 , * ) '\"slowStartNt\": ' , switches % slowStartNt , ',' write ( 10 , * ) '\"fdScheme\": ' , switches % fdScheme , ',' write ( 10 , * ) '\"initWakeVelNt\": ' , switches % initWakeVelNt , ',' write ( 10 , * ) '\"probe\": ' , switches % probe , ',' ! Geom file write ( 10 , * ) '\"nb\": ' , rotor % nb , ',' write ( 10 , * ) '\"propConvention\": ' , rotor % propConvention , ',' write ( 10 , * ) '\"geometryFile\": \"' , rotor % geometryFile , '\",' write ( 10 , * ) '\"spanSpacing\": ' , rotor % spanSpacing , ',' write ( 10 , * ) '\"chordSpacing\": ' , rotor % chordSpacing , ',' write ( 10 , * ) '\"nCamberFiles\": ' , rotor % nCamberFiles , ',' write ( 10 , * ) '\"surfaceType\": ' , rotor % surfaceType , ',' write ( 10 , * ) '\"imagePlane\": ' , rotor % imagePlane , ',' write ( 10 , * ) '\"imageRotorNum\": ' , rotor % imageRotorNum , ',' write ( 10 , * ) '\"nc\": ' , rotor % nc , ',' write ( 10 , * ) '\"ns\": ' , rotor % ns , ',' write ( 10 , * ) '\"nNwake\": ' , rotor % nNwake , ',' write ( 10 , * ) '\"radius\": ' , rotor % radius , ',' write ( 10 , * ) '\"root_cut\": ' , rotor % root_cut , ',' write ( 10 , * ) '\"chord\": ' , rotor % chord , ',' write ( 10 , * ) '\"preconeAngle\": ' , rotor % preconeAngle * radToDeg , ',' write ( 10 , * ) '\"Omega\": ' , rotor % Omega , ',' write ( 10 , * ) '\"phi\": ' , rotor % pts ( 1 ), ',' write ( 10 , * ) '\"theta\": ' , rotor % pts ( 2 ), ',' write ( 10 , * ) '\"psi\": ' , rotor % pts ( 3 ), ',' write ( 10 , * ) '\"theta0\": ' , rotor % controlPitch ( 1 ) * radToDeg , ',' write ( 10 , * ) '\"thetaC\": ' , rotor % controlPitch ( 2 ) * radToDeg , ',' write ( 10 , * ) '\"thetaS\": ' , rotor % controlPitch ( 3 ) * radToDeg , ',' write ( 10 , * ) '\"thetaTwist\": ' , rotor % thetaTwist * radToDeg , ',' write ( 10 , * ) '\"u\": ' , rotor % velBody ( 1 ), ',' write ( 10 , * ) '\"v\": ' , rotor % velBody ( 2 ), ',' write ( 10 , * ) '\"w\": ' , rotor % velBody ( 3 ), ',' write ( 10 , * ) '\"nonDimForceDenom\": ' , rotor % nonDimforceDenominator , ',' if ( rotor % nAirfoils . gt . 0 ) then write ( 10 , * ) '\"alpha0\": ' , rotor % alpha0 ( 1 ), ',' else write ( 10 , * ) '\"alpha0\": ' , 0._dp , ',' endif write ( 10 , * ) '\"wakeTruncateNt\": ' , rotor % wakeTruncateNt , ',' write ( 10 , * ) '\"prescWakeNt\": ' , rotor % prescWakeNt , ',' write ( 10 , * ) '\"initWakeVel\": ' , rotor % initWakeVel , ',' write ( 10 , * ) '\"psiStart\": ' , rotor % psiStart * radToDeg , ',' write ( 10 , * ) '\"forceCalcSwitch\": ' , rotor % forceCalcSwitch * radToDeg , ',' write ( 10 , * ) '\"apparentViscCoeff\": ' , rotor % apparentViscCoeff , ',' write ( 10 , * ) '\"decayCoeff\": ' , rotor % decayCoeff , ',' write ( 10 , * ) '\"axisymmetrySwitch\": ' , rotor % axisymmetrySwitch , ',' write ( 10 , * ) '\"bladeDynamicsSwitch\": ' , rotor % bladeDynamicsSwitch , ',' write ( 10 , * ) '\"flapInitial\": ' , rotor % flapInitial , ',' write ( 10 , * ) '\"dFlapInitial\": ' , rotor % dflapInitial , ',' write ( 10 , * ) '\"Iflap\": ' , rotor % Iflap , ',' write ( 10 , * ) '\"cflap\": ' , rotor % cflap , ',' write ( 10 , * ) '\"kflap\": ' , rotor % kflap , ',' write ( 10 , * ) '\"MflapConstant\": ' , rotor % MflapConstant , ',' write ( 10 , * ) '\"pitchDynamicsSwitch\": ' , rotor % pitchDynamicsSwitch , ',' write ( 10 , * ) '\"dpitch\": ' , rotor % dpitch write ( 10 , * ) '}' close ( 10 ) end subroutine params2file subroutine geom2file ( timestamp , rotor , wakeSuppress ) !! Plot rotor geometry and wake to file use classdef , only : rotor_class type ( rotor_class ), intent ( in ) :: rotor character ( len =* ), intent ( in ) :: timestamp integer , intent ( in ) :: wakeSuppress character ( len = 5 ) :: nxChar , nyChar real ( dp ), dimension ( 3 , rotor % nc + 1 , rotor % ns + 1 ) :: wingMesh real ( dp ), dimension ( 3 , rotor % nNwake + 1 , rotor % ns + 1 ) :: wakeMesh real ( dp ), dimension ( 3 , rotor % nFwake + 1 ) :: wakeTip ! Optimise this by only initialising reqd size real ( dp ), dimension ( 3 , size ( rotor % blade ( 1 )% wapF % waF ) + 1 ) :: wakeTipPresc integer :: i , j , nx , ny , ib open ( unit = 10 , file = ResultsDir // & & 'r' // rotor % id // 'wingNwake' // timestamp // '.tec' , position = 'append' ) if ( abs ( rotor % surfaceType ) == 1 ) then ! Lifting surface write ( 10 , * ) 'Title = \"Wing and Wake\"' write ( 10 , * ) 'VARIABLES = \"X\" \"Y\" \"Z\" \"GAM\" \"skew\"' ! \"Var6\"' do ib = 1 , rotor % nb ! Wing nx = rotor % nc ny = rotor % ns write ( nxChar , '(I5)' ) nx + 1 write ( nyChar , '(I5)' ) ny + 1 do j = 1 , ny do i = 1 , nx wingMesh (:, i , j ) = rotor % blade ( ib )% wiP ( i , j )% pc (:, 1 ) enddo enddo do i = 1 , nx wingMesh (:, i , ny + 1 ) = rotor % blade ( ib )% wiP ( i , ny )% pc (:, 4 ) enddo do j = 1 , ny wingMesh (:, nx + 1 , j ) = rotor % blade ( ib )% wiP ( nx , j )% pc (:, 2 ) enddo wingMesh (:, nx + 1 , ny + 1 ) = rotor % blade ( ib )% wiP ( nx , ny )% pc (:, 3 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // & & ' K=1  T=\"Blade ' // rotor % blade ( ib )% id // '\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4]=CELLCENTERED,[5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) (( wingMesh ( 1 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( wingMesh ( 2 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( wingMesh ( 3 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( - 1._dp * rotor % blade ( ib )% wiP ( i , j )% vr % gam , i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% vr % gam * 0._dp , i = 1 , nx ), j = 1 , ny ) !write(10,*) ((rotor%blade(ib)%wiP(i,j)%vr%skew,i=1,nx),j=1,ny) if ( wakeSuppress == 0 . and . rotor % nNwake > 0 ) then ! Near wake nx = rotor % nNwakeEnd ny = rotor % ns write ( nxChar , '(I5)' ) nx - ( rotor % rowNear - 1 ) + 1 write ( nyChar , '(I5)' ) ny + 1 !Check if necessary - $omp parallel do collapse(2) do j = 1 , ny do i = rotor % rowNear , nx wakeMesh (:, i , j ) = rotor % blade ( ib )% waN ( i , j )% vr % vf ( 1 )% fc (:, 1 ) enddo enddo !Check if necessary -$omp end parallel do do i = rotor % rowNear , nx wakeMesh (:, i , ny + 1 ) = rotor % blade ( ib )% waN ( i , ny )% vr % vf ( 4 )% fc (:, 1 ) enddo do j = 1 , ny wakeMesh (:, nx + 1 , j ) = rotor % blade ( ib )% waN ( nx , j )% vr % vf ( 2 )% fc (:, 1 ) enddo wakeMesh (:, nx + 1 , ny + 1 ) = rotor % blade ( ib )% waN ( nx , ny )% vr % vf ( 3 )% fc (:, 1 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // ' K=1  T=\"NearWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4]=CELLCENTERED, [5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) (( wakeMesh ( 1 , i , j ), i = rotor % rowNear , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( wakeMesh ( 2 , i , j ), i = rotor % rowNear , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( wakeMesh ( 3 , i , j ), i = rotor % rowNear , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( - 1._dp * rotor % blade ( ib )% waN ( i , j )% vr % gam , i = rotor % rowNear , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% waN ( i , j )% vr % skew , i = rotor % rowNear , nx ), j = 1 , ny ) !write(10,*) ((rotor%blade(ib)%waN(i,j)%vr%skew,i=rotor%rowNear,nx),j=1,ny) ! Far wake nx = rotor % nFwakeEnd if ( rotor % rowFar . le . rotor % nFwakeEnd ) then write ( nxChar , '(I5)' ) nx - ( rotor % rowFar - 1 ) + 1 !Check if necessary - $omp parallel do collapse(2) do i = rotor % rowFar , nx wakeTip (:, i ) = rotor % blade ( ib )% waF ( i )% vf % fc (:, 2 ) enddo wakeTip (:, nx + 1 ) = rotor % blade ( ib )% waF ( rotor % nFwakeEnd )% vf % fc (:, 1 ) !Check if necessary -$omp end parallel do write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1   K=1   T=\"FarWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4]=CELLCENTERED ,[5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) ( wakeTip ( 1 , i ), i = rotor % rowFar , nx + 1 ) write ( 10 , * ) ( wakeTip ( 2 , i ), i = rotor % rowFar , nx + 1 ) write ( 10 , * ) ( wakeTip ( 3 , i ), i = rotor % rowFar , nx + 1 ) write ( 10 , * ) ( - 1._dp * rotor % blade ( ib )% waF ( i )% gam , i = rotor % rowFar , nx ) write ( 10 , * ) ( rotor % blade ( ib )% waF ( i )% vf % rVc * 0._dp , i = rotor % rowFar , nx ) !write(10,*) (rotor%blade(ib)%waF(i)%vf%age,i=rotor%rowFar,nx) else ! No far wake present write ( nxChar , '(I5)' ) 2 ! Plot mesh as single redundant point wakeTip (:, 1 ) = rotor % blade ( ib )% waN ( rotor % nNwake , rotor % ns )% vr % vf ( 3 )% fc (:, 1 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1   K=1   T=\"FarWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4]=CELLCENTERED, [5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) wakeTip ( 1 , 1 ), wakeTip ( 1 , 1 ) write ( 10 , * ) wakeTip ( 2 , 1 ), wakeTip ( 2 , 1 ) write ( 10 , * ) wakeTip ( 3 , 1 ), wakeTip ( 3 , 1 ) write ( 10 , * ) 0._dp write ( 10 , * ) 0._dp !write(10,*) 0._dp endif ! Prescribed far wake nx = size ( rotor % blade ( ib )% wapF % waF ) if ( rotor % blade ( ib )% wapF % isPresent ) then write ( nxChar , '(I5)' ) nx + 1 !Check if necessary - $omp parallel do collapse(2) do i = 1 , nx wakeTipPresc (:, i ) = rotor % blade ( ib )% wapF % waF ( i )% vf % fc (:, 2 ) enddo wakeTipPresc (:, nx + 1 ) = rotor % blade ( ib )% wapF % waF ( size ( rotor % blade ( 1 )% wapF % waF ))% vf % fc (:, 1 ) !Check if necessary -$omp end parallel do write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1   K=1   T=\"PrescFarWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4]=CELLCENTERED ,[5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) ( wakeTipPresc ( 1 , i ), i = 1 , nx + 1 ) write ( 10 , * ) ( wakeTipPresc ( 2 , i ), i = 1 , nx + 1 ) write ( 10 , * ) ( wakeTipPresc ( 3 , i ), i = 1 , nx + 1 ) write ( 10 , * ) ( - 1._dp * rotor % blade ( ib )% wapF % waF ( i )% gam , i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% wapF % waF ( i )% vf % rVc , i = 1 , nx ) !write(10,*) (rotor%blade(ib)%waF(i)%vf%age,i=rotor%rowFar,nx) else ! No prescribed far wake present write ( nxChar , '(I5)' ) 2 ! Plot mesh as single redundant point wakeTip (:, 1 ) = rotor % blade ( ib )% waN ( rotor % nNwake , rotor % ns )% vr % vf ( 3 )% fc (:, 1 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1   K=1   T=\"PrescFarWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4]=CELLCENTERED, [5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) wakeTip ( 1 , 1 ), wakeTip ( 1 , 1 ) write ( 10 , * ) wakeTip ( 2 , 1 ), wakeTip ( 2 , 1 ) write ( 10 , * ) wakeTip ( 3 , 1 ), wakeTip ( 3 , 1 ) write ( 10 , * ) 0._dp write ( 10 , * ) 0._dp !write(10,*) 0._dp endif endif enddo elseif ( abs ( rotor % surfaceType ) == 2 ) then ! Non-lifting surface write ( 10 , * ) 'Title = \"Non-lifting surface\"' write ( 10 , * ) 'VARIABLES = \"X\" \"Y\" \"Z\" \"GAM\"' ! \"skew\" \"Var6\"' do ib = 1 , rotor % nb ! Compute common nodes of non-lifting surface nx = rotor % blade ( ib )% stlNodesCols ny = rotor % nc ! No. of triangular elements write ( nxChar , '(I0.5)' ) nx write ( nyChar , '(I0.5)' ) ny write ( 10 , * ) 'Zone NODES=' // trim ( nxChar ) // & & ' ELEMENTS=' // nyChar // & & ' T=\"Blade ' // rotor % blade ( ib )% id // '\"' write ( 10 , * ) 'ZONETYPE=FETRIANGLE, DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=(4=CELLCENTERED)' write ( 10 , * ) rotor % blade ( ib )% stlNodes ( 1 , 1 : nx ) write ( 10 , * ) rotor % blade ( ib )% stlNodes ( 2 , 1 : nx ) write ( 10 , * ) rotor % blade ( ib )% stlNodes ( 3 , 1 : nx ) write ( 10 , * ) rotor % blade ( ib )% wiP (:, 1 )% vr % gam do i = 1 , ny write ( 10 , '(3I7)' ) rotor % blade ( ib )% stlElementNodes (:, i ) enddo enddo endif close ( 10 ) end subroutine geom2file subroutine probes2file ( timestamp , probe , probeVel , rotor , t ) !! Write velocities at probe locations use classdef , only : rotor_class type ( rotor_class ), intent ( inout ), dimension (:) :: rotor character ( len =* ), intent ( in ) :: timestamp real ( dp ), intent ( in ) :: t real ( dp ), intent ( in ) , dimension (:, :) :: probe , probeVel integer :: ir , i real ( dp ), dimension ( 3 ) :: probeLocation , vel open ( unit = 10 , file = ResultsDir // 'probes' // timestamp // '.csv' , & & status = 'replace' , action = 'write' ) write ( 10 , 110 ) 'u' , 'v' , 'w' , 'x' , 'y' , 'z' do i = 1 , size ( probe , 2 ) probeLocation = probe (:, i ) + probeVel (:, i ) * t vel = probeVel (:, i ) do ir = 1 , size ( rotor ) vel = vel & & + rotor ( ir )% vind_bywing ( probeLocation ) & & + rotor ( ir )% vind_bywake ( probeLocation ) enddo write ( 10 , 120 ) vel , probeLocation enddo close ( 10 ) 110 format ( 6 ( A15 )) 120 format ( 6 ( E15 . 7 )) end subroutine probes2file subroutine filaments2file ( timestamp , rotor ) !! Write filaments to file for using with grid-based plots use classdef , only : vf_class , vr_class , rotor_class type ( rotor_class ), intent ( in ), dimension (:) :: rotor character ( len =* ), intent ( in ) :: timestamp integer :: nr , nvrWing , nvrNwake , nvfNwakeTE , nvfFwake integer :: ir , ib , irow , icol , indx type ( vr_class ), allocatable , dimension (:) :: vrWing , vrNwake type ( vf_class ), allocatable , dimension (:) :: vfFwake , vfNwakeTE real ( dp ), allocatable , dimension (:) :: gamFwake , gamNwakeTE nvrWing = 0 nvrNwake = 0 nvfNwakeTE = 0 nvfFwake = 0 nr = size ( rotor ) do ir = 1 , nr if ( rotor ( ir )% rowFar . gt . rotor ( ir )% nFwake ) error stop 'ERROR: Use filaments2file() only after development of far wake' enddo ! Compute number of each filaments do ir = 1 , nr nvrWing = nvrWing + rotor ( ir )% nb * ( rotor ( ir )% nc * rotor ( ir )% ns ) nvrNwake = nvrNwake + rotor ( ir )% nb * ( rotor ( ir )% nNwake * rotor ( ir )% ns ) nvfNwakeTE = nvfNwakeTE + rotor ( ir )% nb * rotor ( ir )% ns nvfFwake = nvfFwake + ( rotor ( ir )% nFwake - rotor ( ir )% rowFar + 1 ) * rotor ( ir )% nb enddo ! Allocate filaments allocate ( vrWing ( nvrWing )) allocate ( vrNwake ( nvrNwake )) allocate ( vfNwakeTE ( nvfNwakeTE )) allocate ( vfFwake ( nvfFwake )) allocate ( gamFwake ( nvfFwake )) allocate ( gamNwakeTE ( nvfNwakeTE )) ! Extract filament properties ! from wing indx = 1 do ir = 1 , nr do ib = 1 , rotor ( ir )% nb do icol = 1 , rotor ( ir )% ns do irow = 1 , rotor ( ir )% nc vrWing ( indx ) = rotor ( ir )% blade ( ib )% wiP ( irow , icol )% vr indx = indx + 1 enddo enddo enddo enddo ! from Nwake indx = 1 do ir = 1 , nr do ib = 1 , rotor ( ir )% nb do icol = 1 , rotor ( ir )% ns do irow = 1 , rotor ( ir )% nNwake vrNwake ( indx ) = rotor ( ir )% blade ( ib )% waN ( irow , icol )% vr indx = indx + 1 enddo enddo enddo enddo ! from NwakeTE indx = 1 do ir = 1 , nr irow = rotor ( ir )% nNwake do ib = 1 , rotor ( ir )% nb do icol = 1 , rotor ( ir )% ns vfNwakeTE ( indx ) = rotor ( ir )% blade ( ib )% waN ( irow , icol )% vr % vf ( 2 ) gamNwakeTE ( indx ) = rotor ( ir )% blade ( ib )% waN ( irow , icol )% vr % gam * ( - 1._dp ) indx = indx + 1 enddo enddo enddo ! from Fwake indx = 1 do ir = 1 , nr do ib = 1 , rotor ( ir )% nb do irow = rotor ( ir )% rowFar , rotor ( ir )% nFwake vfFwake ( indx ) = rotor ( ir )% blade ( ib )% waF ( irow )% vf gamFwake ( indx ) = rotor ( ir )% blade ( ib )% waF ( irow )% gam indx = indx + 1 enddo enddo enddo ! Write to filamentsXXXXX.dat binary file open ( unit = 10 , file = ResultsDir // 'filaments' // timestamp // '.dat' , & & status = 'replace' , action = 'write' , form = 'unformatted' ) write ( 10 ) nvrWing write ( 10 ) nvrNwake write ( 10 ) nvfNwakeTE write ( 10 ) nvfFwake write ( 10 ) vrWing , vrNwake write ( 10 ) vfNwakeTE , gamNwakeTE write ( 10 ) vfFwake , gamFwake close ( 10 ) ! Deallocate filaments deallocate ( vrWing ) deallocate ( vrNwake ) deallocate ( vfNwakeTE ) deallocate ( gamNwakeTE ) deallocate ( vfFwake ) deallocate ( gamFwake ) end subroutine filaments2file subroutine geomSurface2file ( rotor ) !! Plot surface geometry to file use classdef , only : rotor_class type ( rotor_class ), intent ( in ) :: rotor character ( len = 5 ) :: nxChar , nyChar real ( dp ), dimension ( 3 , rotor % nc + 1 , rotor % ns + 1 ) :: mesh integer :: i , j , nx , ny , ib do ib = 1 , rotor % nb open ( unit = 10 , file = ResultsDir // & & 'r' // rotor % id // 'b' // rotor % blade ( ib )% id // 'Surface.tec' , & & action = 'write' , position = 'append' ) write ( 10 , * ) 'Title=\"r' // rotor % id // 'b' // rotor % blade ( ib )% id // '\"' write ( 10 , * ) 'VARIABLES = \"X\" \"Y\" \"Z\" \"nx\" \"ny\" \"nz\"' ! nx , ny, nz can be used for vectors at nodes ! Zone 1: Panel coordinates nx = rotor % nc ny = rotor % ns write ( nxChar , '(I5)' ) nx + 1 write ( nyChar , '(I5)' ) ny + 1 do j = 1 , ny do i = 1 , nx mesh (:, i , j ) = rotor % blade ( ib )% wiP ( i , j )% PC (:, 1 ) enddo enddo do i = 1 , nx mesh (:, i , ny + 1 ) = rotor % blade ( ib )% wiP ( i , ny )% PC (:, 4 ) enddo do j = 1 , ny mesh (:, nx + 1 , j ) = rotor % blade ( ib )% wiP ( nx , j )% PC (:, 2 ) enddo mesh (:, nx + 1 , ny + 1 ) = rotor % blade ( ib )% wiP ( nx , ny )% PC (:, 3 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // ' K=1 T=\"PC\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) (( mesh ( 1 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( mesh ( 2 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( mesh ( 3 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( 0 , i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( 0 , i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( 0 , i = 1 , nx + 1 ), j = 1 , ny + 1 ) ! Zone 2: Vortex filament coordinates write ( nxChar , '(I5)' ) nx + 1 write ( nyChar , '(I5)' ) ny + 1 do j = 1 , ny do i = 1 , nx mesh (:, i , j ) = rotor % blade ( ib )% wiP ( i , j )% vr % vf ( 1 )% fc (:, 1 ) enddo enddo do i = 1 , nx mesh (:, i , ny + 1 ) = rotor % blade ( ib )% wiP ( i , ny )% vr % vf ( 4 )% fc (:, 1 ) enddo do j = 1 , ny mesh (:, nx + 1 , j ) = rotor % blade ( ib )% wiP ( nx , j )% vr % vf ( 2 )% fc (:, 1 ) enddo mesh (:, nx + 1 , ny + 1 ) = rotor % blade ( ib )% wiP ( nx , ny )% vr % vf ( 3 )% fc (:, 1 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // ' K=1 T=\"VR\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARSHARELIST=([4-6]=1)' ! Empty variables write ( 10 , * ) (( mesh ( 1 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( mesh ( 2 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( mesh ( 3 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) ! Zone 3: CP and nCap nx = rotor % nc ny = rotor % ns write ( nxChar , '(I5)' ) nx write ( nyChar , '(I5)' ) ny write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // ' K=1 & & T=\"CP, nCap\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% CP ( 1 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% CP ( 2 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% CP ( 3 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% nCap ( 1 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% nCap ( 2 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% nCap ( 3 ), i = 1 , nx ), j = 1 , ny ) ! Zone4: CP and tauCapChord write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // ' K=1 & & T=\"CP, tauCapChord\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARSHARELIST=([1-3]=3)' ! Share CP coordinates write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% tauCapChord ( 1 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% tauCapChord ( 2 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% tauCapChord ( 3 ), i = 1 , nx ), j = 1 , ny ) ! Zone 5: CP and tauCapSpan write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // ' K=1 & & T=\"CP, tauCapChord\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARSHARELIST=([1-3]=3)' ! Share CP coordinates write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% tauCapSpan ( 1 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% tauCapSpan ( 2 ), i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% tauCapSpan ( 3 ), i = 1 , nx ), j = 1 , ny ) ! Zone 6: Sectional CP and secNormalVec nx = rotor % ns write ( nxChar , '(I5)' ) nx write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1 K=1 T=\"secCP, secNcap\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) ( rotor % blade ( ib )% secCP ( 1 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secCP ( 2 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secCP ( 3 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secNormalVec ( 1 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secNormalVec ( 2 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secNormalVec ( 3 , i ), i = 1 , nx ) ! Zone 7: Sectional CP and secNormalVec nx = rotor % ns write ( nxChar , '(I5)' ) nx write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1 K=1 & & T=\"secCP, secTauCapChord\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARSHARELIST=([1-3]=6)' ! Share secCP coordinates write ( 10 , * ) ( rotor % blade ( ib )% secTauCapChord ( 1 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secTauCapChord ( 2 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secTauCapChord ( 3 , i ), i = 1 , nx ) ! Zone 8: Sectional CP and secNormalVec nx = rotor % ns write ( nxChar , '(I5)' ) nx write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1 K=1 & & T=\"secCP, secTauCapSpan\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARSHARELIST=([1-3]=6)' ! Share secCP coordinates write ( 10 , * ) ( rotor % blade ( ib )% secTauCapSpan ( 1 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secTauCapSpan ( 2 , i ), i = 1 , nx ) write ( 10 , * ) ( rotor % blade ( ib )% secTauCapSpan ( 3 , i ), i = 1 , nx ) close ( 10 ) enddo end subroutine geomSurface2file subroutine tip2file ( timestamp , rotor ) !! Wake tip to file use classdef , only : rotor_class type ( rotor_class ), intent ( in ) :: rotor character ( len =* ), intent ( in ) :: timestamp character ( len = 5 ) :: nxChar , nyChar real ( dp ), dimension ( 3 , rotor % nc + 1 , rotor % ns + 1 ) :: wingMesh real ( dp ), dimension ( 3 , rotor % nNwake + 1 ) :: nWakeTip real ( dp ), dimension ( rotor % nNwake ) :: gamRollup real ( dp ), dimension ( 3 , rotor % nFwake + 1 ) :: fWakeTip real ( dp ) :: gamSum integer :: ib , i , j , nx , ny open ( unit = 10 , file = ResultsDir // & & 'r' // rotor % id // 'tip' // timestamp // '.tec' , & & action = 'write' , position = 'append' ) open ( unit = 11 , file = ResultsDir // & & 'r' // rotor % id // 'tipXYZ' // timestamp // '.csv' , & & action = 'write' , position = 'append' ) write ( 10 , * ) 'Title = \"Wing and Tip\"' write ( 10 , * ) 'VARIABLES = \"X\" \"Y\" \"Z\" \"GAM\" \"ageAzimuthal\"' ! \"Var6\"' do ib = 1 , rotor % nb ! Wing nx = rotor % nc ny = rotor % ns write ( nxChar , '(I5)' ) nx + 1 write ( nyChar , '(I5)' ) ny + 1 do j = 1 , ny do i = 1 , nx wingMesh (:, i , j ) = rotor % blade ( ib )% wiP ( i , j )% pc (:, 1 ) enddo enddo do i = 1 , nx wingMesh (:, i , ny + 1 ) = rotor % blade ( ib )% wiP ( i , ny )% pc (:, 4 ) enddo do j = 1 , ny wingMesh (:, nx + 1 , j ) = rotor % blade ( ib )% wiP ( nx , j )% pc (:, 2 ) enddo wingMesh (:, nx + 1 , ny + 1 ) = rotor % blade ( ib )% wiP ( nx , ny )% pc (:, 3 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=' // trim ( nyChar ) // ' K=1  T=\"Blade\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4,5]=CELLCENTERED)' ![6]=CELLCENTERED)' write ( 10 , * ) (( wingMesh ( 1 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( wingMesh ( 2 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( wingMesh ( 3 , i , j ), i = 1 , nx + 1 ), j = 1 , ny + 1 ) write ( 10 , * ) (( - 1._dp * rotor % blade ( ib )% wiP ( i , j )% vr % gam , i = 1 , nx ), j = 1 , ny ) write ( 10 , * ) (( rotor % blade ( ib )% wiP ( i , j )% & & vr % vf ( 1 )% ageAzimuthal * radToDeg , i = 1 , nx ), j = 1 , ny ) ! write(10,*) ((rotor%blade(ib)%wiP(i,j)%vr%skew,i=1,nx),j=1,ny) ! Near wake nx = rotor % nNwake write ( nxChar , '(I5)' ) nx - ( rotor % rowNear - 1 ) + 1 ! Compute tip location for near wake do i = rotor % rowNear , nx gamRollup ( i ) = rotor % blade ( ib )% waN ( i , rotor % ns )% vr % gam gamSum = 0._dp nWakeTip (:, i ) = 0._dp do j = rotor % rollupStart , rotor % rollupEnd nWakeTip (:, i ) = nWakeTip (:, i ) + rotor % blade ( ib )% waN ( i , j )% vr % vf ( 4 )% fc (:, 1 ) * & rotor % blade ( ib )% waN ( i , j )% vr % gam gamSum = gamSum + rotor % blade ( ib )% waN ( i , j )% vr % gam ! Compute max gam for near wake filaments if ( sign ( 1._dp , rotor % Omega * rotor % controlPitch ( 1 )) > eps ) then if ( rotor % blade ( ib )% waN ( i , j )% vr % gam < gamRollup ( i )) then ! '<' because of negative gamma gamRollup ( i ) = rotor % blade ( ib )% waN ( i , j )% vr % gam endif else ! one of Omega or pitch is negative if ( rotor % blade ( ib )% waN ( i , j )% vr % gam > gamRollup ( i )) then ! '>' because of positive gamma gamRollup ( i ) = rotor % blade ( ib )% waN ( i , j )% vr % gam endif endif enddo if ( abs ( gamSum ) > eps ) then nWakeTip (:, i ) = nWakeTip (:, i ) / gamSum else nWakeTip (:, i ) = rotor % blade ( ib )% waN ( i , rotor % rollupEnd )% vr % vf ( 4 )% fc (:, 1 ) endif enddo ! For last row gamSum = 0._dp nWakeTip (:, nx + 1 ) = 0._dp do j = rotor % rollupStart , rotor % rollupEnd nWakeTip (:, nx + 1 ) = nWakeTip (:, nx + 1 ) + rotor % blade ( ib )% waN ( nx , j )% vr % vf ( 3 )% fc (:, 1 ) * & rotor % blade ( ib )% waN ( nx , j )% vr % gam gamSum = gamSum + rotor % blade ( ib )% waN ( nx , j )% vr % gam enddo if ( abs ( gamSum ) > eps ) then nWakeTip (:, nx + 1 ) = nWakeTip (:, nx + 1 ) / gamSum else nWakeTip (:, nx + 1 ) = rotor % blade ( ib )% waN ( nx , rotor % rollupEnd )% vr % vf ( 3 )% fc (:, 1 ) endif write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1    K=1  T=\"NearWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4,5]=CELLCENTERED)' write ( 10 , * ) ( nWakeTip ( 1 , i ), i = rotor % rowNear , nx + 1 ) write ( 10 , * ) ( nWakeTip ( 2 , i ), i = rotor % rowNear , nx + 1 ) write ( 10 , * ) ( nWakeTip ( 3 , i ), i = rotor % rowNear , nx + 1 ) write ( 10 , * ) ( - 1._dp * gamRollup ( i ), i = rotor % rowNear , nx ) write ( 10 , * ) ( rotor % blade ( ib )% waN ( i , rotor % ns )% & & vr % vf ( 4 )% ageAzimuthal * radToDeg , i = rotor % rowNear , nx ) !write(10,*) ((rotor%blade(ib)%waN(i,j)%vr%skew,i=rotor%rowNear,nx),j=1,ny) write ( 11 , * ) 'X        Y         Z' do i = rotor % rowNear , nx + 1 write ( 11 , * ) nWakeTip ( 1 , i ), nWakeTip ( 2 , i ), nWakeTip ( 3 , i ) enddo ! Far wake nx = rotor % nFwake if ( rotor % rowFar . le . rotor % nFwake ) then write ( nxChar , '(I5)' ) nx - ( rotor % rowFar - 1 ) + 1 !Check if necessary - $omp parallel do collapse(2) do i = rotor % rowFar , nx fWakeTip (:, i ) = rotor % blade ( ib )% waF ( i )% vf % fc (:, 2 ) enddo fWakeTip (:, nx + 1 ) = rotor % blade ( ib )% waF ( rotor % nFwake )% vf % fc (:, 1 ) !Check if necessary -$omp end parallel do write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1   K=1   T=\"FarWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4,5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) ( fWakeTip ( 1 , i ), i = rotor % rowFar , nx + 1 ) write ( 10 , * ) ( fWakeTip ( 2 , i ), i = rotor % rowFar , nx + 1 ) write ( 10 , * ) ( fWakeTip ( 3 , i ), i = rotor % rowFar , nx + 1 ) write ( 10 , * ) ( - 1._dp * rotor % blade ( ib )% waF ( i )% gam , i = rotor % rowFar , nx ) write ( 10 , * ) ( rotor % blade ( ib )% waF ( i )% vf % ageAzimuthal * radToDeg , & & i = rotor % rowFar , nx ) !write(10,*) (rotor%blade(ib)%waF(i)%vf%age,i=rotor%rowFar,nx) do i = rotor % rowFar , nx + 1 write ( 11 , * ) fWakeTip ( 1 , i ), fWakeTip ( 2 , i ), fWakeTip ( 3 , i ) enddo else ! No far wake present write ( nxChar , '(I5)' ) 2 ! Plot mesh as single redundant point fWakeTip (:, 1 ) = rotor % blade ( ib )% waN ( rotor % nNwake , rotor % ns )% vr % vf ( 3 )% fc (:, 1 ) write ( 10 , * ) 'Zone I=' // trim ( nxChar ) // ' J=1   K=1   T=\"FarWake\"' write ( 10 , * ) 'DATAPACKING=BLOCK' write ( 10 , * ) 'VARLOCATION=([4,5]=CELLCENTERED)' !,[6]=CELLCENTERED)' write ( 10 , * ) fWakeTip ( 1 , 1 ), fWakeTip ( 1 , 1 ) write ( 10 , * ) fWakeTip ( 2 , 1 ), fWakeTip ( 2 , 1 ) write ( 10 , * ) fWakeTip ( 3 , 1 ), fWakeTip ( 3 , 1 ) write ( 10 , * ) 0._dp write ( 10 , * ) 0._dp !write(10,*) 0._dp endif enddo close ( 10 ) close ( 11 ) end subroutine tip2file subroutine skew2file ( timestamp , rotor ) !! Skew parameter to file use classdef , only : rotor_class type ( rotor_class ), intent ( in ) :: rotor character ( len =* ), intent ( in ) :: timestamp integer :: ib , irow , nrow , ncol nrow = size ( rotor % blade ( 1 )% waN , 1 ) ncol = size ( rotor % blade ( 1 )% waN , 2 ) do ib = 1 , rotor % nb open ( unit = 12 , file = ResultsDir // & & 'r' // rotor % id // 'b' // rotor % blade ( ib )% id // & & 'skew' // timestamp // '.csv' , & & action = 'write' ) write ( 12 , 110 ) 'max' , 'avg' do irow = nrow , rotor % rowNear , - 1 write ( 12 , 120 ) maxval ( rotor % blade ( ib )% waN ( irow , :)% vr % skew ), & & sum ( rotor % blade ( ib )% waN ( irow , :)% vr % skew ) / ncol enddo 110 format ( 2 ( A15 )) 120 format ( 2 ( E15 . 7 )) close ( 12 ) enddo end subroutine skew2file subroutine force2file ( timestamp , rotor ) ! Write sec and net force to file use classdef , only : rotor_class type ( rotor_class ), intent ( in ) :: rotor character ( len =* ), intent ( in ) :: timestamp integer :: ib , ispan character ( len = 24 ) :: forceDimFilename character ( len = 27 ) :: forceNonDimFilename real ( dp ) :: signLift signLift = sign ( 1._dp , dot_product ( rotor % lift , rotor % zAxisBody )) forceNonDimFilename = ResultsDir // 'r' // rotor % id // 'ForceNonDim.csv' open ( unit = 11 , file = forceNonDimFilename , action = 'write' , position = 'append' ) write ( 11 , 100 ) timestamp , & signLift * norm2 ( rotor % lift ) / rotor % nonDimforceDenominator , & ! CL norm2 ( rotor % drag ) / rotor % nonDimforceDenominator , & ! CD norm2 ( rotor % liftUnsteady ) / rotor % nonDimforceDenominator , & ! CLu norm2 ( rotor % dragInduced ) / rotor % nonDimforceDenominator , & ! CDi norm2 ( rotor % dragProfile ) / rotor % nonDimforceDenominator , & ! CDo norm2 ( rotor % dragUnsteady ) / rotor % nonDimforceDenominator , & ! CDu rotor % forceInertial ( 1 ) / rotor % nonDimforceDenominator , & ! CFx rotor % forceInertial ( 2 ) / rotor % nonDimforceDenominator , & ! CFy rotor % forceInertial ( 3 ) / rotor % nonDimforceDenominator ! CFz close ( 11 ) 100 format ( A , 9 ( E15 . 7 )) forceDimFilename = ResultsDir // 'r' // rotor % id // 'ForceDim.csv' open ( unit = 12 , file = forceDimFilename , action = 'write' , position = 'append' ) write ( 12 , 101 ) timestamp , norm2 ( rotor % lift ), norm2 ( rotor % drag ), & rotor % lift ( 1 ), rotor % lift ( 2 ), rotor % lift ( 3 ), & ! Lift rotor % drag ( 1 ), rotor % drag ( 2 ), rotor % drag ( 3 ), & ! Drag rotor % forceInertial ( 1 ), rotor % forceInertial ( 2 ), rotor % forceInertial ( 3 ) close ( 12 ) 101 format ( A , 11 ( E15 . 7 )) do ib = 1 , rotor % nbConvect open ( unit = 12 , file = ResultsDir // & & 'r' // rotor % id // 'b' // rotor % blade ( ib )% id // & & 'ForceDist' // timestamp // '.csv' , & & action = 'write' , position = 'append' ) write ( 12 , 202 ) 'secSpan' , 'secCL' , 'secCD' , 'secCLu' , & & 'secLift' , 'secDrag' , 'secLiftInPl' , 'secLiftOutPl' , & & 'secArea' , 'secVel' , 'secChord' , 'secTheta' , 'secAlpha' , 'secPhi' , & & 'secViz' , 'secVix' ! secVel is resultant vel that the airfoil sees do ispan = 1 , rotor % ns write ( 12 , 102 ) dot_product ( rotor % blade ( ib )% secCP (:, ispan ) - & & rotor % hubCoords , rotor % blade ( ib )% yAxis ), & & rotor % blade ( ib )% secCL ( ispan ), & & rotor % blade ( ib )% secCD ( ispan ), & & rotor % blade ( ib )% secCLu ( ispan ), & & norm2 ( rotor % blade ( ib )% secLift (:, ispan )), & & norm2 ( rotor % blade ( ib )% secDrag (:, ispan )), & & norm2 ( rotor % blade ( ib )% secLiftInPlane (:, ispan )), & & norm2 ( rotor % blade ( ib )% secLiftOutPlane (:, ispan )), & & rotor % blade ( ib )% secArea ( ispan ), & & norm2 ( rotor % blade ( ib )% secChordwiseResVel (:, ispan )), & & rotor % blade ( ib )% secChord ( ispan ), & & rotor % blade ( ib )% secTheta ( ispan ) * radToDeg , & & rotor % blade ( ib )% secAlpha ( ispan ) * radToDeg , & & rotor % blade ( ib )% secPhi ( ispan ) * radToDeg , & & rotor % blade ( ib )% secViz ( ispan ), & & rotor % blade ( ib )% secVix ( ispan ) enddo close ( 12 ) enddo 202 format ( 16 ( A15 )) 102 format ( 16 ( E15 . 7 )) end subroutine force2file subroutine dynamics2file ( timestamp , rotor ) !! Rotor dynamics to file use classdef , only : rotor_class character ( len =* ), intent ( in ) :: timestamp type ( rotor_class ), intent ( in ) :: rotor character ( len = 30 ) :: dynamicsFilename dynamicsFilename = ResultsDir // 'r' // rotor % id // 'bladedynamics.csv' open ( unit = 10 , file = dynamicsFilename , action = 'write' , position = 'append' ) write ( 10 , 100 ) timestamp , rotor % blade ( 1 )% theta * radToDeg , rotor % blade ( 1 )% flap * radToDeg , & & rotor % blade ( 1 )% dflap * radToDeg , rotor % velBody ( 3 ), rotor % omegaSlow close ( 10 ) 100 format ( A5 , 5 ( E15 . 7 )) end subroutine dynamics2file subroutine inflow2file ( timestamp , rotorArray , rotorNumber , directionVector ) !! Calculate inflow velocity along directionVector !! on the blades of rotor(rotorNumber) at rotor(rotorNumber)%secCP use classdef , only : rotor_class character ( len =* ), intent ( in ) :: timestamp type ( rotor_class ), intent ( inout ), dimension (:) :: rotorArray integer , intent ( in ) :: rotorNumber real ( dp ), intent ( in ), dimension ( 3 ) :: directionVector character ( len = 2 ) :: rotorNumberChar , bladeNumberChar integer :: is , ir , ib real ( dp ), dimension ( 3 ) :: P real ( dp ), dimension ( rotorArray ( rotorNumber )% ns , rotorArray ( rotorNumber )% nb ) :: inflowVel inflowVel = 0._dp do ir = 1 , size ( rotorArray ) do ib = 1 , rotorArray ( rotorNumber )% nb do is = 1 , rotorArray ( rotorNumber )% ns P = rotorArray ( rotorNumber )% blade ( ib )% secCP (:, is ) inflowVel ( is , ib ) = inflowVel ( is , ib ) + dot_product ( rotorArray ( ir )% vind_bywing ( P ), directionVector ) inflowVel ( is , ib ) = inflowVel ( is , ib ) - dot_product ( rotorArray ( ir )% vind_bywing_boundVortices ( P ), directionVector ) inflowVel ( is , ib ) = inflowVel ( is , ib ) + dot_product ( rotorArray ( ir )% vind_bywake ( P ), directionVector ) enddo enddo enddo ! Write to file write ( rotorNumberChar , '(I0.2)' ) rotorNumber do ib = 1 , rotorArray ( rotorNumber )% nb write ( bladeNumberChar , '(I0.2)' ) ib open ( unit = 12 , file = ResultsDir // & & 'r' // rotorNumberChar // 'b' // bladeNumberChar // & & 'inflowDist' // timestamp // '.curve' , & & action = 'write' , position = 'append' ) write ( 12 , 100 ) 'secSpan' , 'inflowVel' do is = 1 , rotorArray ( rotorNumber )% ns write ( 12 , 101 ) dot_product ( rotorArray ( rotorNumber )% blade ( ib )% secCP (:, is ), & & rotorArray ( rotorNumber )% hubCoords - & & rotorArray ( rotorNumber )% blade ( ib )% yAxis ), & & inflowVel ( is , ib ) enddo close ( 12 ) enddo 100 format ( 2 ( A15 )) 101 format ( 2 ( F15 . 7 )) end subroutine inflow2file subroutine gamma2file ( timestamp , rotor ) !! Calculate inflow velocity along directionVector on the blades of rotor(rotorNumber) !! at rotor(rotorNumber)%secCP use classdef , only : rotor_class character ( len =* ), intent ( in ) :: timestamp type ( rotor_class ), intent ( in ) :: rotor integer :: ib , ic , is character ( len = 2 ) :: rowNumberChar ! Write to file do ib = 1 , rotor % nb open ( unit = 12 , & & file = ResultsDir // & & 'r' // rotor % id // 'b' // rotor % blade ( ib )% id // & & 'gammaDist' // timestamp // '.curve' , & & action = 'write' , position = 'append' ) ic = 1 write ( rowNumberChar , '(I0.2)' ) ic write ( 12 , * ) '# Row' // rowNumberChar do is = 1 , rotor % ns write ( 12 , * ) dot_product ( rotor % blade ( ib )% wiP ( 1 , is )% CP - rotor % hubCoords , rotor % blade ( ib )% yAxis ), & - 1._dp * sum ( rotor % blade ( ib )% wiP (:, is )% vr % gam ) enddo close ( 12 ) enddo end subroutine gamma2file end module libPostprocess","tags":"","loc":"sourcefile/libpostprocess.f90.html"},{"title":"Documentation – VOLCANOR","text":"The vortex lattice method is a potential flow based method. While different flavours exist, the one implemented here is a lifting surface model with a free-wake formulation. To keep the solver generalized, the flow solution is obtained in the global frame. Details on this specific implementation of the vortex lattice method are available in the following references: Joseph, C., and Mohan, R. A Parallel, Object-Oriented Framework for Unsteady Free-Wake Analysis of Multi-Rotor/Wing Systems. Computers & Fluids, Elsevier BV, 215, Jan, 2021, p. 104788. Katz, J., and Plotkin, A. Low-Speed Aerodynamics . Cambridge University Press, Feb 05, 2001. Assumptions and limitations Flow solution is incompressible, inviscid and irrotational. Viscous effects in flow like dissipation and strain are included using empirical factors. Reynolds number and Mach number effects on airfoil characteristics have not been modelled directly in the solver. The Vatistas' core model is used for vortex desingularization. All vortices are rectilinear. Airfoil thickness effects are not accounted for as only the camberline surface is modelled. Input linear velocities are in inertial frame and angular velocities are in body frame. This is subject to change in future versions. Code philosophy The code is centered around the object-oriented philosophy and is built up using a hierarchical model as shown in the figure. Vortex filaments are used to contstruct wing and wake ring elements. These are further used to construct wing and wake 'sheets' which make up larger aircraft configurations. Ever geometry is assumed to be a rotor at first. For example, a fixed-wing is a non-rotating single-bladed rotor. This rather unorthodox terminology was adopted for the sake of generalization during the initial phases of development. Code organization The Fortran source files are present in the src/ folder. main.f90 drives the solver and general program flow. classdef.f90 contains attribute and method definitions for the various abstract data types. libCommon.f90 contains subroutines that work on higher-level objects and those that deal with general bookkeeping. libPostProcess.f90 contains post-processing and data write-out subroutines. libMath.f90 is an independent math library that contains operations on vectors and matrices. libC81.f90 deals with handling C81 airfoil files and is an independent library. gridgen.90 converts results from the Lagrangian to an Eulerian framework to better plot pressure and velocity fields on a traditional CFD-like domain. Data input to the solver is through the files config.nml and geom01.nml which are in namelist format. Namelist files are a Fortran specific ASCII input format that follow a variable name-value ordering. Use the provided script newcase.sh to generate templates of these files. A few utility codes are provided in tools/ to make plotting and parsing of results easier. Installation The solver has the following dependencies: CMake OpenMP LAPACK BLAS GNU Fortran or Intel Fortran compiler Python (Optional; for postprocessing) Paraview (Optional; for postprocessing) The source files utilize a CMake build system. Follow the steps below to generate the volcanor executable. Clone the Github repository using git clone git@github.com:cibinjoseph/VOLCANOR.git Create a build/ directory in the topmost folder VOLCANOR/ . Change directory to build/ . Run cmake from this directory pointing to the directory one level below. This will generate a Makefile for your OS and available compiler. Run make volcanor to compile all source files and generate the volcanor executable in the bin/ folder. On a Linux system with Intel Fortran installed, this is achieved using the following commands. mkdir build\ncd build/\nFC=ifort cmake ..\nmake volcanor","tags":"","loc":"page/index.html"},{"title":"Tutorials – VOLCANOR","text":"Warning Tutorial pages are under construction! A few tutorials are provided for using the solver. Use the index on the left to access these tutorials. The basic case directory setup described below is the same for setting up all cases. These tutorials were created for a Linux system. Case directory setup Use the newcase.sh script to generate a new 'case' directory with an arbitrary name mysimulation.case . The .case extension is a simple convention to denote a single simulation case and any preferred name may be used. ./newcash.sh mysimulation.case This bash script provides an easy way to set up a dedicated directory for a simulation by creating template input files and links to executables that are necessary to run a simulation. tree mysimulation.case/\n\nmysimulation.case/\n├── bin -> /path/to/VOLCANOR/bin\n├── config.nml\n├── geom01.nml\n├── gridconfig.nml\n├── Makefile -> /path/to/VOLCANOR/tools/Makefile\n├── Restart\n├── Results\n└── tools -> /path/to/VOLCANOR/tools In the case directory, besides the links, you will find namelist ( .nml ) files which serve as inputs to VOLCANOR. Namelist files are a Fortran specifc ASCII input format which may also be read into Python ( f90nml ) and other languages using external packages. The Results directory will contain the solution outputs when they are generated on running the solver respectively. The Restart folder holds binary records of the simulation and may be used to restart the simulation if necessary and users may ignore this directory.","tags":"","loc":"page/tutorials/index.html"},{"title":"Tutorial 1: Suddenly started rectangular wing – VOLCANOR","text":"Let's simulate a rectangular wing, suddenly started from rest into a constant freestream velocity. Case directory setup Use the newcase.sh script to generate a new 'case' directory with the name simplewing.case as described in Case directory setup . Case setup The config.nml file sets up global parameters that control the whole simulation like number of timesteps, timestep length and fluid density. For this case, the default settings should work fine. The relevant section is shown below and the number of timesteps nt is set to be computed from the time required for the wing to traverse 10 chord lengths. The timestep length dt defaults to time taken for traversing a distance 1/16th of the chord length. Intervals at which solution plots and results should be written out may be controlled in sections below the PARAMS section. & PARAMS ! NO. OF TIMESTEPS [nt]    TIMESTEP (sec) [dt]         NO. OF ROTORS [nr] ! [nt]timesteps  [0]default  [-nt]chords or revs nt = - 10 dt = 0.0 nr = 1 ! DENSITY [kg/m3]    SOUND VEL. [m/s]  KINEMATICVISC [m2/s] density = 1.0 velSound = 33 0.0 kinematicVisc = 0.000018 / Geometry required for each simulation is defined using the geomXX.nml files, where XX denotes a serial number. We shall simulate a wing of unit chord and aspect ratio 4. For the geom01.nml file, the relevant section is shown below. The parameter theta0 represent the wing pitch angle and the nomenclature is borrowed from rotorcraft conventions. The freestream velocity is set to 10 m/s using the vector velBody . Note the axis conventions used here. The negative sign is present since we are setting the velocity of the geometry which is towards the negative direction in an inertial coordinate frame. & GEOMPARAMS ! Span[m]      root_cut[r/R]      chord[m]    preconeAngle[deg] span = 4.0 rootcut = 0.0 chord = 1.0 preconeAngle = 0.0 ! Omega[rad/s]   X-shaftAxis     Y-shaftAxis     Z-shaftAxis Omega = 0.0 shaftAxis = 0.0 , 0.0 , 1.0 ! theta0[deg]    thetaC[deg]    thetaS[deg]    thetaTwist[deg] theta0 = 5.0 thetaC = 0.0 thetaS = 0.0 thetaTwist = 0.0 ! axisymmetrySwitch  [0]Off [1]On axisymmetrySwitch = 0 ! pivot point     flapHinge      spanwiseLiftTerm    invert tauSpan ! from LE[x/c]  from centre[r/R]    [1]enable     for swept/symmetric pivotLE = 0.00 flapHinge = 0.0 spanwiseLiftSwitch = 0 symmetricTau = 1 ! customTrajectorySwitch  [0]Off [1]On customTrajectorySwitch = 0 ! u[m/s]    v[m/s]     w[m/s]    p[rad/s]    q[rad/s]    r[rad/s] velBody = - 1 0.0 , 0.0 , 0.0 omegaBody = 0.0 , 0.0 , 0.0 ! forceCalcSwitch ! [0]gamma [1]alpha [2]FELS             No. of airfoil files forceCalcSwitch = 0 nAirfoils = 0 / The wing and wake discretization may be set in the PANELS section. Providing a large number of near wake rows using nNwake ensures that the wake surface is modelled with sufficient accuracy. nc and ns control the number of chordwise and spanwise panels on the wing. & PANELS ! No. of blades,nb  Prop convention [0]Helicopter [1]Prop nb = 1 propConvention = 0 ! Panel discretization [1]linear [2]cosine [3]halfsine [4]tan spanSpacing = 2 chordSpacing = 1 ! degengeom geometryFile from OpenVSP geometryFile = 0 nCamberFiles = 0 ! Chordwise panels,nc   Spanwise panels,ns nc = 4 ns = 13 ! Near wake panels,nNwake [n]timesteps [-n]chords/revs nNwake = 160 / Simulation To run the simulation we make use of the Makefile present in this case folder. Start the simulation using the make command. When the simulation is run, the current timestep is printed out on screen and a copy of the output is also written to volcanor.log . During the simulation, basic monitors like force plots can be generated using the script provided in tools/plotit.py . For example, to monitor the force coefficient, use the -f flag. ./tools/plotit.py -f We can plot the wakes during or after the simulation completes. Paraview is a powerful data visualization software that is recommended to postprocess results. Alternatives like Tecplot or VisIt can also be used. Visualize the wake by opening the r01wingNwakeXXXXX.tec tecplot files generated by the solver in the Results directory.","tags":"","loc":"page/tutorials/tutorial1.html"}]}